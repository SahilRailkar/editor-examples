{"version":3,"file":"tiptap-starter-kit.bundle.umd.min.js","sources":["../../../node_modules/prosemirror-model/src/diff.js","../../../node_modules/prosemirror-model/src/fragment.js","../../../node_modules/prosemirror-model/src/comparedeep.js","../../../node_modules/prosemirror-model/src/mark.js","../../../node_modules/prosemirror-model/src/replace.js","../../../node_modules/prosemirror-model/src/resolvedpos.js","../../../node_modules/prosemirror-model/src/node.js","../../../node_modules/prosemirror-model/src/content.js","../../../node_modules/prosemirror-model/src/schema.js","../../../node_modules/prosemirror-model/src/from_dom.js","../../../node_modules/prosemirror-model/src/to_dom.js","../../../node_modules/prosemirror-transform/src/map.js","../../../node_modules/prosemirror-transform/src/transform.js","../../../node_modules/prosemirror-transform/src/step.js","../../../node_modules/prosemirror-transform/src/replace_step.js","../../../node_modules/prosemirror-transform/src/structure.js","../../../node_modules/prosemirror-transform/src/mark_step.js","../../../node_modules/prosemirror-transform/src/replace.js","../../../node_modules/prosemirror-transform/src/mark.js","../../../node_modules/prosemirror-state/src/selection.js","../../../node_modules/prosemirror-state/src/transaction.js","../../../node_modules/prosemirror-state/src/state.js","../../../node_modules/prosemirror-state/src/plugin.js","../../../node_modules/prosemirror-dropcursor/src/dropcursor.js","../../../node_modules/w3c-keyname/index.es.js","../../../node_modules/prosemirror-keymap/src/keymap.js","../../../node_modules/prosemirror-view/src/browser.js","../../../node_modules/prosemirror-view/src/dom.js","../../../node_modules/prosemirror-view/src/domcoords.js","../../../node_modules/prosemirror-view/src/viewdesc.js","../../../node_modules/prosemirror-view/src/selection.js","../../../node_modules/prosemirror-view/src/capturekeys.js","../../../node_modules/prosemirror-view/src/domchange.js","../../../node_modules/prosemirror-view/src/clipboard.js","../../../node_modules/prosemirror-view/src/domobserver.js","../../../node_modules/prosemirror-view/src/input.js","../../../node_modules/prosemirror-view/src/decoration.js","../../../node_modules/prosemirror-view/src/index.js","../../../node_modules/prosemirror-gapcursor/src/gapcursor.js","../../../node_modules/prosemirror-gapcursor/src/index.js","../../extension-document/src/document.ts","../../extension-paragraph/src/paragraph.ts","../../extension-text/src/text.ts","../../../node_modules/rope-sequence/dist/index.es.js","../../../node_modules/prosemirror-history/src/history.js","../../extension-bold/src/bold.ts","../../extension-italic/src/italic.ts","../../../node_modules/prosemirror-inputrules/src/inputrules.js","../../../node_modules/prosemirror-inputrules/src/rulebuilders.js","../../extension-code-block/src/code-block.ts","../../extension-heading/src/heading.ts","../../../node_modules/prosemirror-commands/src/commands.js","../../extension-strike/src/strike.ts","../../extension-blockquote/src/blockquote.ts","../../extension-horizontal-rule/src/horizontal-rule.ts","../../extension-ordered-list/src/ordered-list.ts","../../extension-list-item/src/list-item.ts","../src/index.ts"],"sourcesContent":["export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?string) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?string) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted whenever a new\n  // block node is started. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNode(node, options))\n    })\n\n    return target\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  serializeNodeAndMarks(node, options = {}) {\n    let dom = this.serializeNode(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d)) result.push(d)\n  }\n  return result\n}\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\nimport {ReplaceStep, ReplaceAroundStep} from \"prosemirror-transform\"\n\nconst classesById = Object.create(null)\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nexport class Selection {\n  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])\n  // Initialize a selection with the head and anchor and ranges. If no\n  // ranges are given, constructs a single range across `$anchor` and\n  // `$head`.\n  constructor($anchor, $head, ranges) {\n    // :: [SelectionRange]\n    // The ranges covered by the selection.\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))]\n    // :: ResolvedPos\n    // The resolved anchor of the selection (the side that stays in\n    // place when the selection is modified).\n    this.$anchor = $anchor\n    // :: ResolvedPos\n    // The resolved head of the selection (the side that moves when\n    // the selection is modified).\n    this.$head = $head\n  }\n\n  // :: number\n  // The selection's anchor, as an unresolved position.\n  get anchor() { return this.$anchor.pos }\n\n  // :: number\n  // The selection's head.\n  get head() { return this.$head.pos }\n\n  // :: number\n  // The lower bound of the selection's main range.\n  get from() { return this.$from.pos }\n\n  // :: number\n  // The upper bound of the selection's main range.\n  get to() { return this.$to.pos }\n\n  // :: ResolvedPos\n  // The resolved lower  bound of the selection's main range.\n  get $from() {\n    return this.ranges[0].$from\n  }\n\n  // :: ResolvedPos\n  // The resolved upper bound of the selection's main range.\n  get $to() {\n    return this.ranges[0].$to\n  }\n\n  // :: bool\n  // Indicates whether the selection contains any content.\n  get empty() {\n    let ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos) return false\n    return true\n  }\n\n  // eq:: (Selection) → bool\n  // Test whether the selection is the same as another selection.\n\n  // map:: (doc: Node, mapping: Mappable) → Selection\n  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n  // should be the new document to which we are mapping.\n\n  // :: () → Slice\n  // Get the content of this selection as a slice.\n  content() {\n    return this.$from.node(0).slice(this.from, this.to, true)\n  }\n\n  // :: (Transaction, ?Slice)\n  // Replace the selection with a slice or, if no slice is given,\n  // delete the selection. Will append to the given transaction.\n  replace(tr, content = Slice.empty) {\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild, lastParent = null\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    }\n  }\n\n  // :: (Transaction, Node)\n  // Replace the selection with the given node, appending the changes\n  // to the given transaction.\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      let from = mapping.map($from.pos), to = mapping.map($to.pos)\n      if (i) {\n        tr.deleteRange(from, to)\n      } else {\n        tr.replaceRangeWith(from, to, node)\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)\n      }\n    }\n  }\n\n  // toJSON:: () → Object\n  // Convert the selection to a JSON representation. When implementing\n  // this for a custom selection class, make sure to give the object a\n  // `type` property whose value matches the ID under which you\n  // [registered](#state.Selection^jsonID) your class.\n\n  // :: (ResolvedPos, number, ?bool) → ?Selection\n  // Find a valid cursor or leaf node selection starting at the given\n  // position and searching back if `dir` is negative, and forward if\n  // positive. When `textOnly` is true, only consider cursor\n  // selections. Will return null when no valid selection position is\n  // found.\n  static findFrom($pos, dir, textOnly) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n    if (inner) return inner\n\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0\n          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n      if (found) return found\n    }\n  }\n\n  // :: (ResolvedPos, ?number) → Selection\n  // Find a valid cursor or leaf node selection near the given\n  // position. Searches forward first by default, but if `bias` is\n  // negative, it will search backwards first.\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the start of\n  // the given document. Will return an\n  // [`AllSelection`](#state.AllSelection) if no valid position\n  // exists.\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the end of the\n  // given document.\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n  }\n\n  // :: (Node, Object) → Selection\n  // Deserialize the JSON representation of a selection. Must be\n  // implemented for custom classes (as a static class method).\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\")\n    let cls = classesById[json.type]\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)\n    return cls.fromJSON(doc, json)\n  }\n\n  // :: (string, constructor<Selection>)\n  // To be able to deserialize selections from JSON, custom selection\n  // classes must register themselves with an ID string, so that they\n  // can be disambiguated. Try to pick something that's unlikely to\n  // clash with classes from other modules.\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id)\n    classesById[id] = selectionClass\n    selectionClass.prototype.jsonID = id\n    return selectionClass\n  }\n\n  // :: () → SelectionBookmark\n  // Get a [bookmark](#state.SelectionBookmark) for this selection,\n  // which is a value that can be mapped without having access to a\n  // current document, and later resolved to a real selection for a\n  // given document again. (This is used mostly by the history to\n  // track and restore old selections.) The default implementation of\n  // this method just converts the selection to a text selection and\n  // returns the bookmark for that.\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark()\n  }\n}\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nexport class SelectionRange {\n  // :: (ResolvedPos, ResolvedPos)\n  constructor($from, $to) {\n    // :: ResolvedPos\n    // The lower bound of the range.\n    this.$from = $from\n    // :: ResolvedPos\n    // The upper bound of the range.\n    this.$to = $to\n  }\n}\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nexport class TextSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // Construct a text selection between the given points.\n  constructor($anchor, $head = $anchor) {\n    super($anchor, $head)\n  }\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }\n\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.inlineContent) return Selection.near($head)\n    let $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  }\n\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content)\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to)\n      if (marks) tr.ensureMarks(marks)\n    }\n  }\n\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  }\n\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head)\n  }\n\n  toJSON() {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\")\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  }\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true)\n      if (found) $head = found.$head\n      else return Selection.near($head, bias)\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor\n        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head\n      }\n    }\n    return new TextSelection($anchor, $head)\n  }\n}\n\nSelection.jsonID(\"text\", TextSelection)\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n  }\n}\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nexport class NodeSelection extends Selection {\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument.\n  constructor($pos) {\n    let node = $pos.nodeAfter\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize)\n    super($pos, $end)\n    // :: Node The selected node.\n    this.node = node\n  }\n\n  map(doc, mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    let $pos = doc.resolve(pos)\n    if (deleted) return Selection.near($pos)\n    return new NodeSelection($pos)\n  }\n\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  }\n\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  }\n\n  toJSON() {\n    return {type: \"node\", anchor: this.anchor}\n  }\n\n  getBookmark() { return new NodeBookmark(this.anchor) }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\")\n    return new NodeSelection(doc.resolve(json.anchor))\n  }\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  static create(doc, from) {\n    return new this(doc.resolve(from))\n  }\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false\n  }\n}\n\nNodeSelection.prototype.visible = false\n\nSelection.jsonID(\"node\", NodeSelection)\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor\n  }\n  map(mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)\n    return Selection.near($pos)\n  }\n}\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nexport class AllSelection extends Selection {\n  // :: (Node)\n  // Create an all-selection over the given document.\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size))\n  }\n\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size)\n      let sel = Selection.atStart(tr.doc)\n      if (!sel.eq(tr.selection)) tr.setSelection(sel)\n    } else {\n      super.replace(tr, content)\n    }\n  }\n\n  toJSON() { return {type: \"all\"} }\n\n  static fromJSON(doc) { return new AllSelection(doc) }\n\n  map(doc) { return new AllSelection(doc) }\n\n  eq(other) { return other instanceof AllSelection }\n\n  getBookmark() { return AllBookmark }\n}\n\nSelection.jsonID(\"all\", AllSelection)\n\nconst AllBookmark = {\n  map() { return this },\n  resolve(doc) { return new AllSelection(doc) }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) return TextSelection.create(doc, pos)\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i)\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) return inner\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1\n  if (last < startLen) return\n  let step = tr.steps[last]\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return\n  let map = tr.mapping.maps[last], end\n  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo })\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {Transform} from \"prosemirror-transform\"\nimport {Mark} from \"prosemirror-model\"\nimport {Selection} from \"./selection\"\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nexport class Transaction extends Transform {\n  constructor(state) {\n    super(state.doc)\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  }\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\")\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  }\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0\n  }\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  setStoredMarks(marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  }\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks)\n    return this\n  }\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0\n  }\n\n  addStep(step, doc) {\n    super.addStep(step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  }\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  setTime(time) {\n    this.time = time\n    return this\n  }\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  replaceSelection(slice) {\n    this.selection.replace(this, slice)\n    return this\n  }\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  replaceSelectionWith(node, inheritMarks) {\n    let selection = this.selection\n    if (inheritMarks !== false)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))\n    selection.replaceWith(this, node)\n    return this\n  }\n\n  // :: () → Transaction\n  // Delete the selection.\n  deleteSelection() {\n    this.selection.replace(this)\n    return this\n  }\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  insertText(text, from, to = from) {\n    let schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) return this.deleteSelection()\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) return this.deleteRange(from, to)\n      let marks = this.storedMarks\n      if (!marks) {\n        let $from = this.doc.resolve(from)\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks))\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))\n      return this\n    }\n  }\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  }\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  }\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  get isGeneric() {\n    for (let _ in this.meta) return false\n    return true\n  }\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL\n    return this\n  }\n\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0\n  }\n}\n","import {Node} from \"prosemirror-model\"\n\nimport {Selection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name\n    this.init = bind(desc.init, self)\n    this.apply = bind(desc.apply, self)\n  }\n}\n\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init(config) { return config.storedMarks || null },\n    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init() { return 0 },\n    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema\n    this.fields = baseFields.concat()\n    this.plugins = []\n    this.pluginsByKey = Object.create(null)\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key])\n        throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\")\n      this.plugins.push(plugin)\n      this.pluginsByKey[plugin.key] = plugin\n      if (plugin.spec.state)\n        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin))\n    })\n  }\n}\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nexport class EditorState {\n  constructor(config) {\n    this.config = config\n  }\n\n  // doc:: Node\n  // The current document.\n\n  // selection:: Selection\n  // The selection.\n\n  // storedMarks:: ?[Mark]\n  // A set of marks to apply to the next input. Will be null when\n  // no explicit marks have been set.\n\n  // :: Schema\n  // The schema of the state's document.\n  get schema() {\n    return this.config.schema\n  }\n\n  // :: [Plugin]\n  // The plugins that are active in this state.\n  get plugins() {\n    return this.config.plugins\n  }\n\n  // :: (Transaction) → EditorState\n  // Apply the given transaction to produce a new state.\n  apply(tr) {\n    return this.applyTransaction(tr).state\n  }\n\n  // : (Transaction) → bool\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i]\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n        return false\n    }\n    return true\n  }\n\n  // :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n  // Verbose variant of [`apply`](#state.EditorState.apply) that\n  // returns the precise transactions that were applied (which might\n  // be influenced by the [transaction\n  // hooks](#state.PluginSpec.filterTransaction) of\n  // plugins) along with the new state.\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}\n\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    outer: for (;;) {\n      let haveNew = false\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i]\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this\n          let tr = n < trs.length &&\n              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr)\n            if (!seen) {\n              seen = []\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0})\n            }\n            trs.push(tr)\n            newState = newState.applyInner(tr)\n            haveNew = true\n          }\n          if (seen) seen[i] = {state: newState, n: trs.length}\n        }\n      }\n      if (!haveNew) return {state: newState, transactions: trs}\n    }\n  }\n\n  // : (Transaction) → EditorState\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\")\n    let newInstance = new EditorState(this.config), fields = this.config.fields\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i]\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance)\n    }\n    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance)\n    return newInstance\n  }\n\n  // :: Transaction\n  // Start a [transaction](#state.Transaction) from this state.\n  get tr() { return new Transaction(this) }\n\n  // :: (Object) → EditorState\n  // Create a new state.\n  //\n  //   config::- Configuration options. Must contain `schema` or `doc` (or both).\n  //\n  //      schema:: ?Schema\n  //      The schema to use (only relevant if no `doc` is specified).\n  //\n  //      doc:: ?Node\n  //      The starting document.\n  //\n  //      selection:: ?Selection\n  //      A valid selection in the document.\n  //\n  //      storedMarks:: ?[Mark]\n  //      The initial set of [stored marks](#state.EditorState.storedMarks).\n  //\n  //      plugins:: ?[Plugin]\n  //      The plugins that should be active in this state.\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins)\n    let instance = new EditorState($config)\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance)\n    return instance\n  }\n\n  // :: (Object) → EditorState\n  // Create a new state based on this one, but with an adjusted set of\n  // active plugins. State fields that exist in both sets of plugins\n  // are kept unchanged. Those that no longer exist are dropped, and\n  // those that are new are initialized using their\n  // [`init`](#state.StateField.init) method, passing in the new\n  // configuration object..\n  //\n  //   config::- configuration options\n  //\n  //     plugins:: [Plugin]\n  //     New set of active plugins.\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins)\n    let fields = $config.fields, instance = new EditorState($config)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance)\n    }\n    return instance\n  }\n\n  // :: (?union<Object<Plugin>, string, number>) → Object\n  // Serialize this state to JSON. If you want to serialize the state\n  // of plugins, pass an object mapping property names to use in the\n  // resulting JSON object to plugin objects. The argument may also be\n  // a string or number, in which case it is ignored, to support the\n  // way `JSON.stringify` calls `toString` methods.\n  toJSON(pluginFields) {\n    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON())\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\")\n        throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\")\n      let plugin = pluginFields[prop], state = plugin.spec.state\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key])\n    }\n    return result\n  }\n\n  // :: (Object, Object, ?Object<Plugin>) → EditorState\n  // Deserialize a JSON representation of a state. `config` should\n  // have at least a `schema` field, and should contain array of\n  // plugins to initialize the state with. `pluginFields` can be used\n  // to deserialize the state of plugins, by associating plugin\n  // instances with the property names they use in the JSON object.\n  //\n  //   config::- configuration options\n  //\n  //     schema:: Schema\n  //     The schema to use.\n  //\n  //     plugins:: ?[Plugin]\n  //     The set of active plugins.\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\")\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\")\n    let $config = new Configuration(config.schema, config.plugins)\n    let instance = new EditorState($config)\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc)\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection)\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON)\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop], state = plugin.spec.state\n          if (plugin.key == field.name && state && state.fromJSON &&\n              Object.prototype.hasOwnProperty.call(json, prop)) {\n            // This field belongs to a plugin mapped to a JSON field, read it from there.\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n            return\n          }\n        }\n        instance[field.name] = field.init(config, instance)\n      }\n    })\n    return instance\n  }\n\n  // Kludge to allow the view to track mappings between different\n  // instances of a state.\n  //\n  // FIXME this is no longer needed as of prosemirror-view 1.9.0,\n  // though due to backwards-compat we should probably keep it around\n  // for a while (if only as a no-op)\n  static addApplyListener(f) {\n    applyListeners.push(f)\n  }\n  static removeApplyListener(f) {\n    let found = applyListeners.indexOf(f)\n    if (found > -1) applyListeners.splice(found, 1)\n  }\n}\n\nconst applyListeners = []\n","// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop]\n    if (val instanceof Function) val = val.bind(self)\n    else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {})\n    target[prop] = val\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nexport class Plugin {\n  // :: (PluginSpec)\n  // Create a plugin.\n  constructor(spec) {\n    // :: EditorProps\n    // The [props](#view.EditorProps) exported by this plugin.\n    this.props = {}\n    if (spec.props) bindProps(spec.props, this, this.props)\n    // :: Object\n    // The plugin's [spec object](#state.PluginSpec).\n    this.spec = spec\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\")\n  }\n\n  // :: (EditorState) → any\n  // Extract the plugin's state field from an editor state.\n  getState(state) { return state[this.key] }\n}\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nconst keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name]\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nexport class PluginKey {\n  // :: (?string)\n  // Create a plugin key.\n  constructor(name = \"key\") { this.key = createKey(name) }\n\n  // :: (EditorState) → ?Plugin\n  // Get the active plugin with this key, if any, from an editor\n  // state.\n  get(state) { return state.config.pluginsByKey[this.key] }\n\n  // :: (EditorState) → ?any\n  // Get the plugin's state from an editor state.\n  getState(state) { return state[this.key] }\n}\n","import {Plugin} from \"prosemirror-state\"\nimport {dropPoint} from \"prosemirror-transform\"\n\n// :: (options: ?Object) → Plugin\n// Create a plugin that, when added to a ProseMirror instance,\n// causes a decoration to show up at the drop position when something\n// is dragged over the editor.\n//\n//   options::- These options are supported:\n//\n//     color:: ?string\n//     The color of the cursor. Defaults to `black`.\n//\n//     width:: ?number\n//     The precise width of the cursor in pixels. Defaults to 1.\n//\n//     class:: ?string\n//     A CSS class name to add to the cursor element.\nexport function dropCursor(options = {}) {\n  return new Plugin({\n    view(editorView) { return new DropCursorView(editorView, options) }\n  })\n}\n\nclass DropCursorView {\n  constructor(editorView, options) {\n    this.editorView = editorView\n    this.width = options.width || 1\n    this.color = options.color || \"black\"\n    this.class = options.class\n    this.cursorPos = null\n    this.element = null\n    this.timeout = null\n\n    this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n      let handler = e => this[name](e)\n      editorView.dom.addEventListener(name, handler)\n      return {name, handler}\n    })\n  }\n\n  destroy() {\n    this.handlers.forEach(({name, handler}) => this.editorView.dom.removeEventListener(name, handler))\n  }\n\n  update(editorView, prevState) {\n    if (this.cursorPos != null && prevState.doc != editorView.state.doc) this.updateOverlay()\n  }\n\n  setCursor(pos) {\n    if (pos == this.cursorPos) return\n    this.cursorPos = pos\n    if (pos == null) {\n      this.element.parentNode.removeChild(this.element)\n      this.element = null\n    } else {\n      this.updateOverlay()\n    }\n  }\n\n  updateOverlay() {\n    let $pos = this.editorView.state.doc.resolve(this.cursorPos), rect\n    if (!$pos.parent.inlineContent) {\n      let before = $pos.nodeBefore, after = $pos.nodeAfter\n      if (before || after) {\n        let nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ?  before.nodeSize : 0)).getBoundingClientRect()\n        let top = before ? nodeRect.bottom : nodeRect.top\n        if (before && after)\n          top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2\n        rect = {left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2}\n      }\n    }\n    if (!rect) {\n      let coords = this.editorView.coordsAtPos(this.cursorPos)\n      rect = {left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom}\n    }\n\n    let parent = this.editorView.dom.offsetParent\n    if (!this.element) {\n      this.element = parent.appendChild(document.createElement(\"div\"))\n      if (this.class) this.element.className = this.class\n      this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none; background-color: \" + this.color\n    }\n    let parentLeft, parentTop\n    if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n      parentLeft = -pageXOffset\n      parentTop = -pageYOffset\n    } else {\n      let rect = parent.getBoundingClientRect()\n      parentLeft = rect.left - parent.scrollLeft\n      parentTop = rect.top - parent.scrollTop\n    }\n    this.element.style.left = (rect.left - parentLeft) + \"px\"\n    this.element.style.top = (rect.top - parentTop) + \"px\"\n    this.element.style.width = (rect.right - rect.left) + \"px\"\n    this.element.style.height = (rect.bottom - rect.top) + \"px\"\n  }\n\n  scheduleRemoval(timeout) {\n    clearTimeout(this.timeout)\n    this.timeout = setTimeout(() => this.setCursor(null), timeout)\n  }\n\n  dragover(event) {\n    if (!this.editorView.editable) return\n    let pos = this.editorView.posAtCoords({left: event.clientX, top: event.clientY})\n    if (pos) {\n      let target = pos.pos\n      if (this.editorView.dragging && this.editorView.dragging.slice) {\n        target = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice)\n        if (target == null) return this.setCursor(null)\n      }\n      this.setCursor(target)\n      this.scheduleRemoval(5000)\n    }\n  }\n\n  dragend() {\n    this.scheduleRemoval(20)\n  }\n\n  drop() {\n    this.scheduleRemoval(20)\n  }\n\n  dragleave(event) {\n    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n      this.setCursor(null)\n  }\n}\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","import {base, keyName} from \"w3c-keyname\"\nimport {Plugin} from \"prosemirror-state\"\n\n// declare global: navigator\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") result = \" \"\n  let alt, ctrl, shift, meta\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true\n    else if (/^a(lt)?$/i.test(mod)) alt = true\n    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n    else if (/^s(hift)?$/i.test(mod)) shift = true\n    else if (/^mod$/i.test(mod)) { if (mac) meta = true; else ctrl = true }\n    else throw new Error(\"Unrecognized modifier name: \" + mod)\n  }\n  if (alt) result = \"Alt-\" + result\n  if (ctrl) result = \"Ctrl-\" + result\n  if (meta) result = \"Meta-\" + result\n  if (shift) result = \"Shift-\" + result\n  return result\n}\n\nfunction normalize(map) {\n  let copy = Object.create(null)\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop]\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name\n  if (event.ctrlKey) name = \"Ctrl-\" + name\n  if (event.metaKey) name = \"Meta-\" + name\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nexport function keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nexport function keydownHandler(bindings) {\n  let map = normalize(bindings)\n  return function(view, event) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n    let direct = map[modifiers(name, event, !isChar)]\n    if (direct && direct(view.state, view.dispatch, view)) return true\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      let fromCode = map[modifiers(baseName, event, true)]\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      let withShift = map[modifiers(name, event, true)]\n      if (withShift && withShift(view.state, view.dispatch, view)) return true\n    }\n    return false\n  }\n}\n","const result = {}\nexport default result\n\nif (typeof navigator != \"undefined\" && typeof document != \"undefined\") {\n  const ie_edge = /Edge\\/(\\d+)/.exec(navigator.userAgent)\n  const ie_upto10 = /MSIE \\d/.test(navigator.userAgent)\n  const ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n  result.mac = /Mac/.test(navigator.platform)\n  let ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge)\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null\n  result.gecko = !ie && /gecko\\/(\\d+)/i.test(navigator.userAgent)\n  result.gecko_version = result.gecko && +(/Firefox\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1]\n  let chrome = !ie && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\n  result.chrome = !!chrome\n  result.chrome_version = chrome && +chrome[1]\n  // Is true for both iOS and iPadOS for convenience\n  result.safari = !ie && /Apple Computer/.test(navigator.vendor)\n  result.ios = result.safari && (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2)\n  result.android = /Android \\d/.test(navigator.userAgent)\n  result.webkit = \"webkitFontSmoothing\" in document.documentElement.style\n  result.webkit_version = result.webkit && +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1]\n}\n","import browser from \"./browser\"\n\nexport const domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling\n    if (!node) return index\n  }\n}\n\nexport const parentNode = function(node) {\n  let parent = node.parentNode\n  return parent && parent.nodeType == 11 ? parent.host : parent\n}\n\nlet reusedRange = null\n\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nexport const textRange = function(node, from, to) {\n  let range = reusedRange || (reusedRange = document.createRange())\n  range.setEnd(node, to == null ? node.nodeValue.length : to)\n  range.setStart(node, from || 0)\n  return range\n}\n\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nexport const isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n                        scanFor(node, off, targetNode, targetOff, 1))\n}\n\nconst atomElements = /^(img|br|input|textarea|hr)$/i\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      let parent = node.parentNode\n      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        return false\n      off = domIndex(node) + (dir < 0 ? 0 : 1)\n      node = parent\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)]\n      if (node.contentEditable == \"false\") return false\n      off = dir < 0 ? nodeSize(node) : 0\n    } else {\n      return false\n    }\n  }\n}\n\nexport function nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nexport function isOnEdge(node, offset, parent) {\n  for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n    if (node == parent) return true\n    let index = domIndex(node)\n    node = node.parentNode\n    if (!node) return false\n    atStart = atStart && index == 0\n    atEnd = atEnd && index == nodeSize(node)\n  }\n}\n\nfunction hasBlockDesc(dom) {\n  let desc\n  for (let cur = dom; cur; cur = cur.parentNode) if (desc = cur.pmViewDesc) break\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)\n}\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nexport const selectionCollapsed = function(domSel) {\n  let collapsed = domSel.isCollapsed\n  if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n    collapsed = false\n  return collapsed\n}\n\nexport function keyEvent(keyCode, key) {\n  let event = document.createEvent(\"Event\")\n  event.initEvent(\"keydown\", true, true)\n  event.keyCode = keyCode\n  event.key = event.code = key\n  return event\n}\n","import {nodeSize, textRange, parentNode} from \"./dom\"\nimport browser from \"./browser\"\n\nfunction windowRect(doc) {\n  return {left: 0, right: doc.documentElement.clientWidth,\n          top: 0, bottom: doc.documentElement.clientHeight}\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side]\n}\n\nfunction clientRect(node) {\n  let rect = node.getBoundingClientRect()\n  // Adjust for elements with style \"transform: scale()\"\n  let scaleX = (rect.width / node.offsetWidth) || 1\n  let scaleY = (rect.height / node.offsetHeight) || 1\n  // Make sure scrollbar width isn't included in the rectangle\n  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,\n          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}\n}\n\nexport function scrollRectIntoView(view, rect, startDOM) {\n  let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5\n  let doc = view.dom.ownerDocument\n  for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) break\n    if (parent.nodeType != 1) continue\n    let atTop = parent == doc.body || parent.nodeType != 1\n    let bounding = atTop ? windowRect(doc) : clientRect(parent)\n    let moveX = 0, moveY = 0\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"))\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\")\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"))\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\")\n    if (moveX || moveY) {\n      if (atTop) {\n        doc.defaultView.scrollBy(moveX, moveY)\n      } else {\n        let startX = parent.scrollLeft, startY = parent.scrollTop\n        if (moveY) parent.scrollTop += moveY\n        if (moveX) parent.scrollLeft += moveX\n        let dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY\n        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY}\n      }\n    }\n    if (atTop) break\n  }\n}\n\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nexport function storeScrollPos(view) {\n  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top)\n  let refDOM, refTop\n  for (let x = (rect.left + rect.right) / 2, y = startY + 1;\n       y < Math.min(innerHeight, rect.bottom); y += 5) {\n    let dom = view.root.elementFromPoint(x, y)\n    if (dom == view.dom || !view.dom.contains(dom)) continue\n    let localRect = dom.getBoundingClientRect()\n    if (localRect.top >= startY - 20) {\n      refDOM = dom\n      refTop = localRect.top\n      break\n    }\n  }\n  return {refDOM, refTop, stack: scrollStack(view.dom)}\n}\n\nfunction scrollStack(dom) {\n  let stack = [], doc = dom.ownerDocument\n  for (; dom; dom = parentNode(dom)) {\n    stack.push({dom, top: dom.scrollTop, left: dom.scrollLeft})\n    if (dom == doc) break\n  }\n  return stack\n}\n\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nexport function resetScrollPos({refDOM, refTop, stack}) {\n  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop)\n}\n\nfunction restoreScrollStack(stack, dTop) {\n  for (let i = 0; i < stack.length; i++) {\n    let {dom, top, left} = stack[i]\n    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop\n    if (dom.scrollLeft != left) dom.scrollLeft = left\n  }\n}\n\nlet preventScrollSupported = null\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nexport function focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive() // in IE\n  if (preventScrollSupported) return dom.focus(preventScrollSupported)\n\n  let stored = scrollStack(dom)\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {preventScroll: true}\n      return true\n    }\n  } : undefined)\n  if (!preventScrollSupported) {\n    preventScrollSupported = false\n    restoreScrollStack(stored, 0)\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  let closest, dxClosest = 2e8, coordsClosest, offset = 0\n  let rowBot = coords.top, rowTop = coords.top\n  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    let rects\n    if (child.nodeType == 1) rects = child.getClientRects()\n    else if (child.nodeType == 3) rects = textRange(child).getClientRects()\n    else continue\n\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i]\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot)\n        rowTop = Math.min(rect.top, rowTop)\n        let dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0\n        if (dx < dxClosest) {\n          closest = child\n          dxClosest = dx\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords\n          if (child.nodeType == 1 && dx)\n            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        offset = childIndex + 1\n    }\n  }\n  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest)\n  if (!closest || (dxClosest && closest.nodeType == 1)) return {node, offset}\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  let len = node.nodeValue.length\n  let range = document.createRange()\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1)\n    range.setStart(node, i)\n    let rect = singleRect(range, 1)\n    if (rect.top == rect.bottom) continue\n    if (inRect(coords, rect))\n      return {node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)}\n  }\n  return {node, offset: 0}\n}\n\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&\n    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1\n}\n\nfunction targetKludge(dom, coords) {\n  let parent = dom.parentNode\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    return parent\n  return dom\n}\n\nfunction posFromElement(view, elt, coords) {\n  let {node, offset} = findOffsetInNode(elt, coords), bias = -1\n  if (node.nodeType == 1 && !node.firstChild) {\n    let rect = node.getBoundingClientRect()\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1\n  }\n  return view.docView.posFromDOM(node, offset, bias)\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  // Browser (in caretPosition/RangeFromPoint) will agressively\n  // normalize towards nearby inline nodes. Since we are interested in\n  // positions between block nodes too, we first walk up the hierarchy\n  // of nodes to see if there are block nodes that the coordinates\n  // fall outside of. If so, we take the position before/after that\n  // block. If not, we call `posFromDOM` on the raw node/offset.\n  let outside = -1\n  for (let cur = node;;) {\n    if (cur == view.dom) break\n    let desc = view.docView.nearestDesc(cur, true)\n    if (!desc) return null\n    if (desc.node.isBlock && desc.parent) {\n      let rect = desc.dom.getBoundingClientRect()\n      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore\n      else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter\n      else break\n    }\n    cur = desc.dom.parentNode\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)\n}\n\nfunction elementFromPoint(element, coords, box) {\n  let len = element.childNodes.length\n  if (len && box.top < box.bottom) {\n    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n      let child = element.childNodes[i]\n      if (child.nodeType == 1) {\n        let rects = child.getClientRects()\n        for (let j = 0; j < rects.length; j++) {\n          let rect = rects[j]\n          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect)\n        }\n      }\n      if ((i = (i + 1) % len) == startI) break\n    }\n  }\n  return element\n}\n\n// Given an x,y position on the editor, get the position in the document.\nexport function posAtCoords(view, coords) {\n  let root = view.root, node, offset\n  if (root.caretPositionFromPoint) {\n    try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n      let pos = root.caretPositionFromPoint(coords.left, coords.top)\n      if (pos) ({offsetNode: node, offset} = pos)\n    } catch (_) {}\n  }\n  if (!node && root.caretRangeFromPoint) {\n    let range = root.caretRangeFromPoint(coords.left, coords.top)\n    if (range) ({startContainer: node, startOffset: offset} = range)\n  }\n\n  let elt = root.elementFromPoint(coords.left, coords.top + 1), pos\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    let box = view.dom.getBoundingClientRect()\n    if (!inRect(coords, box)) return null\n    elt = elementFromPoint(view.dom, coords, box)\n    if (!elt) return null\n  }\n  // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n  if (browser.safari && elt.draggable) node = offset = null\n  elt = targetKludge(elt, coords)\n  if (node) {\n    if (browser.gecko && node.nodeType == 1) {\n      // Firefox will sometimes return offsets into <input> nodes, which\n      // have no actual children, from caretPositionFromPoint (#953)\n      offset = Math.min(offset, node.childNodes.length)\n      // It'll also move the returned position before image nodes,\n      // even if those are behind it.\n      if (offset < node.childNodes.length) {\n        let next = node.childNodes[offset], box\n        if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left &&\n            box.bottom > coords.top)\n          offset++\n      }\n    }\n    // Suspiciously specific kludge to work around caret*FromPoint\n    // never returning a position at the end of the document\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n        coords.top > node.lastChild.getBoundingClientRect().bottom)\n      pos = view.state.doc.content.size\n    // Ignore positions directly after a BR, since caret*FromPoint\n    // 'round up' positions that would be more accurately placed\n    // before the BR node.\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      pos = posFromCaret(view, node, offset, coords)\n  }\n  if (pos == null) pos = posFromElement(view, elt, coords)\n\n  let desc = view.docView.nearestDesc(elt, true)\n  return {pos, inside: desc ? desc.posAtStart - desc.border : -1}\n}\n\nfunction singleRect(object, bias) {\n  let rects = object.getClientRects()\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/\n\n// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nexport function coordsAtPos(view, pos, side) {\n  let {node, offset} = view.docView.domFromPos(pos, side < 0 ? -1 : 1)\n\n  let supportEmptyRange = browser.webkit || browser.gecko\n  if (node.nodeType == 3) {\n    // These browsers support querying empty text ranges. Prefer that in\n    // bidi context or when at the end of a node.\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      let rect = singleRect(textRange(node, offset, offset), side)\n      // Firefox returns bad results (the position before the space)\n      // when querying a position directly after line-broken\n      // whitespace. Detect this situation and and kludge around it\n      if (browser.gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1)\n        if (rectBefore.top == rect.top) {\n          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1)\n          if (rectAfter.top != rect.top)\n            return flattenV(rectAfter, rectAfter.left < rectBefore.left)\n        }\n      }\n      return rect\n    } else {\n      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1\n      if (side < 0 && !offset) { to++; takeSide = -1 }\n      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1 }\n      else if (side < 0) { from-- }\n      else { to ++ }\n      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)\n    }\n  }\n\n  // Return a horizontal line in block context\n  if (!view.state.doc.resolve(pos).parent.inlineContent) {\n    if (offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1]\n      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false)\n    }\n    if (offset < nodeSize(node)) {\n      let after = node.childNodes[offset]\n      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true)\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0)\n  }\n\n  // Inline, not in text node (this is not Bidi-safe)\n  if (offset && (side < 0 || offset == nodeSize(node))) {\n    let before = node.childNodes[offset - 1]\n    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n        // BR nodes tend to only return the rectangle before them.\n        // Only use them if they are the last element in their parent\n        : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null\n    if (target) return flattenV(singleRect(target, 1), false)\n  }\n  if (offset < nodeSize(node)) {\n    let after = node.childNodes[offset]\n    let target = after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n        : after.nodeType == 1 ? after : null\n    if (target) return flattenV(singleRect(target, -1), true)\n  }\n  // All else failed, just try to get a rectangle for the target node\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)\n}\n\nfunction flattenV(rect, left) {\n  if (rect.width == 0) return rect\n  let x = left ? rect.left : rect.right\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\n\nfunction flattenH(rect, top) {\n  if (rect.height == 0) return rect\n  let y = top ? rect.top : rect.bottom\n  return {top: y, bottom: y, left: rect.left, right: rect.right}\n}\n\nfunction withFlushedState(view, state, f) {\n  let viewState = view.state, active = view.root.activeElement\n  if (viewState != state) view.updateState(state)\n  if (active != view.dom) view.focus()\n  try {\n    return f()\n  } finally {\n    if (viewState != state) view.updateState(viewState)\n    if (active != view.dom && active) active.focus()\n  }\n}\n\n// : (EditorView, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  let sel = state.selection\n  let $pos = dir == \"up\" ? sel.$from : sel.$to\n  return withFlushedState(view, state, () => {\n    let {node: dom} = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1)\n    for (;;) {\n      let nearest = view.docView.nearestDesc(dom, true)\n      if (!nearest) break\n      if (nearest.node.isBlock) { dom = nearest.dom; break }\n      dom = nearest.dom.parentNode\n    }\n    let coords = coordsAtPos(view, $pos.pos, 1)\n    for (let child = dom.firstChild; child; child = child.nextSibling) {\n      let boxes\n      if (child.nodeType == 1) boxes = child.getClientRects()\n      else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects()\n      else continue\n      for (let i = 0; i < boxes.length; i++) {\n        let box = boxes[i]\n        if (box.bottom > box.top && (dir == \"up\" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))\n          return false\n      }\n    }\n    return true\n  })\n}\n\nconst maybeRTL = /[\\u0590-\\u08ac]/\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  let {$head} = state.selection\n  if (!$head.parent.isTextblock) return false\n  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size\n  let sel = getSelection()\n  // If the textblock is all LTR, or the browser doesn't support\n  // Selection.modify (Edge), fall back to a primitive approach\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    return dir == \"left\" || dir == \"backward\" ? atStart : atEnd\n\n  return withFlushedState(view, state, () => {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset\n    let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n    sel.modify(\"move\", dir, \"character\")\n    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom\n    let result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        (oldNode == sel.focusNode && oldOff == sel.focusOffset)\n    // Restore the previous selection\n    sel.removeAllRanges()\n    sel.addRange(oldRange)\n    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel\n    return result\n  })\n}\n\nlet cachedState = null, cachedDir = null, cachedResult = false\nexport function endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) return cachedResult\n  cachedState = state; cachedDir = dir\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\n","import {DOMSerializer, Fragment, Mark} from \"prosemirror-model\"\nimport {TextSelection} from \"prosemirror-state\"\n\nimport {domIndex, isEquivalentPosition, nodeSize} from \"./dom\"\nimport browser from \"./browser\"\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, you want more control over\n// the behavior of a node's in-editor representation, and need to\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n// Mark views only support `dom` and `contentDOM`, and don't support\n// any of the node view methods.\n//\n// Objects returned as node views must conform to this interface.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), an array\n//   of active decorations around the node (which are automatically\n//   drawn, and the node view may ignore if it isn't interested in\n//   them), and a [decoration source](#view.DecorationSource) that\n//   represents any decorations that apply to the content of the node\n//   (which again may be ignored). It should return true if it was\n//   able to update to that node, and false otherwise. If the node\n//   view has a `contentDOM` property (or no `dom` property), updating\n//   its child nodes will be handled by ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to remove the effect again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. The `anchor` and `head` positions are relative to the start\n//   of the node. By default, a DOM selection will be created between\n//   the DOM positions corresponding to those positions, but if you\n//   override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view. Events for\n//   which this returns true are not handled by the editor.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   or a selection change happens within the view. When the change is\n//   a selection change, the record will have a `type` property of\n//   `\"selection\"` (which doesn't occur for native mutation records).\n//   Return false if the editor should re-read the selection or\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is destroyed. (Not available for marks.)\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n  // : (?ViewDesc, [ViewDesc], dom.Node, ?dom.Node)\n  constructor(parent, children, dom, contentDOM) {\n    this.parent = parent\n    this.children = children\n    this.dom = dom\n    // An expando property on the DOM node provides a link back to its\n    // description.\n    dom.pmViewDesc = this\n    // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    this.contentDOM = contentDOM\n    this.dirty = NOT_DIRTY\n  }\n\n  // Used to check whether a given description corresponds to a\n  // widget/mark/node.\n  matchesWidget() { return false }\n  matchesMark() { return false }\n  matchesNode() { return false }\n  matchesHack() { return false }\n\n  get beforePosition() { return false }\n\n  // : () → ?ParseRule\n  // When parsing in-editor content (in domchange.js), we allow\n  // descriptions to determine the parse rules that should be used to\n  // parse them.\n  parseRule() { return null }\n\n  // : (dom.Event) → bool\n  // Used by the editor's event handler to ignore events that come\n  // from certain descs.\n  stopEvent() { return false }\n\n  // The size of the content represented by this desc.\n  get size() {\n    let size = 0\n    for (let i = 0; i < this.children.length; i++) size += this.children[i].size\n    return size\n  }\n\n  // For block nodes, this represents the space taken up by their\n  // start/end tokens.\n  get border() { return 0 }\n\n  destroy() {\n    this.parent = null\n    if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = null\n    for (let i = 0; i < this.children.length; i++)\n      this.children[i].destroy()\n  }\n\n  posBeforeChild(child) {\n    for (let i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n      let cur = this.children[i]\n      if (cur == child) return pos\n      pos += cur.size\n    }\n  }\n\n  get posBefore() {\n    return this.parent.posBeforeChild(this)\n  }\n\n  get posAtStart() {\n    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n  }\n\n  get posAfter() {\n    return this.posBefore + this.size\n  }\n\n  get posAtEnd() {\n    return this.posAtStart + this.size - 2 * this.border\n  }\n\n  // : (dom.Node, number, ?number) → number\n  localPosFromDOM(dom, offset, bias) {\n    // If the DOM position is in the content, use the child desc after\n    // it to figure out a position.\n    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n      if (bias < 0) {\n        let domBefore, desc\n        if (dom == this.contentDOM) {\n          domBefore = dom.childNodes[offset - 1]\n        } else {\n          while (dom.parentNode != this.contentDOM) dom = dom.parentNode\n          domBefore = dom.previousSibling\n        }\n        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling\n        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n      } else {\n        let domAfter, desc\n        if (dom == this.contentDOM) {\n          domAfter = dom.childNodes[offset]\n        } else {\n          while (dom.parentNode != this.contentDOM) dom = dom.parentNode\n          domAfter = dom.nextSibling\n        }\n        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this)) domAfter = domAfter.nextSibling\n        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd\n      }\n    }\n    // Otherwise, use various heuristics, falling back on the bias\n    // parameter, to determine whether to return the position at the\n    // start or at the end of this view desc.\n    let atEnd\n    if (dom == this.dom && this.contentDOM) {\n      atEnd = offset > domIndex(this.contentDOM)\n    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2\n    } else if (this.dom.firstChild) {\n      if (offset == 0) for (let search = dom;; search = search.parentNode) {\n        if (search == this.dom) { atEnd = false; break }\n        if (search.parentNode.firstChild != search) break\n      }\n      if (atEnd == null && offset == dom.childNodes.length) for (let search = dom;; search = search.parentNode) {\n        if (search == this.dom) { atEnd = true; break }\n        if (search.parentNode.lastChild != search) break\n      }\n    }\n    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n  }\n\n  // Scan up the dom finding the first desc that is a descendant of\n  // this one.\n  nearestDesc(dom, onlyNodes) {\n    for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n      let desc = this.getDesc(cur)\n      if (desc && (!onlyNodes || desc.node)) {\n        // If dom is outside of this desc's nodeDOM, don't count it.\n        if (first && desc.nodeDOM &&\n            !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))\n          first = false\n        else\n          return desc\n      }\n    }\n  }\n\n  getDesc(dom) {\n    let desc = dom.pmViewDesc\n    for (let cur = desc; cur; cur = cur.parent) if (cur == this) return desc\n  }\n\n  posFromDOM(dom, offset, bias) {\n    for (let scan = dom; scan; scan = scan.parentNode) {\n      let desc = this.getDesc(scan)\n      if (desc) return desc.localPosFromDOM(dom, offset, bias)\n    }\n    return -1\n  }\n\n  // : (number) → ?NodeViewDesc\n  // Find the desc for the node after the given pos, if any. (When a\n  // parent node overrode rendering, there might not be one.)\n  descAt(pos) {\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (offset == pos && end != offset) {\n        while (!child.border && child.children.length) child = child.children[0]\n        return child\n      }\n      if (pos < end) return child.descAt(pos - offset - child.border)\n      offset = end\n    }\n  }\n\n  // : (number, number) → {node: dom.Node, offset: number}\n  domFromPos(pos, side) {\n    if (!this.contentDOM) return {node: this.dom, offset: 0}\n    for (let offset = 0, i = 0, first = true;; i++, first = false) {\n      // Skip removed or always-before children\n      while (i < this.children.length && (this.children[i].beforePosition ||\n                                          this.children[i].dom.parentNode != this.contentDOM))\n        offset += this.children[i++].size\n      let child = i == this.children.length ? null : this.children[i]\n      if (offset == pos && (side == 0 || !child || !child.size || child.border || (side < 0 && first)) ||\n          child && child.domAtom && pos < offset + child.size) return {\n        node: this.contentDOM,\n        offset: child ? domIndex(child.dom) : this.contentDOM.childNodes.length\n      }\n      if (!child) throw new Error(\"Invalid position \" + pos)\n      let end = offset + child.size\n      if (!child.domAtom && (side < 0 && !child.border ? end >= pos : end > pos) &&\n          (end > pos || i + 1 >= this.children.length || !this.children[i + 1].beforePosition))\n        return child.domFromPos(pos - offset - child.border, side)\n      offset = end\n    }\n  }\n\n  // Used to find a DOM range in a single parent for a given changed\n  // range.\n  parseRange(from, to, base = 0) {\n    if (this.children.length == 0)\n      return {node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length}\n\n    let fromOffset = -1, toOffset = -1\n    for (let offset = base, i = 0;; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (fromOffset == -1 && from <= end) {\n        let childBase = offset + child.border\n        // FIXME maybe descend mark views to parse a narrower range?\n        if (from >= childBase && to <= end - child.border && child.node &&\n            child.contentDOM && this.contentDOM.contains(child.contentDOM))\n          return child.parseRange(from, to, childBase)\n\n        from = offset\n        for (let j = i; j > 0; j--) {\n          let prev = this.children[j - 1]\n          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n            fromOffset = domIndex(prev.dom) + 1\n            break\n          }\n          from -= prev.size\n        }\n        if (fromOffset == -1) fromOffset = 0\n      }\n      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n        to = end\n        for (let j = i + 1; j < this.children.length; j++) {\n          let next = this.children[j]\n          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n            toOffset = domIndex(next.dom)\n            break\n          }\n          to += next.size\n        }\n        if (toOffset == -1) toOffset = this.contentDOM.childNodes.length\n        break\n      }\n      offset = end\n    }\n    return {node: this.contentDOM, from, to, fromOffset, toOffset}\n  }\n\n  emptyChildAt(side) {\n    if (this.border || !this.contentDOM || !this.children.length) return false\n    let child = this.children[side < 0 ? 0 : this.children.length - 1]\n    return child.size == 0 || child.emptyChildAt(side)\n  }\n\n  // : (number) → dom.Node\n  domAfterPos(pos) {\n    let {node, offset} = this.domFromPos(pos, 0)\n    if (node.nodeType != 1 || offset == node.childNodes.length)\n      throw new RangeError(\"No node after pos \" + pos)\n    return node.childNodes[offset]\n  }\n\n  // : (number, number, dom.Document)\n  // View descs are responsible for setting any selection that falls\n  // entirely inside of them, so that custom implementations can do\n  // custom things with the selection. Note that this falls apart when\n  // a selection starts in such a node and ends in another, in which\n  // case we just use whatever domFromPos produces as a best effort.\n  setSelection(anchor, head, root, force) {\n    // If the selection falls entirely in a child, give it to that child\n    let from = Math.min(anchor, head), to = Math.max(anchor, head)\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (from > offset && to < end)\n        return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force)\n      offset = end\n    }\n\n    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1)\n    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1)\n    let domSel = root.getSelection()\n\n    let brKludge = false\n    // On Firefox, using Selection.collapse to put the cursor after a\n    // BR node for some reason doesn't always work (#1073). On Safari,\n    // the cursor sometimes inexplicable visually lags behind its\n    // reported position in such situations (#1092).\n    if ((browser.gecko || browser.safari) && anchor == head) {\n      let {node, offset} = anchorDOM\n      if (node.nodeType == 3) {\n        brKludge = offset && node.nodeValue[offset - 1] == \"\\n\"\n        // Issue #1128\n        if (brKludge && offset == node.nodeValue.length &&\n            node.nextSibling && node.nextSibling.nodeName == \"BR\")\n          anchorDOM = headDOM = {node: node.parentNode, offset: domIndex(node) + 1}\n      } else {\n        let prev = node.childNodes[offset - 1]\n        brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\")\n      }\n    }\n\n    if (!(force || brKludge && browser.safari) &&\n        isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n        isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n      return\n\n    // Selection.extend can be used to create an 'inverted' selection\n    // (one where the focus is before the anchor), but not all\n    // browsers support it yet.\n    let domSelExtended = false\n    if ((domSel.extend || anchor == head) && !brKludge) {\n      domSel.collapse(anchorDOM.node, anchorDOM.offset)\n      try {\n        if (anchor != head) domSel.extend(headDOM.node, headDOM.offset)\n        domSelExtended = true\n      } catch (err) {\n        // In some cases with Chrome the selection is empty after calling\n        // collapse, even when it should be valid. This appears to be a bug, but\n        // it is difficult to isolate. If this happens fallback to the old path\n        // without using extend.\n        if (!(err instanceof DOMException)) throw err\n        // declare global: DOMException\n      }\n    }\n    if (!domSelExtended) {\n      if (anchor > head) { let tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp }\n      let range = document.createRange()\n      range.setEnd(headDOM.node, headDOM.offset)\n      range.setStart(anchorDOM.node, anchorDOM.offset)\n      domSel.removeAllRanges()\n      domSel.addRange(range)\n    }\n  }\n\n  // : (dom.MutationRecord) → bool\n  ignoreMutation(mutation) {\n    return !this.contentDOM && mutation.type != \"selection\"\n  }\n\n  get contentLost() {\n    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)\n  }\n\n  // Remove a subtree of the element tree that has been touched\n  // by a DOM change, so that the next update will redraw it.\n  markDirty(from, to) {\n    for (let offset = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n        let startInside = offset + child.border, endInside = end - child.border\n        if (from >= startInside && to <= endInside) {\n          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY\n          if (from == startInside && to == endInside &&\n              (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY\n          else child.markDirty(from - startInside, to - startInside)\n          return\n        } else {\n          child.dirty = NODE_DIRTY\n        }\n      }\n      offset = end\n    }\n    this.dirty = CONTENT_DIRTY\n  }\n\n  markParentsDirty() {\n    let level = 1\n    for (let node = this.parent; node; node = node.parent, level++) {\n      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY\n      if (node.dirty < dirty) node.dirty = dirty\n    }\n  }\n\n  get domAtom() { return false }\n}\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nconst nothing = []\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n  // : (ViewDesc, Decoration)\n  constructor(parent, widget, view, pos) {\n    let self, dom = widget.type.toDOM\n    if (typeof dom == \"function\") dom = dom(view, () => {\n      if (!self) return pos\n      if (self.parent) return self.parent.posBeforeChild(self)\n    })\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        let wrap = document.createElement(\"span\")\n        wrap.appendChild(dom)\n        dom = wrap\n      }\n      dom.contentEditable = false\n      dom.classList.add(\"ProseMirror-widget\")\n    }\n    super(parent, nothing, dom, null)\n    this.widget = widget\n    self = this\n  }\n\n  get beforePosition() {\n    return this.widget.type.side < 0\n  }\n\n  matchesWidget(widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)\n  }\n\n  parseRule() { return {ignore: true} }\n\n  stopEvent(event) {\n    let stop = this.widget.spec.stopEvent\n    return stop ? stop(event) : false\n  }\n\n  ignoreMutation(mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection\n  }\n\n  get domAtom() { return true }\n}\n\nclass CompositionViewDesc extends ViewDesc {\n  constructor(parent, dom, textDOM, text) {\n    super(parent, nothing, dom, null)\n    this.textDOM = textDOM\n    this.text = text\n  }\n\n  get size() { return this.text.length }\n\n  localPosFromDOM(dom, offset) {\n    if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0)\n    return this.posAtStart + offset\n  }\n\n  domFromPos(pos) {\n    return {node: this.textDOM, offset: pos}\n  }\n\n  ignoreMutation(mut) {\n    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue\n   }\n}\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n  // : (ViewDesc, Mark, dom.Node)\n  constructor(parent, mark, dom, contentDOM) {\n    super(parent, [], dom, contentDOM)\n    this.mark = mark\n  }\n\n  static create(parent, mark, inline, view) {\n    let custom = view.nodeViews[mark.type.name]\n    let spec = custom && custom(mark, view, inline)\n    if (!spec || !spec.dom)\n      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline))\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)\n  }\n\n  parseRule() { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} }\n\n  matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) }\n\n  markDirty(from, to) {\n    super.markDirty(from, to)\n    // Move dirty info to nearest node view\n    if (this.dirty != NOT_DIRTY) {\n      let parent = this.parent\n      while (!parent.node) parent = parent.parent\n      if (parent.dirty < this.dirty) parent.dirty = this.dirty\n      this.dirty = NOT_DIRTY\n    }\n  }\n\n  slice(from, to, view) {\n    let copy = MarkViewDesc.create(this.parent, this.mark, true, view)\n    let nodes = this.children, size = this.size\n    if (to < size) nodes = replaceNodes(nodes, to, size, view)\n    if (from > 0) nodes = replaceNodes(nodes, 0, from, view)\n    for (let i = 0; i < nodes.length; i++) nodes[i].parent = copy\n    copy.children = nodes\n    return copy\n  }\n}\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n  // : (?ViewDesc, Node, [Decoration], DecorationSource, dom.Node, ?dom.Node, EditorView)\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    super(parent, node.isLeaf ? nothing : [], dom, contentDOM)\n    this.nodeDOM = nodeDOM\n    this.node = node\n    this.outerDeco = outerDeco\n    this.innerDeco = innerDeco\n    if (contentDOM) this.updateChildren(view, pos)\n  }\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finnicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  static create(parent, node, outerDeco, innerDeco, view, pos) {\n    let custom = view.nodeViews[node.type.name], descObj\n    let spec = custom && custom(node, view, () => {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (!descObj) return pos\n      if (descObj.parent) return descObj.parent.posBeforeChild(descObj)\n    }, outerDeco, innerDeco)\n\n    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM\n    if (node.isText) {\n      if (!dom) dom = document.createTextNode(node.text)\n      else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\")\n    } else if (!dom) {\n      ;({dom, contentDOM} = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)))\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n      if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = false\n      if (node.type.spec.draggable) dom.draggable = true\n    }\n\n    let nodeDOM = dom\n    dom = applyOuterDeco(dom, outerDeco, node)\n\n    if (spec)\n      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,\n                                              spec, view, pos + 1)\n    else if (node.isText)\n      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view)\n    else\n      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1)\n  }\n\n  parseRule() {\n    // Experimental kludge to allow opt-in re-parsing of nodes\n    if (this.node.type.spec.reparseInView) return null\n    // FIXME the assumption that this can always return the current\n    // attrs means that if the user somehow manages to change the\n    // attrs in the dom, that won't be picked up. Not entirely sure\n    // whether this is a problem\n    let rule = {node: this.node.type.name, attrs: this.node.attrs}\n    if (this.node.type.spec.code) rule.preserveWhitespace = \"full\"\n    if (this.contentDOM && !this.contentLost) rule.contentElement = this.contentDOM\n    else rule.getContent = () => this.contentDOM ? Fragment.empty : this.node.content\n    return rule\n  }\n\n  matchesNode(node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  }\n\n  get size() { return this.node.nodeSize }\n\n  get border() { return this.node.isLeaf ? 0 : 1 }\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  updateChildren(view, pos) {\n    let inline = this.node.inlineContent, off = pos\n    let composition = inline && view.composing && this.localCompositionNode(view, pos)\n    let updater = new ViewTreeUpdater(this, composition && composition.node)\n    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n      if (widget.spec.marks)\n        updater.syncToMarks(widget.spec.marks, inline, view)\n      else if (widget.type.side >= 0 && !insideNode)\n        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view)\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget, view, off)\n    }, (child, outerDeco, innerDeco, i) => {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, inline, view)\n      // Either find an existing desc that exactly matches this node,\n      // and drop the descs before it.\n      updater.findNodeMatch(child, outerDeco, innerDeco, i) ||\n        // Or try updating the next desc to reflect this node.\n        updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||\n        // Or just add it as a new desc.\n        updater.addNode(child, outerDeco, innerDeco, view, off)\n      off += child.nodeSize\n    })\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, inline, view)\n    if (this.node.isTextblock) updater.addTextblockHacks()\n    updater.destroyRest()\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      // May have to protect focused DOM from being changed if a composition is active\n      if (composition) this.protectLocalComposition(view, composition)\n      renderDescs(this.contentDOM, this.children, view)\n      if (browser.ios) iosHacks(this.dom)\n    }\n  }\n\n  localCompositionNode(view, pos) {\n    // Only do something if both the selection and a focused text node\n    // are inside of this node, and the node isn't already part of a\n    // view that's a child of this view\n    let {from, to} = view.state.selection\n    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) return\n    let sel = view.root.getSelection()\n    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset)\n    if (!textNode || !this.dom.contains(textNode.parentNode)) return\n\n    // Find the text in the focused node in the node, stop if it's not\n    // there (may have been modified through other means, in which\n    // case it should overwritten)\n    let text = textNode.nodeValue\n    let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos)\n\n    return textPos < 0 ? null : {node: textNode, pos: textPos, text}\n  }\n\n  protectLocalComposition(view, {node, pos, text}) {\n    // The node is already part of a local view desc, leave it there\n    if (this.getDesc(node)) return\n\n    // Create a composition view for the orphaned nodes\n    let topNode = node\n    for (;; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM) break\n      while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling)\n      while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling)\n      if (topNode.pmViewDesc) topNode.pmViewDesc = null\n    }\n    let desc = new CompositionViewDesc(this, topNode, node, text)\n    view.compositionNodes.push(desc)\n\n    // Patch up this.children to contain the composition view\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc)\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) return false\n    this.updateInner(node, outerDeco, innerDeco, view)\n    return true\n  }\n\n  updateInner(node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco)\n    this.node = node\n    this.innerDeco = innerDeco\n    if (this.contentDOM) this.updateChildren(view, this.posAtStart)\n    this.dirty = NOT_DIRTY\n  }\n\n  updateOuterDeco(outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) return\n    let needsWrap = this.nodeDOM.nodeType != 1\n    let oldDOM = this.dom\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap))\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = null\n      this.dom.pmViewDesc = this\n    }\n    this.outerDeco = outerDeco\n  }\n\n  // Mark this node as being the selected node.\n  selectNode() {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\")\n    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true\n  }\n\n  // Remove selected node marking from this node.\n  deselectNode() {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\")\n    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\")\n  }\n\n  get domAtom() { return this.node.isAtom }\n}\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nexport function docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc)\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)\n}\n\nclass TextViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view)\n  }\n\n  parseRule() {\n    let skip = this.nodeDOM.parentNode\n    while (skip && skip != this.dom && !skip.pmIsDeco) skip = skip.parentNode\n    return {skip: skip || true}\n  }\n\n  update(node, outerDeco, _, view) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n        !node.sameMarkup(this.node)) return false\n    this.updateOuterDeco(outerDeco)\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text\n      if (view.trackWrites == this.nodeDOM) view.trackWrites = null\n    }\n    this.node = node\n    this.dirty = NOT_DIRTY\n    return true\n  }\n\n  inParent() {\n    let parentDOM = this.parent.contentDOM\n    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true\n    return false\n  }\n\n  domFromPos(pos) {\n    return {node: this.nodeDOM, offset: pos}\n  }\n\n  localPosFromDOM(dom, offset, bias) {\n    if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length)\n    return super.localPosFromDOM(dom, offset, bias)\n  }\n\n  ignoreMutation(mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\"\n  }\n\n  slice(from, to, view) {\n    let node = this.node.cut(from, to), dom = document.createTextNode(node.text)\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)\n  }\n\n  get domAtom() { return false }\n}\n\n// A dummy desc used to tag trailing BR or span nodes created to work\n// around contentEditable terribleness.\nclass BRHackViewDesc extends ViewDesc {\n  parseRule() { return {ignore: true} }\n  matchesHack() { return this.dirty == NOT_DIRTY }\n  get domAtom() { return true }\n}\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n  // : (?ViewDesc, Node, [Decoration], DecorationSource, dom.Node, ?dom.Node, NodeView, EditorView)\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos)\n    this.spec = spec\n  }\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY) return false\n    if (this.spec.update) {\n      let result = this.spec.update(node, outerDeco, innerDeco)\n      if (result) this.updateInner(node, outerDeco, innerDeco, view)\n      return result\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return super.update(node, outerDeco, innerDeco, view)\n    }\n  }\n\n  selectNode() {\n    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()\n  }\n\n  deselectNode() {\n    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()\n  }\n\n  setSelection(anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n      : super.setSelection(anchor, head, root, force)\n  }\n\n  destroy() {\n    if (this.spec.destroy) this.spec.destroy()\n    super.destroy()\n  }\n\n  stopEvent(event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  }\n\n  ignoreMutation(mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation)\n  }\n}\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n  let dom = parentDOM.firstChild, written = false\n  for (let i = 0; i < descs.length; i++) {\n    let desc = descs[i], childDOM = desc.dom\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom); written = true }\n      dom = dom.nextSibling\n    } else {\n      written = true\n      parentDOM.insertBefore(childDOM, dom)\n    }\n    if (desc instanceof MarkViewDesc) {\n      let pos = dom ? dom.previousSibling : parentDOM.lastChild\n      renderDescs(desc.contentDOM, desc.children, view)\n      dom = pos ? pos.nextSibling : parentDOM.firstChild\n    }\n  }\n  while (dom) { dom = rm(dom); written = true }\n  if (written && view.trackWrites == parentDOM) view.trackWrites = null\n}\n\nfunction OuterDecoLevel(nodeName) {\n  if (nodeName) this.nodeName = nodeName\n}\nOuterDecoLevel.prototype = Object.create(null)\n\nconst noDeco = [new OuterDecoLevel]\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) return noDeco\n\n  let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top]\n\n  for (let i = 0; i < outerDeco.length; i++) {\n    let attrs = outerDeco[i].type.attrs\n    if (!attrs) continue\n    if (attrs.nodeName)\n      result.push(top = new OuterDecoLevel(attrs.nodeName))\n\n    for (let name in attrs) {\n      let val = attrs[name]\n      if (val == null) continue\n      if (needsWrap && result.length == 1)\n        result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"))\n      if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val\n      else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val\n      else if (name != \"nodeName\") top[name] = val\n    }\n  }\n\n  return result\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM\n\n  let curDOM = nodeDOM\n  for (let i = 0; i < curComputed.length; i++) {\n    let deco = curComputed[i], prev = prevComputed[i]\n    if (i) {\n      let parent\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent\n      } else {\n        parent = document.createElement(deco.nodeName)\n        parent.pmIsDeco = true\n        parent.appendChild(curDOM)\n        prev = noDeco[0]\n        curDOM = parent\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco)\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (let name in prev)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      dom.removeAttribute(name)\n  for (let name in cur)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n      dom.setAttribute(name, cur[name])\n  if (prev.class != cur.class) {\n    let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : nothing\n    let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : nothing\n    for (let i = 0; i < prevList.length; i++) if (curList.indexOf(prevList[i]) == -1)\n      dom.classList.remove(prevList[i])\n    for (let i = 0; i < curList.length; i++) if (prevList.indexOf(curList[i]) == -1)\n      dom.classList.add(curList[i])\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m\n      while (m = prop.exec(prev.style))\n        dom.style.removeProperty(m[1])\n    }\n    if (cur.style)\n      dom.style.cssText += cur.style\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (!a[i].type.eq(b[i].type)) return false\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  let next = dom.nextSibling\n  dom.parentNode.removeChild(dom)\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n  // : (NodeViewDesc)\n  constructor(top, lockedNode) {\n    this.top = top\n    this.lock = lockedNode\n    // Index into `this.top`'s child array, represents the current\n    // update position.\n    this.index = 0\n    // When entering a mark, the current top and index are pushed\n    // onto this.\n    this.stack = []\n    // Tracks whether anything was changed\n    this.changed = false\n\n    this.preMatch = preMatch(top.node.content, top.children)\n  }\n\n  // Destroy and remove the children between the given indices in\n  // `this.top`.\n  destroyBetween(start, end) {\n    if (start == end) return\n    for (let i = start; i < end; i++) this.top.children[i].destroy()\n    this.top.children.splice(start, end - start)\n    this.changed = true\n  }\n\n  // Destroy all remaining children in `this.top`.\n  destroyRest() {\n    this.destroyBetween(this.index, this.top.children.length)\n  }\n\n  // : ([Mark], EditorView)\n  // Sync the current stack of mark descs with the given array of\n  // marks, reusing existing mark descs when possible.\n  syncToMarks(marks, inline, view) {\n    let keep = 0, depth = this.stack.length >> 1\n    let maxKeep = Math.min(depth, marks.length)\n    while (keep < maxKeep &&\n           (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n      keep++\n\n    while (keep < depth) {\n      this.destroyRest()\n      this.top.dirty = NOT_DIRTY\n      this.index = this.stack.pop()\n      this.top = this.stack.pop()\n      depth--\n    }\n    while (depth < marks.length) {\n      this.stack.push(this.top, this.index + 1)\n      let found = -1\n      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n        if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }\n      }\n      if (found > -1) {\n        if (found > this.index) {\n          this.changed = true\n          this.destroyBetween(this.index, found)\n        }\n        this.top = this.top.children[this.index]\n      } else {\n        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view)\n        this.top.children.splice(this.index, 0, markDesc)\n        this.top = markDesc\n        this.changed = true\n      }\n      this.index = 0\n      depth++\n    }\n  }\n\n  // : (Node, [Decoration], DecorationSource) → bool\n  // Try to find a node desc matching the given data. Skip over it and\n  // return true when successful.\n  findNodeMatch(node, outerDeco, innerDeco, index) {\n    let children = this.top.children, found = -1\n    if (index >= this.preMatch.index) {\n      for (let i = this.index; i < children.length; i++) if (children[i].matchesNode(node, outerDeco, innerDeco)) {\n        found = i\n        break\n      }\n    } else {\n      for (let i = this.index, e = Math.min(children.length, i + 1); i < e; i++) {\n        let child = children[i]\n        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n          found = i\n          break\n        }\n      }\n    }\n    if (found < 0) return false\n    this.destroyBetween(this.index, found)\n    this.index++\n    return true\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool\n  // Try to update the next node, if any, to the given data. Checks\n  // pre-matches to avoid overwriting nodes that could still be used.\n  updateNextNode(node, outerDeco, innerDeco, view, index) {\n    for (let i = this.index; i < this.top.children.length; i++) {\n      let next = this.top.children[i]\n      if (next instanceof NodeViewDesc) {\n        let preMatch = this.preMatch.matched.get(next)\n        if (preMatch != null && preMatch != index) return false\n        let nextDOM = next.dom\n\n        // Can't update if nextDOM is or contains this.lock, except if\n        // it's a text node whose content already matches the new text\n        // and whose decorations match the new ones.\n        let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&\n            !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n              next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco))\n        if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n          this.destroyBetween(this.index, i)\n          if (next.dom != nextDOM) this.changed = true\n          this.index++\n          return true\n        }\n        break\n      }\n    }\n    return false\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView)\n  // Insert the node as a newly created node desc.\n  addNode(node, outerDeco, innerDeco, view, pos) {\n    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos))\n    this.changed = true\n  }\n\n  placeWidget(widget, view, pos) {\n    let next = this.index < this.top.children.length ? this.top.children[this.index] : null\n    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n      this.index++\n    } else {\n      let desc = new WidgetViewDesc(this.top, widget, view, pos)\n      this.top.children.splice(this.index++, 0, desc)\n      this.changed = true\n    }\n  }\n\n  // Make sure a textblock looks and behaves correctly in\n  // contentEditable.\n  addTextblockHacks() {\n    let lastChild = this.top.children[this.index - 1]\n    while (lastChild instanceof MarkViewDesc) lastChild = lastChild.children[lastChild.children.length - 1]\n\n    if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) ||\n        /\\n$/.test(lastChild.node.text)) {\n      if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {\n        this.index++\n      } else {\n        let dom = document.createElement(\"br\")\n        this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null))\n        this.changed = true\n      }\n    }\n  }\n}\n\n// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, descs) {\n  let fI = frag.childCount, dI = descs.length, matched = new Map\n  for (; fI > 0 && dI > 0; dI--) {\n    let desc = descs[dI - 1], node = desc.node\n    if (!node) continue\n    if (node != frag.child(fI - 1)) break\n    --fI\n    matched.set(desc, fI)\n  }\n  return {index: fI, matched}\n}\n\nfunction compareSide(a, b) { return a.type.side - b.type.side }\n\n// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  let locals = deco.locals(parent), offset = 0\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (let i = 0; i < parent.childCount; i++) {\n      let child = parent.child(i)\n      onNode(child, locals, deco.forChild(offset, child), i)\n      offset += child.nodeSize\n    }\n    return\n  }\n\n  let decoIndex = 0, active = [], restNode = null\n  for (let parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      let widget = locals[decoIndex++], widgets\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        (widgets || (widgets = [widget])).push(locals[decoIndex++])\n      if (widgets) {\n        widgets.sort(compareSide)\n        for (let i = 0; i < widgets.length; i++) onWidget(widgets[i], parentIndex, !!restNode)\n      } else {\n        onWidget(widget, parentIndex, !!restNode)\n      }\n    }\n\n    let child, index\n    if (restNode) {\n      index = -1\n      child = restNode\n      restNode = null\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex\n      child = parent.child(parentIndex++)\n    } else {\n      break\n    }\n\n    for (let i = 0; i < active.length; i++) if (active[i].to <= offset) active.splice(i--, 1)\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      active.push(locals[decoIndex++])\n\n    let end = offset + child.nodeSize\n    if (child.isText) {\n      let cutAt = end\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from\n      for (let i = 0; i < active.length; i++) if (active[i].to < cutAt) cutAt = active[i].to\n      if (cutAt < end) {\n        restNode = child.cut(cutAt - offset)\n        child = child.cut(0, cutAt - offset)\n        end = cutAt\n        index = -1\n      }\n    }\n\n    let outerDeco = !active.length ? nothing\n        : child.isInline && !child.isLeaf ? active.filter(d => !d.inline)\n        : active.slice()\n    onNode(child, outerDeco, deco.forChild(offset, child), index)\n    offset = end\n  }\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    let oldCSS = dom.style.cssText\n    dom.style.cssText = oldCSS + \"; list-style: square !important\"\n    window.getComputedStyle(dom).listStyle\n    dom.style.cssText = oldCSS\n  }\n}\n\nfunction nearbyTextNode(node, offset) {\n  for (;;) {\n    if (node.nodeType == 3) return node\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n        return node.childNodes[offset]\n      node = node.childNodes[offset - 1]\n      offset = nodeSize(node)\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset]\n      offset = 0\n    } else {\n      return null\n    }\n  }\n}\n\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n  for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n    let child = frag.child(i++), childStart = pos\n    pos += child.nodeSize\n    if (!child.isText) continue\n    let str = child.text\n    while (i < frag.childCount) {\n      let next = frag.child(i++)\n      pos += next.nodeSize\n      if (!next.isText) break\n      str += next.text\n    }\n    if (pos >= from) {\n      let found = str.lastIndexOf(text, to - childStart)\n      if (found >= 0 && found + text.length + childStart >= from)\n        return childStart + found\n    }\n  }\n  return -1\n}\n\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  let result = []\n  for (let i = 0, off = 0; i < nodes.length; i++) {\n    let child = nodes[i], start = off, end = off += child.size\n    if (start >= to || end <= from) {\n      result.push(child)\n    } else {\n      if (start < from) result.push(child.slice(0, from - start, view))\n      if (replacement) {\n        result.push(replacement)\n        replacement = null\n      }\n      if (end > to) result.push(child.slice(to - start, child.size, view))\n    }\n  }\n  return result\n}\n","import {TextSelection, NodeSelection} from \"prosemirror-state\"\n\nimport browser from \"./browser\"\nimport {selectionCollapsed, isEquivalentPosition, domIndex, isOnEdge} from \"./dom\"\n\nexport function selectionFromDOM(view, origin) {\n  let domSel = view.root.getSelection(), doc = view.state.doc\n  if (!domSel.focusNode) return null\n  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0\n  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)\n  if (head < 0) return null\n  let $head = doc.resolve(head), $anchor, selection\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head\n    while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent\n    if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent\n        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      let pos = nearestDesc.posBefore\n      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos))\n    }\n  } else {\n    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset)\n    if (anchor < 0) return null\n    $anchor = doc.resolve(anchor)\n  }\n\n  if (!selection) {\n    let bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1\n    selection = selectionBetween(view, $anchor, $head, bias)\n  }\n  return selection\n}\n\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() :\n    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)\n}\n\nexport function selectionToDOM(view, force) {\n  let sel = view.state.selection\n  syncNodeSelection(view, sel)\n\n  if (!editorOwnsSelection(view)) return\n\n  view.domObserver.disconnectSelection()\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view)\n  } else {\n    let {anchor, head} = sel, resetEditableFrom, resetEditableTo\n    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        resetEditableFrom = temporarilyEditableNear(view, sel.from)\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        resetEditableTo = temporarilyEditableNear(view, sel.to)\n    }\n    view.docView.setSelection(anchor, head, view.root, force)\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) resetEditable(resetEditableFrom)\n      if (resetEditableTo) resetEditable(resetEditableTo)\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\")\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\")\n      if (\"onselectionchange\" in document) removeClassOnSelectionChange(view)\n    }\n  }\n\n  view.domObserver.setCurSelection()\n  view.domObserver.connectSelection()\n}\n\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\n\nconst brokenSelectBetweenUneditable = browser.safari || browser.chrome && browser.chrome_version < 63\n\nfunction temporarilyEditableNear(view, pos) {\n  let {node, offset} = view.docView.domFromPos(pos, 0)\n  let after = offset < node.childNodes.length ? node.childNodes[offset] : null\n  let before = offset ? node.childNodes[offset - 1] : null\n  if (browser.safari && after && after.contentEditable == \"false\") return setEditable(after)\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) return setEditable(after)\n    else if (before) return setEditable(before)\n  }\n}\n\nfunction setEditable(element) {\n  element.contentEditable = \"true\"\n  if (browser.safari && element.draggable) { element.draggable = false; element.wasDraggable = true }\n  return element\n}\n\nfunction resetEditable(element) {\n  element.contentEditable = \"false\"\n  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  let doc = view.dom.ownerDocument\n  doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard)\n  let domSel = view.root.getSelection()\n  let node = domSel.anchorNode, offset = domSel.anchorOffset\n  doc.addEventListener(\"selectionchange\", view.hideSelectionGuard = () => {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard)\n      setTimeout(() => {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          view.dom.classList.remove(\"ProseMirror-hideselection\")\n      }, 20)\n    }\n  })\n}\n\nfunction selectCursorWrapper(view) {\n  let domSel = view.root.getSelection(), range = document.createRange()\n  let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\"\n  if (img) range.setEnd(node.parentNode, domIndex(node) + 1)\n  else range.setEnd(node, 0)\n  range.collapse(false)\n  domSel.removeAllRanges()\n  domSel.addRange(range)\n  // Kludge to kill 'control selection' in IE11 when selecting an\n  // invisible cursor wrapper, since that would result in those weird\n  // resize handles and a selection that considers the absolutely\n  // positioned wrapper, rather than the root editable node, the\n  // focused element.\n  if (!img && !view.state.selection.visible && browser.ie && browser.ie_version <= 11) {\n    node.disabled = true\n    node.disabled = false\n  }\n}\n\nexport function syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    let desc = view.docView.descAt(sel.from)\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view)\n      if (desc) desc.selectNode()\n      view.lastSelectedViewDesc = desc\n    }\n  } else {\n    clearNodeSelection(view)\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      view.lastSelectedViewDesc.deselectNode()\n    view.lastSelectedViewDesc = null\n  }\n}\n\nexport function selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", f => f(view, $anchor, $head))\n    || TextSelection.between($anchor, $head, bias)\n}\n\nexport function hasFocusAndSelection(view) {\n  if (view.editable && view.root.activeElement != view.dom) return false\n  return hasSelection(view)\n}\n\nexport function hasSelection(view) {\n  let sel = view.root.getSelection()\n  if (!sel.anchorNode) return false\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))\n  } catch(_) {\n    return false\n  }\n}\n\nexport function anchorInRightPlace(view) {\n  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0)\n  let domSel = view.root.getSelection()\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)\n}\n","import {Selection, NodeSelection, TextSelection, AllSelection} from \"prosemirror-state\"\nimport browser from \"./browser\"\nimport {domIndex, selectionCollapsed} from \"./dom\"\nimport {selectionToDOM} from \"./selection\"\n\nfunction moveSelectionBlock(state, dir) {\n  let {$anchor, $head} = state.selection\n  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head)\n  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null\n  return $start && Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView())\n  return true\n}\n\nfunction selectHorizontally(view, dir, mods) {\n  let sel = view.state.selection\n  if (sel instanceof TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      let next = moveSelectionBlock(view.state, dir)\n      if (next && (next instanceof NodeSelection)) return apply(view, next)\n      return false\n    } else if (!(browser.mac && mods.indexOf(\"m\") > -1)) {\n      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc\n      if (!node || node.isText) return false\n      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false\n      if (NodeSelection.isSelectable(node)) {\n        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))\n      } else if (browser.webkit) {\n        // Chrome and Safari will introduce extra pointless cursor\n        // positions around inline uneditable nodes, so we have to\n        // take over and move the cursor past them (#937)\n        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))\n      } else {\n        return false\n      }\n    }\n  } else if (sel instanceof NodeSelection && sel.node.isInline) {\n    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))\n  } else {\n    let next = moveSelectionBlock(view.state, dir)\n    if (next) return apply(view, next)\n    return false\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  let desc = dom.pmViewDesc\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\")\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  let sel = view.root.getSelection()\n  let node = sel.focusNode, offset = sel.focusOffset\n  if (!node) return\n  let moveNode, moveOffset, force = false\n  // Gecko will do odd things when the selection is directly in front\n  // of a non-editable node, so in that case, move it into the next\n  // node if possible. Issue prosemirror/prosemirror#832.\n  if (browser.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break\n      } else {\n        let before = node.childNodes[offset - 1]\n        if (isIgnorable(before)) {\n          moveNode = node\n          moveOffset = --offset\n        } else if (before.nodeType == 3) {\n          node = before\n          offset = node.nodeValue.length\n        } else break\n      }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      let prev = node.previousSibling\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode\n        moveOffset = domIndex(prev)\n        prev = prev.previousSibling\n      }\n      if (!prev) {\n        node = node.parentNode\n        if (node == view.dom) break\n        offset = 0\n      } else {\n        node = prev\n        offset = nodeLen(node)\n      }\n    }\n  }\n  if (force) setSelFocus(view, sel, node, offset)\n  else if (moveNode) setSelFocus(view, sel, moveNode, moveOffset)\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  let sel = view.root.getSelection()\n  let node = sel.focusNode, offset = sel.focusOffset\n  if (!node) return\n  let len = nodeLen(node)\n  let moveNode, moveOffset\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) break\n      let after = node.childNodes[offset]\n      if (isIgnorable(after)) {\n        moveNode = node\n        moveOffset = ++offset\n      }\n      else break\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      let next = node.nextSibling\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode\n        moveOffset = domIndex(next) + 1\n        next = next.nextSibling\n      }\n      if (!next) {\n        node = node.parentNode\n        if (node == view.dom) break\n        offset = len = 0\n      } else {\n        node = next\n        offset = 0\n        len = nodeLen(node)\n      }\n    }\n  }\n  if (moveNode) setSelFocus(view, sel, moveNode, moveOffset)\n}\n\nfunction isBlockNode(dom) {\n  let desc = dom.pmViewDesc\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSelFocus(view, sel, node, offset) {\n  if (selectionCollapsed(sel)) {\n    let range = document.createRange()\n    range.setEnd(node, offset)\n    range.setStart(node, offset)\n    sel.removeAllRanges()\n    sel.addRange(range)\n  } else if (sel.extend) {\n    sel.extend(node, offset)\n  }\n  view.domObserver.setCurSelection()\n  let {state} = view\n  // If no state update ends up happening, reset the selection.\n  setTimeout(() => {\n    if (view.state == state) selectionToDOM(view)\n  }, 50)\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n  let sel = view.state.selection\n  if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false\n  if (browser.mac && mods.indexOf(\"m\") > -1) return false\n  let {$from, $to} = sel\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    let next = moveSelectionBlock(view.state, dir)\n    if (next && (next instanceof NodeSelection))\n      return apply(view, next)\n  }\n  if (!$from.parent.inlineContent) {\n    let side = dir < 0 ? $from : $to\n    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir)\n    return beyond ? apply(view, beyond) : false\n  }\n  return false\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return true\n  let {$head, $anchor, empty} = view.state.selection\n  if (!$head.sameParent($anchor)) return true\n  if (!empty) return false\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true\n  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter)\n  if (nextNode && !nextNode.isText) {\n    let tr = view.state.tr\n    if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos)\n    else tr.delete($head.pos, $head.pos + nextNode.nodeSize)\n    view.dispatch(tr)\n    return true\n  }\n  return false\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop()\n  node.contentEditable = state\n  view.domObserver.start()\n}\n\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n  if (!browser.safari || view.state.selection.$head.parentOffset > 0) return\n  let {focusNode, focusOffset} = view.root.getSelection()\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n      focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    let child = focusNode.firstChild\n    switchEditable(view, child, true)\n    setTimeout(() => switchEditable(view, child, false), 20)\n  }\n}\n\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction getMods(event) {\n  let result = \"\"\n  if (event.ctrlKey) result += \"c\"\n  if (event.metaKey) result += \"m\"\n  if (event.altKey) result += \"a\"\n  if (event.shiftKey) result += \"s\"\n  return result\n}\n\nexport function captureKeyDown(view, event) {\n  let code = event.keyCode, mods = getMods(event)\n  if (code == 8 || (browser.mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46 || (browser.mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 40) { // Down arrow\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (mods == (browser.mac ? \"m\" : \"c\") &&\n             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n    return true\n  }\n  return false\n}\n","import {Fragment, DOMParser} from \"prosemirror-model\"\nimport {Selection, TextSelection} from \"prosemirror-state\"\n\nimport {selectionBetween, selectionFromDOM, selectionToDOM} from \"./selection\"\nimport {selectionCollapsed, keyEvent} from \"./dom\"\nimport browser from \"./browser\"\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, from_, to_) {\n  let {node: parent, fromOffset, toOffset, from, to} = view.docView.parseRange(from_, to_)\n\n  let domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{node: anchor, offset: domSel.anchorOffset}]\n    if (!selectionCollapsed(domSel))\n      find.push({node: domSel.focusNode, offset: domSel.focusOffset})\n  }\n  // Work around issue in Chrome where backspacing sometimes replaces\n  // the deleted content with a random BR node (issues #799, #831)\n  if (browser.chrome && view.lastKeyCode === 8) {\n    for (let off = toOffset; off > fromOffset; off--) {\n      let node = parent.childNodes[off - 1], desc = node.pmViewDesc\n      if (node.nodeType == \"BR\" && !desc) { toOffset = off; break }\n      if (!desc || desc.size) break\n    }\n  }\n  let startDoc = view.state.doc\n  let parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n  let $from = startDoc.resolve(from)\n\n  let sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.spec.code ? \"full\" : true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode,\n    context: $from\n  })\n  if (find && find[0].pos != null) {\n    let anchor = find[0].pos, head = find[1] && find[1].pos\n    if (head == null) head = anchor\n    sel = {anchor: anchor + from, head: head + from}\n  }\n  return {doc, sel, from, to}\n}\n\nfunction ruleFromNode(dom) {\n  let desc = dom.pmViewDesc\n  if (desc) {\n    return desc.parseRule()\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    // Safari replaces the list item or table cell with a BR\n    // directly in the list node (?!) if you delete the last\n    // character in a list item or table cell (#708, #862)\n    if (browser.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      let skip = document.createElement(\"div\")\n      skip.appendChild(document.createElement(\"li\"))\n      return {skip}\n    } else if (dom.parentNode.lastChild == dom || browser.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return {ignore: true}\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return {ignore: true}\n  }\n}\n\nexport function readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    let origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null\n    let newSel = selectionFromDOM(view, origin)\n    if (newSel && !view.state.selection.eq(newSel)) {\n      let tr = view.state.tr.setSelection(newSel)\n      if (origin == \"pointer\") tr.setMeta(\"pointer\", true)\n      else if (origin == \"key\") tr.scrollIntoView()\n      view.dispatch(tr)\n    }\n    return\n  }\n\n  let $before = view.state.doc.resolve(from)\n  let shared = $before.sharedDepth(to)\n  from = $before.before(shared + 1)\n  to = view.state.doc.resolve(to).after(shared + 1)\n\n  let sel = view.state.selection\n  let parse = parseBetween(view, from, to)\n  // Chrome sometimes leaves the cursor before the inserted text when\n  // composing after a cursor wrapper. This moves it forward.\n  if (browser.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {\n    let text = view.cursorWrapper.deco.type.toDOM.nextSibling\n    let size = text && text.nodeValue ? text.nodeValue.length : 1\n    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size}\n  }\n\n  let doc = view.state.doc, compare = doc.slice(parse.from, parse.to)\n  let preferredPos, preferredSide\n  // Prefer anchoring to end when Backspace is pressed\n  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to\n    preferredSide = \"end\"\n  } else {\n    preferredPos = view.state.selection.from\n    preferredSide = \"start\"\n  }\n  view.lastKeyCode = null\n\n  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide)\n  if (!change) {\n    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = {start: sel.from, endA: sel.to, endB: sel.to}\n    } else if ((browser.ios && view.lastIOSEnter > Date.now() - 225 || browser.android) &&\n               addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\") &&\n               view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n      view.lastIOSEnter = 0\n      return\n    } else {\n      if (parse.sel) {\n        let sel = resolveSelection(view, view.state.doc, parse.sel)\n        if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel))\n      }\n      return\n    }\n  }\n  view.domChangeCount++\n  // Handle the case where overwriting a selection by typing matches\n  // the start or end of the selected content, creating a change\n  // that's smaller than what was actually overwritten.\n  if (view.state.selection.from < view.state.selection.to &&\n      change.start == change.endB &&\n      view.state.selection instanceof TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {\n      change.start = view.state.selection.from\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {\n      change.endB += (view.state.selection.to - change.endA)\n      change.endA = view.state.selection.to\n    }\n  }\n\n  // IE11 will insert a non-breaking space _ahead_ of the space after\n  // the cursor space when adding a space before another space. When\n  // that happened, adjust the change to cover the space instead.\n  if (browser.ie && browser.ie_version <= 11 && change.endB == change.start + 1 &&\n      change.endA == change.start && change.start > parse.from &&\n      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n    change.start--\n    change.endA--\n    change.endB--\n  }\n\n  let $from = parse.doc.resolveNoCache(change.start - parse.from)\n  let $to = parse.doc.resolveNoCache(change.endB - parse.from)\n  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent\n  let nextSel\n  // If this looks like the effect of pressing Enter (or was recorded\n  // as being an iOS enter press), just dispatch an Enter key instead.\n  if (((browser.ios && view.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\"))) ||\n       (!inlineChange && $from.pos < parse.doc.content.size &&\n        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n        nextSel.head == $to.pos)) &&\n      view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n    view.lastIOSEnter = 0\n    return\n  }\n  // Same for backspace\n  if (view.state.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) {\n    if (browser.android && browser.chrome) view.domObserver.suppressSelectionUpdates() // #820\n    return\n  }\n\n  // Chrome Android will occasionally, during composition, delete the\n  // entire composition and then immediately insert it again. This is\n  // used to detect that situation.\n  if (browser.chrome && browser.android && change.toB == change.from)\n    view.lastAndroidDelete = Date.now()\n\n  // This tries to detect Android virtual keyboard\n  // enter-and-pick-suggestion action. That sometimes (see issue\n  // #1059) first fires a DOM mutation, before moving the selection to\n  // the newly created block. And then, because ProseMirror cleans up\n  // the DOM selection, it gives up moving the selection entirely,\n  // leaving the cursor in the wrong place. When that happens, we drop\n  // the new paragraph from the initial change, and fire a simulated\n  // enter key afterwards.\n  if (browser.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2\n    $to = parse.doc.resolveNoCache(change.endB - parse.from)\n    setTimeout(() => {\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })\n    }, 20)\n  }\n\n  let chFrom = change.start, chTo = change.endA\n\n  let tr, storedMarks, markChange, $from1\n  if (inlineChange) {\n    if ($from.pos == $to.pos) { // Deletion\n      // IE11 sometimes weirdly moves the DOM selection around after\n      // backspacing out the first element in a textblock\n      if (browser.ie && browser.ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates()\n        setTimeout(() => selectionToDOM(view), 20)\n      }\n      tr = view.state.tr.delete(chFrom, chTo)\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA))\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr\n      if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark)\n      else tr.removeMark(chFrom, chTo, markChange.mark)\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset)\n      if (view.someProp(\"handleTextInput\", f => f(view, chFrom, chTo, text))) return\n      tr = view.state.tr.insertText(text, chFrom, chTo)\n    }\n  }\n\n  if (!tr)\n    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from))\n  if (parse.sel) {\n    let sel = resolveSelection(view, tr.doc, parse.sel)\n    // Chrome Android will sometimes, during composition, report the\n    // selection in the wrong place. If it looks like that is\n    // happening, don't update the selection.\n    // Edge just doesn't move the cursor forward when you start typing\n    // in an empty block or between br nodes.\n    if (sel && !(browser.chrome && browser.android && view.composing && sel.empty &&\n                 (change.from != change.toB || view.lastAndroidDelete < Date.now() - 100) &&\n                 (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n                 browser.ie && sel.empty && sel.head == chFrom))\n      tr.setSelection(sel)\n  }\n  if (storedMarks) tr.ensureMarks(storedMarks)\n  view.dispatch(tr.scrollIntoView())\n}\n\nfunction resolveSelection(view, doc, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null\n  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks\n  let added = curMarks, removed = prevMarks, type, mark, update\n  for (let i = 0; i < prevMarks.length; i++) added = prevMarks[i].removeFromSet(added)\n  for (let i = 0; i < curMarks.length; i++) removed = curMarks[i].removeFromSet(removed)\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0]\n    type = \"add\"\n    update = node => node.mark(mark.addToSet(node.marks))\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0]\n    type = \"remove\"\n    update = node => node.mark(mark.removeFromSet(node.marks))\n  } else {\n    return null\n  }\n  let updated = []\n  for (let i = 0; i < prev.childCount; i++) updated.push(update(prev.child(i)))\n  if (Fragment.from(updated).eq(cur)) return {mark, type}\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    return false\n\n  let $start = old.resolve(start)\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    return false\n  let $next = old.resolve(skipClosingAndOpening($start, true, true))\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    return false\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--\n    end++\n    fromEnd = false\n  }\n  if (mayOpen) {\n    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth))\n    while (next && !next.isLeaf) {\n      next = next.firstChild\n      end++\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  let start = a.findDiffStart(b, pos)\n  if (start == null) return null\n  let {a: endA, b: endB} = a.findDiffEnd(b, pos + a.size, pos + b.size)\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, start - Math.min(endA, endB))\n    preferredPos -= endA + adjust - start\n  }\n  if (endA < start && a.size < b.size) {\n    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0\n    start -= move\n    endB = start + (endB - endA)\n    endA = start\n  } else if (endB < start) {\n    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0\n    start -= move\n    endA = start + (endA - endB)\n    endB = start\n  }\n  return {start, endA, endB}\n}\n","import {Slice, Fragment, DOMParser, DOMSerializer} from \"prosemirror-model\"\n\nexport function serializeForClipboard(view, slice) {\n  let context = [], {content, openStart, openEnd} = slice\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--\n    openEnd--\n    let node = content.firstChild\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null)\n    content = node.content\n  }\n\n  let serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema)\n  let doc = detachedDoc(), wrap = doc.createElement(\"div\")\n  wrap.appendChild(serializer.serializeFragment(content, {document: doc}))\n\n  let firstChild = wrap.firstChild, needsWrap\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (let i = needsWrap.length - 1; i >= 0; i--) {\n      let wrapper = doc.createElement(needsWrap[i])\n      while (wrap.firstChild) wrapper.appendChild(wrap.firstChild)\n      wrap.appendChild(wrapper)\n    }\n    firstChild = wrap.firstChild\n  }\n\n  if (firstChild && firstChild.nodeType == 1)\n    firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd} ${JSON.stringify(context)}`)\n\n  let text = view.someProp(\"clipboardTextSerializer\", f => f(slice)) ||\n      slice.content.textBetween(0, slice.content.size, \"\\n\\n\")\n\n  return {dom: wrap, text}\n}\n\n// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nexport function parseFromClipboard(view, text, html, plainText, $context) {\n  let dom, inCode = $context.parent.type.spec.code, slice\n  if (!html && !text) return null\n  let asText = text && (plainText || inCode || !html)\n  if (asText) {\n    view.someProp(\"transformPastedText\", f => { text = f(text, inCode || plainText) })\n    if (inCode) return new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0)\n    let parsed = view.someProp(\"clipboardTextParser\", f => f(text, $context, plainText))\n    if (parsed) {\n      slice = parsed\n    } else {\n      dom = document.createElement(\"div\")\n      text.trim().split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n        dom.appendChild(document.createElement(\"p\")).textContent = block\n      })\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", f => { html = f(html) })\n    dom = readHTML(html)\n  }\n\n  let contextNode = dom && dom.querySelector(\"[data-pm-slice]\")\n  let sliceData = contextNode && /^(\\d+) (\\d+) (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\"))\n  if (!slice) {\n    let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context})\n  }\n  if (sliceData)\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3])\n  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), false)\n\n  view.someProp(\"transformPasted\", f => { slice = f(slice) })\n  return slice\n}\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) return fragment\n  for (let d = $context.depth; d >= 0; d--) {\n    let parent = $context.node(d)\n    let match = parent.contentMatchAt($context.index(d))\n    let lastWrap, result = []\n    fragment.forEach(node => {\n      if (!result) return\n      let wrap = match.findWrapping(node.type), inLast\n      if (!wrap) return result = null\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast\n      } else {\n        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length)\n        let wrapped = withWrappers(node, wrap)\n        result.push(wrapped)\n        match = match.matchType(wrapped.type, wrapped.attrs)\n        lastWrap = wrap\n      }\n    })\n    if (result) return Fragment.from(result)\n  }\n  return fragment\n}\n\nfunction withWrappers(node, wrap, from = 0) {\n  for (let i = wrap.length - 1; i >= from; i--)\n    node = wrap[i].create(null, Fragment.from(node))\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1)\n    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner))\n    let match = sibling.contentMatchAt(sibling.childCount)\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))))\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) return node\n  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1))\n  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)\n  return node.copy(fragment.append(fill))\n}\n\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content\n  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd)\n  if (depth >= from)\n    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)\n      : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true))\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))\n}\n\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd)\n  if (openEnd < slice.openEnd)\n    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd)\n  return slice\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n}\n\nlet _detachedDoc = null\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n}\n\nfunction readHTML(html) {\n  let metas = /^(\\s*<meta [^>]*>)*/.exec(html)\n  if (metas) html = html.slice(metas[0].length)\n  let elt = detachedDoc().createElement(\"div\")\n  let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    html = wrap.map(n => \"<\" + n + \">\").join(\"\") + html + wrap.map(n => \"</\" + n + \">\").reverse().join(\"\")\n  elt.innerHTML = html\n  if (wrap) for (let i = 0; i < wrap.length; i++) elt = elt.querySelector(wrap[i]) || elt\n  return elt\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) return slice\n  let schema = slice.content.firstChild.type.schema, array\n  try { array = JSON.parse(context) }\n  catch(e) { return slice }\n  let {content, openStart, openEnd} = slice\n  for (let i = array.length - 2; i >= 0; i -= 2) {\n    let type = schema.nodes[array[i]]\n    if (!type || type.hasRequiredAttrs()) break\n    content = Fragment.from(type.create(array[i + 1], content))\n    openStart++; openEnd++\n  }\n  return new Slice(content, openStart, openEnd)\n}\n","import browser from \"./browser\"\nimport {domIndex, isEquivalentPosition} from \"./dom\"\nimport {hasFocusAndSelection, hasSelection, selectionToDOM} from \"./selection\"\n\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n}\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = browser.ie && browser.ie_version <= 11\n\nclass SelectionState {\n  constructor() {\n    this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null\n  }\n\n  set(sel) {\n    this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset\n    this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset\n  }\n\n  eq(sel) {\n    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n      sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset\n  }\n}\n\nexport class DOMObserver {\n  constructor(view, handleDOMChange) {\n    this.view = view\n    this.handleDOMChange = handleDOMChange\n    this.queue = []\n    this.flushingSoon = -1\n    this.observer = window.MutationObserver &&\n      new window.MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) this.queue.push(mutations[i])\n        // IE11 will sometimes (on backspacing out a single character\n        // text node after a BR node) call the observer callback\n        // before actually updating the DOM, which will cause\n        // ProseMirror to miss the change (see #930)\n        if (browser.ie && browser.ie_version <= 11 && mutations.some(\n          m => m.type == \"childList\" && m.removedNodes.length ||\n               m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n          this.flushSoon()\n        else\n          this.flush()\n      })\n    this.currentSelection = new SelectionState\n    if (useCharData) {\n      this.onCharData = e => {\n        this.queue.push({target: e.target, type: \"characterData\", oldValue: e.prevValue})\n        this.flushSoon()\n      }\n    }\n    this.onSelectionChange = this.onSelectionChange.bind(this)\n    this.suppressingSelectionUpdates = false\n  }\n\n  flushSoon() {\n    if (this.flushingSoon < 0)\n      this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush() }, 20)\n  }\n\n  forceFlush() {\n    if (this.flushingSoon > -1) {\n      window.clearTimeout(this.flushingSoon)\n      this.flushingSoon = -1\n      this.flush()\n    }\n  }\n\n  start() {\n    if (this.observer)\n      this.observer.observe(this.view.dom, observeOptions)\n    if (useCharData)\n      this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData)\n    this.connectSelection()\n  }\n\n  stop() {\n    if (this.observer) {\n      let take = this.observer.takeRecords()\n      if (take.length) {\n        for (let i = 0; i < take.length; i++) this.queue.push(take[i])\n        window.setTimeout(() => this.flush(), 20)\n      }\n      this.observer.disconnect()\n    }\n    if (useCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData)\n    this.disconnectSelection()\n  }\n\n  connectSelection() {\n    this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange)\n  }\n\n  disconnectSelection() {\n    this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange)\n  }\n\n  suppressSelectionUpdates() {\n    this.suppressingSelectionUpdates = true\n    setTimeout(() => this.suppressingSelectionUpdates = false, 50)\n  }\n\n  onSelectionChange() {\n    if (!hasFocusAndSelection(this.view)) return\n    if (this.suppressingSelectionUpdates) return selectionToDOM(this.view)\n    // Deletions on IE11 fire their events in the wrong order, giving\n    // us a selection change event before the DOM changes are\n    // reported.\n    if (browser.ie && browser.ie_version <= 11 && !this.view.state.selection.empty) {\n      let sel = this.view.root.getSelection()\n      // Selection.isCollapsed isn't reliable on IE\n      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n        return this.flushSoon()\n    }\n    this.flush()\n  }\n\n  setCurSelection() {\n    this.currentSelection.set(this.view.root.getSelection())\n  }\n\n  ignoreSelectionChange(sel) {\n    if (sel.rangeCount == 0) return true\n    let container = sel.getRangeAt(0).commonAncestorContainer\n    let desc = this.view.docView.nearestDesc(container)\n    if (desc && desc.ignoreMutation({type: \"selection\", target: container.nodeType == 3 ? container.parentNode : container})) {\n      this.setCurSelection()\n      return true\n    }\n  }\n\n  flush() {\n    if (!this.view.docView || this.flushingSoon > -1) return\n    let mutations = this.observer ? this.observer.takeRecords() : []\n    if (this.queue.length) {\n      mutations = this.queue.concat(mutations)\n      this.queue.length = 0\n    }\n\n    let sel = this.view.root.getSelection()\n    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel)\n\n    let from = -1, to = -1, typeOver = false, added = []\n    if (this.view.editable) {\n      for (let i = 0; i < mutations.length; i++) {\n        let result = this.registerMutation(mutations[i], added)\n        if (result) {\n          from = from < 0 ? result.from : Math.min(result.from, from)\n          to = to < 0 ? result.to : Math.max(result.to, to)\n          if (result.typeOver) typeOver = true\n        }\n      }\n    }\n\n    if (browser.gecko && added.length > 1) {\n      let brs = added.filter(n => n.nodeName == \"BR\")\n      if (brs.length == 2) {\n        let [a, b] = brs\n        if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove()\n        else a.remove()\n      }\n    }\n\n    if (from > -1 || newSel) {\n      if (from > -1) {\n        this.view.docView.markDirty(from, to)\n        checkCSS(this.view)\n      }\n      this.handleDOMChange(from, to, typeOver, added)\n      if (this.view.docView.dirty) this.view.updateState(this.view.state)\n      else if (!this.currentSelection.eq(sel)) selectionToDOM(this.view)\n      this.currentSelection.set(sel)\n    }\n  }\n\n  registerMutation(mut, added) {\n    // Ignore mutations inside nodes that were already noted as inserted\n    if (added.indexOf(mut.target) > -1) return null\n    let desc = this.view.docView.nearestDesc(mut.target)\n    if (mut.type == \"attributes\" &&\n        (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n         // Firefox sometimes fires spurious events for null/empty styles\n         (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n      return null\n    if (!desc || desc.ignoreMutation(mut)) return null\n\n    if (mut.type == \"childList\") {\n      for (let i = 0; i < mut.addedNodes.length; i++) added.push(mut.addedNodes[i])\n      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n        return {from: desc.posBefore, to: desc.posAfter}\n      let prev = mut.previousSibling, next = mut.nextSibling\n      if (browser.ie && browser.ie_version <= 11 && mut.addedNodes.length) {\n        // IE11 gives us incorrect next/prev siblings for some\n        // insertions, so if there are added nodes, recompute those\n        for (let i = 0; i < mut.addedNodes.length; i++) {\n          let {previousSibling, nextSibling} = mut.addedNodes[i]\n          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling\n          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling\n        }\n      }\n      let fromOffset = prev && prev.parentNode == mut.target\n          ? domIndex(prev) + 1 : 0\n      let from = desc.localPosFromDOM(mut.target, fromOffset, -1)\n      let toOffset = next && next.parentNode == mut.target\n          ? domIndex(next) : mut.target.childNodes.length\n      let to = desc.localPosFromDOM(mut.target, toOffset, 1)\n      return {from, to}\n    } else if (mut.type == \"attributes\") {\n      return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}\n    } else { // \"characterData\"\n      return {\n        from: desc.posAtStart,\n        to: desc.posAtEnd,\n        // An event was generated for a text change that didn't change\n        // any text. Mark the dom change to fall back to assuming the\n        // selection was typed over with an identical value if it can't\n        // find another change.\n        typeOver: mut.target.nodeValue == mut.oldValue\n      }\n    }\n  }\n}\n\nlet cssChecked = false\n\nfunction checkCSS(view) {\n  if (cssChecked) return\n  cssChecked = true\n  if (getComputedStyle(view.dom).whiteSpace == \"normal\")\n    console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\")\n}\n","import {Selection, NodeSelection, TextSelection} from \"prosemirror-state\"\nimport {dropPoint} from \"prosemirror-transform\"\nimport {Slice} from \"prosemirror-model\"\n\nimport browser from \"./browser\"\nimport {captureKeyDown} from \"./capturekeys\"\nimport {readDOMChange} from \"./domchange\"\nimport {parseFromClipboard, serializeForClipboard} from \"./clipboard\"\nimport {DOMObserver} from \"./domobserver\"\nimport {selectionBetween, selectionToDOM, selectionFromDOM} from \"./selection\"\nimport {keyEvent} from \"./dom\"\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {}, editHandlers = {}\n\nexport function initInput(view) {\n  view.shiftKey = false\n  view.mouseDown = null\n  view.lastKeyCode = null\n  view.lastKeyCodeTime = 0\n  view.lastClick = {time: 0, x: 0, y: 0, type: \"\"}\n  view.lastSelectionOrigin = null\n  view.lastSelectionTime = 0\n\n  view.lastIOSEnter = 0\n  view.lastIOSEnterFallbackTimeout = null\n  view.lastAndroidDelete = 0\n\n  view.composing = false\n  view.composingTimeout = null\n  view.compositionNodes = []\n  view.compositionEndedAt = -2e8\n\n  view.domObserver = new DOMObserver(view, (from, to, typeOver, added) => readDOMChange(view, from, to, typeOver, added))\n  view.domObserver.start()\n  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM\n  view.domChangeCount = 0\n\n  view.eventHandlers = Object.create(null)\n  for (let event in handlers) {\n    let handler = handlers[event]\n    view.dom.addEventListener(event, view.eventHandlers[event] = event => {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        handler(view, event)\n    })\n  }\n  // On Safari, for reasons beyond my understanding, adding an input\n  // event handler makes an issue where the composition vanishes when\n  // you press enter go away.\n  if (browser.safari) view.dom.addEventListener(\"input\", () => null)\n\n  ensureListeners(view)\n}\n\nfunction setSelectionOrigin(view, origin) {\n  view.lastSelectionOrigin = origin\n  view.lastSelectionTime = Date.now()\n}\n\nexport function destroyInput(view) {\n  view.domObserver.stop()\n  for (let type in view.eventHandlers)\n    view.dom.removeEventListener(type, view.eventHandlers[type])\n  clearTimeout(view.composingTimeout)\n  clearTimeout(view.lastIOSEnterFallbackTimeout)\n}\n\nexport function ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", currentHandlers => {\n    for (let type in currentHandlers) if (!view.eventHandlers[type])\n      view.dom.addEventListener(type, view.eventHandlers[type] = event => runCustomHandler(view, event))\n  })\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", handlers => {\n    let handler = handlers[event.type]\n    return handler ? handler(view, event) || event.defaultPrevented : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) return true\n  if (event.defaultPrevented) return false\n  for (let node = event.target; node != view.dom; node = node.parentNode)\n    if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      return false\n  return true\n}\n\nexport function dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    handlers[event.type](view, event)\n}\n\neditHandlers.keydown = (view, event) => {\n  view.shiftKey = event.keyCode == 16 || event.shiftKey\n  if (inOrNearComposition(view, event)) return\n  view.domObserver.forceFlush()\n  view.lastKeyCode = event.keyCode\n  view.lastKeyCodeTime = Date.now()\n  // On iOS, if we preventDefault enter key presses, the virtual\n  // keyboard gets confused. So the hack here is to set a flag that\n  // makes the DOM change code recognize that what just happens should\n  // be replaced by whatever the Enter key handlers do.\n  if (browser.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    let now = Date.now()\n    view.lastIOSEnter = now\n    view.lastIOSEnterFallbackTimeout = setTimeout(() => {\n      if (view.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))\n        view.lastIOSEnter = 0\n      }\n    }, 200)\n  } else if (view.someProp(\"handleKeyDown\", f => f(view, event)) || captureKeyDown(view, event)) {\n    event.preventDefault()\n  } else {\n    setSelectionOrigin(view, \"key\")\n  }\n}\n\neditHandlers.keyup = (view, e) => {\n  if (e.keyCode == 16) view.shiftKey = false\n}\n\neditHandlers.keypress = (view, event) => {\n  if (inOrNearComposition(view, event) || !event.charCode ||\n      event.ctrlKey && !event.altKey || browser.mac && event.metaKey) return\n\n  if (view.someProp(\"handleKeyPress\", f => f(view, event))) {\n    event.preventDefault()\n    return\n  }\n\n  let sel = view.state.selection\n  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    let text = String.fromCharCode(event.charCode)\n    if (!view.someProp(\"handleTextInput\", f => f(view, sel.$from.pos, sel.$to.pos, text)))\n      view.dispatch(view.state.tr.insertText(text).scrollIntoView())\n    event.preventDefault()\n  }\n}\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nfunction isNear(event, click) {\n  let dx = click.x - event.clientX, dy = click.y - event.clientY\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) return false\n  let $pos = view.state.doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n      return true\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) view.focus()\n  let tr = view.state.tr.setSelection(selection)\n  if (origin == \"pointer\") tr.setMeta(\"pointer\", true)\n  view.dispatch(tr)\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) return false\n  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter\n  if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\")\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) return false\n  let sel = view.state.selection, selectedNode, selectAt\n  if (sel instanceof NodeSelection) selectedNode = sel.node\n\n  let $pos = view.state.doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    if (NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 &&\n          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        selectAt = $pos.before(sel.$from.depth)\n      else\n        selectAt = $pos.before(i)\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\")\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", f => f(view, pos, event)) ||\n    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", f => f(view, pos, event))\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", f => f(view, pos, event)) ||\n    defaultTripleClick(view, inside)\n}\n\nfunction defaultTripleClick(view, inside) {\n  let doc = view.state.doc\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\")\n      return true\n    }\n    return false\n  }\n\n  let $pos = doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    let nodePos = $pos.before(i)\n    if (node.inlineContent)\n      updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\")\n    else if (NodeSelection.isSelectable(node))\n      updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\")\n    else\n      continue\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  return endComposition(view)\n}\n\nconst selectNodeModifier = browser.mac ? \"metaKey\" : \"ctrlKey\"\n\nhandlers.mousedown = (view, event) => {\n  view.shiftKey = event.shiftKey\n  let flushed = forceDOMFlush(view)\n  let now = Date.now(), type = \"singleClick\"\n  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {\n    if (view.lastClick.type == \"singleClick\") type = \"doubleClick\"\n    else if (view.lastClick.type == \"doubleClick\") type = \"tripleClick\"\n  }\n  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type}\n\n  let pos = view.posAtCoords(eventCoords(event))\n  if (!pos) return\n\n  if (type == \"singleClick\")\n    view.mouseDown = new MouseDown(view, pos, event, flushed)\n  else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))\n    event.preventDefault()\n  else\n    setSelectionOrigin(view, \"pointer\")\n}\n\nclass MouseDown {\n  constructor(view, pos, event, flushed) {\n    this.view = view\n    this.startDoc = view.state.doc\n    this.pos = pos\n    this.event = event\n    this.flushed = flushed\n    this.selectNode = event[selectNodeModifier]\n    this.allowDefault = event.shiftKey\n\n    let targetNode, targetPos\n    if (pos.inside > -1) {\n      targetNode = view.state.doc.nodeAt(pos.inside)\n      targetPos = pos.inside\n    } else {\n      let $pos = view.state.doc.resolve(pos.pos)\n      targetNode = $pos.parent\n      targetPos = $pos.depth ? $pos.before() : 0\n    }\n\n    this.mightDrag = null\n\n    const target = flushed ? null : event.target\n    const targetDesc = target ? view.docView.nearestDesc(target, true) : null\n    this.target = targetDesc ? targetDesc.dom : null\n\n    if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n        view.state.selection instanceof NodeSelection && targetPos == view.state.selection.from)\n      this.mightDrag = {node: targetNode,\n                        pos: targetPos,\n                        addAttr: this.target && !this.target.draggable,\n                        setUneditable: this.target && browser.gecko && !this.target.hasAttribute(\"contentEditable\")}\n\n    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n      this.view.domObserver.stop()\n      if (this.mightDrag.addAttr) this.target.draggable = true\n      if (this.mightDrag.setUneditable)\n        setTimeout(() => this.target.setAttribute(\"contentEditable\", \"false\"), 20)\n      this.view.domObserver.start()\n    }\n\n    view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this))\n    view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this))\n    setSelectionOrigin(view, \"pointer\")\n  }\n\n  done() {\n    this.view.root.removeEventListener(\"mouseup\", this.up)\n    this.view.root.removeEventListener(\"mousemove\", this.move)\n    if (this.mightDrag && this.target) {\n      this.view.domObserver.stop()\n      if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\")\n      if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\")\n      this.view.domObserver.start()\n    }\n    this.view.mouseDown = null\n  }\n\n  up(event) {\n    this.done()\n\n    if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n      return\n\n    let pos = this.pos\n    if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event))\n\n    if (this.allowDefault || !pos) {\n      setSelectionOrigin(this.view, \"pointer\")\n    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n      event.preventDefault()\n    } else if (this.flushed ||\n               // Safari ignores clicks on draggable elements\n               (browser.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n               // Chrome will sometimes treat a node selection as a\n               // cursor, but still report that the node is selected\n               // when asked through getSelection. You'll then get a\n               // situation where clicking at the point where that\n               // (hidden) cursor is doesn't change the selection, and\n               // thus doesn't get a reaction from ProseMirror. This\n               // works around that.\n               (browser.chrome && !(this.view.state.selection instanceof TextSelection) &&\n                (pos.pos == this.view.state.selection.from || pos.pos == this.view.state.selection.to))) {\n      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\")\n      event.preventDefault()\n    } else {\n      setSelectionOrigin(this.view, \"pointer\")\n    }\n  }\n\n  move(event) {\n    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n                               Math.abs(this.event.y - event.clientY) > 4))\n      this.allowDefault = true\n    setSelectionOrigin(this.view, \"pointer\")\n  }\n}\n\nhandlers.touchdown = view => {\n  forceDOMFlush(view)\n  setSelectionOrigin(view, \"pointer\")\n}\n\nhandlers.contextmenu = view => forceDOMFlush(view)\n\nfunction inOrNearComposition(view, event) {\n  if (view.composing) return true\n  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n  // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n  // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n  // emitted. The keydown event triggers newline insertion, which we don't want.\n  // This method returns true if the keydown event should be ignored.\n  // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n  // This guards against the case where compositionend is triggered without the keyboard\n  // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n  // afterwards- we wouldn't want to ignore the keydown event in this case.\n  if (browser.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {\n    view.compositionEndedAt = -2e8\n    return true\n  }\n  return false\n}\n\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = browser.android ? 5000 : -1\n\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n  if (!view.composing) {\n    view.domObserver.flush()\n    let {state} = view, $pos = state.selection.$from\n    if (state.selection.empty &&\n        (state.storedMarks ||\n         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {\n      // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n      view.markCursor = view.state.storedMarks || $pos.marks()\n      endComposition(view, true)\n      view.markCursor = null\n    } else {\n      endComposition(view)\n      // In firefox, if the cursor is after but outside a marked node,\n      // the inserted text won't inherit the marks. So this moves it\n      // inside if necessary.\n      if (browser.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        let sel = view.root.getSelection()\n        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1]\n          if (!before) break\n          if (before.nodeType == 3) {\n            sel.collapse(before, before.nodeValue.length)\n            break\n          } else {\n            node = before\n            offset = -1\n          }\n        }\n      }\n    }\n    view.composing = true\n  }\n  scheduleComposeEnd(view, timeoutComposition)\n}\n\neditHandlers.compositionend = (view, event) => {\n  if (view.composing) {\n    view.composing = false\n    view.compositionEndedAt = event.timeStamp\n    scheduleComposeEnd(view, 20)\n  }\n}\n\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.composingTimeout)\n  if (delay > -1) view.composingTimeout = setTimeout(() => endComposition(view), delay)\n}\n\nexport function clearComposition(view) {\n  view.composing = false\n  while (view.compositionNodes.length > 0) view.compositionNodes.pop().markParentsDirty()\n}\n\nexport function endComposition(view, forceUpdate) {\n  view.domObserver.forceFlush()\n  clearComposition(view)\n  if (forceUpdate || view.docView.dirty) {\n    let sel = selectionFromDOM(view)\n    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel))\n    else view.updateState(view.state)\n    return true\n  }\n  return false\n}\n\nfunction captureCopy(view, dom) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  if (!view.dom.parentNode) return\n  let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"))\n  wrap.appendChild(dom)\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\"\n  let sel = getSelection(), range = document.createRange()\n  range.selectNodeContents(dom)\n  // Done because IE will fire a selectionchange moving the selection\n  // to its start when removeAllRanges is called and the editor still\n  // has focus (which will mess up the editor's selection state).\n  view.dom.blur()\n  sel.removeAllRanges()\n  sel.addRange(range)\n  setTimeout(() => {\n    if (wrap.parentNode) wrap.parentNode.removeChild(wrap)\n    view.focus()\n  }, 50)\n}\n\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n      (browser.ios && browser.webkit_version < 604)\n\nhandlers.copy = editHandlers.cut = (view, e) => {\n  let sel = view.state.selection, cut = e.type == \"cut\"\n  if (sel.empty) return\n\n  // IE and Edge's clipboard interface is completely broken\n  let data = brokenClipboardAPI ? null : e.clipboardData\n  let slice = sel.content(), {dom, text} = serializeForClipboard(view, slice)\n  if (data) {\n    e.preventDefault()\n    data.clearData()\n    data.setData(\"text/html\", dom.innerHTML)\n    data.setData(\"text/plain\", text)\n  } else {\n    captureCopy(view, dom)\n  }\n  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"))\n}\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\nfunction capturePaste(view, e) {\n  if (!view.dom.parentNode) return\n  let plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code\n  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"))\n  if (!plainText) target.contentEditable = \"true\"\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\"\n  target.focus()\n  setTimeout(() => {\n    view.focus()\n    if (target.parentNode) target.parentNode.removeChild(target)\n    if (plainText) doPaste(view, target.value, null, e)\n    else doPaste(view, target.textContent, target.innerHTML, e)\n  }, 50)\n}\n\nfunction doPaste(view, text, html, e) {\n  let slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from)\n  if (view.someProp(\"handlePaste\", f => f(view, e, slice || Slice.empty))) return true\n  if (!slice) return false\n\n  let singleNode = sliceSingleNode(slice)\n  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice)\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"))\n  return true\n}\n\neditHandlers.paste = (view, e) => {\n  let data = brokenClipboardAPI ? null : e.clipboardData\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), e)) e.preventDefault()\n  else capturePaste(view, e)\n}\n\nclass Dragging {\n  constructor(slice, move) {\n    this.slice = slice\n    this.move = move\n  }\n}\n\nconst dragCopyModifier = browser.mac ? \"altKey\" : \"ctrlKey\"\n\nhandlers.dragstart = (view, e) => {\n  let mouseDown = view.mouseDown\n  if (mouseDown) mouseDown.done()\n  if (!e.dataTransfer) return\n\n  let sel = view.state.selection\n  let pos = sel.empty ? null : view.posAtCoords(eventCoords(e))\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) {\n    // In selection\n  } else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)))\n  } else if (e.target && e.target.nodeType == 1) {\n    let desc = view.docView.nearestDesc(e.target, true)\n    if (!desc || !desc.node.type.spec.draggable || desc == view.docView) return\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)))\n  }\n  let slice = view.state.selection.content(), {dom, text} = serializeForClipboard(view, slice)\n  e.dataTransfer.clearData()\n  e.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML)\n  if (!brokenClipboardAPI) e.dataTransfer.setData(\"text/plain\", text)\n  view.dragging = new Dragging(slice, !e[dragCopyModifier])\n}\n\nhandlers.dragend = view => {\n  let dragging = view.dragging\n  window.setTimeout(() => {\n    if (view.dragging == dragging)  view.dragging = null\n  }, 50)\n}\n\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault()\n\neditHandlers.drop = (view, e) => {\n  let dragging = view.dragging\n  view.dragging = null\n\n  if (!e.dataTransfer) return\n\n  let eventPos = view.posAtCoords(eventCoords(e))\n  if (!eventPos) return\n  let $mouse = view.state.doc.resolve(eventPos.pos)\n  if (!$mouse) return\n  let slice = dragging && dragging.slice ||\n      parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"),\n                         brokenClipboardAPI ? null : e.dataTransfer.getData(\"text/html\"), false, $mouse)\n  let move = dragging && !e[dragCopyModifier]\n  if (view.someProp(\"handleDrop\", f => f(view, e, slice || Slice.empty, move))) {\n    e.preventDefault()\n    return\n  }\n  if (!slice) return\n\n  e.preventDefault()\n  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos\n  if (insertPos == null) insertPos = $mouse.pos\n\n  let tr = view.state.tr\n  if (move) tr.deleteSelection()\n\n  let pos = tr.mapping.map(insertPos)\n  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1\n  let beforeInsert = tr.doc\n  if (isNode)\n    tr.replaceRangeWith(pos, pos, slice.content.firstChild)\n  else\n    tr.replaceRange(pos, pos, slice)\n  if (tr.doc.eq(beforeInsert)) return\n\n  let $pos = tr.doc.resolve(pos)\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new NodeSelection($pos))\n  } else {\n    let end = tr.mapping.map(insertPos)\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo)\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)))\n  }\n  view.focus()\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"))\n}\n\nhandlers.focus = view => {\n  if (!view.focused) {\n    view.domObserver.stop()\n    view.dom.classList.add(\"ProseMirror-focused\")\n    view.domObserver.start()\n    view.focused = true\n    setTimeout(() => {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))\n        selectionToDOM(view)\n    }, 20)\n  }\n}\n\nhandlers.blur = view => {\n  if (view.focused) {\n    view.domObserver.stop()\n    view.dom.classList.remove(\"ProseMirror-focused\")\n    view.domObserver.start()\n    view.domObserver.currentSelection.set({})\n    view.focused = false\n  }\n}\n\nhandlers.beforeinput = (view, event) => {\n  // We should probably do more with beforeinput events, but support\n  // is so spotty that I'm still waiting to see where they are going.\n\n  // Very specific hack to deal with backspace sometimes failing on\n  // Chrome Android when after an uneditable node.\n  if (browser.chrome && browser.android && event.inputType == \"deleteContentBackward\") {\n    let {domChangeCount} = view\n    setTimeout(() => {\n      if (view.domChangeCount != domChangeCount) return // Event already had some effect\n      // This bug tends to close the virtual keyboard, so we refocus\n      view.dom.blur()\n      view.focus()\n      if (view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) return\n      let {$cursor} = view.state.selection\n      // Crude approximation of backspace behavior when no command handled it\n      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView())\n    }, 50)\n  }\n}\n\n// Make sure all handlers get registered\nfor (let prop in editHandlers) handlers[prop] = editHandlers[prop]\n","function compareObjs(a, b) {\n  if (a == b) return true\n  for (let p in a) if (a[p] !== b[p]) return false\n  for (let p in b) if (!(p in a)) return false\n  return true\n}\n\nclass WidgetType {\n  constructor(toDOM, spec) {\n    this.spec = spec || noSpec\n    this.side = this.spec.side || 0\n    this.toDOM = toDOM\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let {pos, deleted} = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1)\n    return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n  }\n\n  valid() { return true }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof WidgetType &&\n       (this.spec.key && this.spec.key == other.spec.key ||\n        this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))\n  }\n}\n\nclass InlineType {\n  constructor(attrs, spec) {\n    this.spec = spec || noSpec\n    this.attrs = attrs\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset\n    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset\n    return from >= to ? null : new Decoration(from, to, this)\n  }\n\n  valid(_, span) { return span.from < span.to }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n       compareObjs(this.spec, other.spec))\n  }\n\n  static is(span) { return span.type instanceof InlineType }\n}\n\nclass NodeType {\n  constructor(attrs, spec) {\n    this.spec = spec || noSpec\n    this.attrs = attrs\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.mapResult(span.from + oldOffset, 1)\n    if (from.deleted) return null\n    let to = mapping.mapResult(span.to + oldOffset, -1)\n    if (to.deleted || to.pos <= from.pos) return null\n    return new Decoration(from.pos - offset, to.pos - offset, this)\n  }\n\n  valid(node, span) {\n    let {index, offset} = node.content.findIndex(span.from)\n    return offset == span.from && offset + node.child(index).nodeSize == span.to\n  }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n       compareObjs(this.spec, other.spec))\n  }\n}\n\n// ::- Decoration objects can be provided to the view through the\n// [`decorations` prop](#view.EditorProps.decorations). They come in\n// several variants—see the static members of this class for details.\nexport class Decoration {\n  constructor(from, to, type) {\n    // :: number\n    // The start position of the decoration.\n    this.from = from\n    // :: number\n    // The end position. Will be the same as `from` for [widget\n    // decorations](#view.Decoration^widget).\n    this.to = to\n    this.type = type\n  }\n\n  copy(from, to) {\n    return new Decoration(from, to, this.type)\n  }\n\n  eq(other, offset = 0) {\n    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to\n  }\n\n  map(mapping, offset, oldOffset) {\n    return this.type.map(mapping, this, offset, oldOffset)\n  }\n\n  // :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration\n  // Creates a widget decoration, which is a DOM node that's shown in\n  // the document at the given position. It is recommended that you\n  // delay rendering the widget by passing a function that will be\n  // called when the widget is actually drawn in a view, but you can\n  // also directly pass a DOM node. `getPos` can be used to find the\n  // widget's current document position.\n  //\n  //   spec::- These options are supported:\n  //\n  //     side:: ?number\n  //     Controls which side of the document position this widget is\n  //     associated with. When negative, it is drawn before a cursor\n  //     at its position, and content inserted at that position ends\n  //     up after the widget. When zero (the default) or positive, the\n  //     widget is drawn after the cursor and content inserted there\n  //     ends up before the widget.\n  //\n  //     When there are multiple widgets at a given position, their\n  //     `side` values determine the order in which they appear. Those\n  //     with lower values appear first. The ordering of widgets with\n  //     the same `side` value is unspecified.\n  //\n  //     When `marks` is null, `side` also determines the marks that\n  //     the widget is wrapped in—those of the node before when\n  //     negative, those of the node after when positive.\n  //\n  //     marks:: ?[Mark]\n  //     The precise set of marks to draw around the widget.\n  //\n  //     stopEvent:: ?(event: dom.Event) → bool\n  //     Can be used to control which DOM events, when they bubble out\n  //     of this widget, the editor view should ignore.\n  //\n  //     ignoreSelection:: ?bool\n  //     When set (defaults to false), selection changes inside the\n  //     widget are ignored, and don't cause ProseMirror to try and\n  //     re-sync the selection with its selection state.\n  //\n  //     key:: ?string\n  //     When comparing decorations of this type (in order to decide\n  //     whether it needs to be redrawn), ProseMirror will by default\n  //     compare the widget DOM node by identity. If you pass a key,\n  //     that key will be compared instead, which can be useful when\n  //     you generate decorations on the fly and don't want to store\n  //     and reuse DOM nodes. Make sure that any widgets with the same\n  //     key are interchangeable—if widgets differ in, for example,\n  //     the behavior of some event handler, they should get\n  //     different keys.\n  static widget(pos, toDOM, spec) {\n    return new Decoration(pos, pos, new WidgetType(toDOM, spec))\n  }\n\n  // :: (number, number, DecorationAttrs, ?Object) → Decoration\n  // Creates an inline decoration, which adds the given attributes to\n  // each inline node between `from` and `to`.\n  //\n  //   spec::- These options are recognized:\n  //\n  //     inclusiveStart:: ?bool\n  //     Determines how the left side of the decoration is\n  //     [mapped](#transform.Position_Mapping) when content is\n  //     inserted directly at that position. By default, the decoration\n  //     won't include the new content, but you can set this to `true`\n  //     to make it inclusive.\n  //\n  //     inclusiveEnd:: ?bool\n  //     Determines how the right side of the decoration is mapped.\n  //     See\n  //     [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).\n  static inline(from, to, attrs, spec) {\n    return new Decoration(from, to, new InlineType(attrs, spec))\n  }\n\n  // :: (number, number, DecorationAttrs, ?Object) → Decoration\n  // Creates a node decoration. `from` and `to` should point precisely\n  // before and after a node in the document. That node, and only that\n  // node, will receive the given attributes.\n  //\n  //   spec::-\n  //\n  //   Optional information to store with the decoration. It\n  //   is also used when comparing decorators for equality.\n  static node(from, to, attrs, spec) {\n    return new Decoration(from, to, new NodeType(attrs, spec))\n  }\n\n  // :: Object\n  // The spec provided when creating this decoration. Can be useful\n  // if you've stored extra information in that object.\n  get spec() { return this.type.spec }\n\n  get inline() { return this.type instanceof InlineType }\n}\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nconst none = [], noSpec = {}\n\n// :: class extends DecorationSource\n// A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nexport class DecorationSet {\n  constructor(local, children) {\n    this.local = local && local.length ? local : none\n    this.children = children && children.length ? children : none\n  }\n\n  // :: (Node, [Decoration]) → DecorationSet\n  // Create a set of decorations, using the structure of the given\n  // document.\n  static create(doc, decorations) {\n    return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty\n  }\n\n  // :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]\n  // Find all decorations in this set which touch the given range\n  // (including decorations that start or end directly at the\n  // boundaries) and match the given predicate on their spec. When\n  // `start` and `end` are omitted, all decorations in the set are\n  // considered. When `predicate` isn't given, all decorations are\n  // assumed to match.\n  find(start, end, predicate) {\n    let result = []\n    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate)\n    return result\n  }\n\n  findInner(start, end, result, offset, predicate) {\n    for (let i = 0; i < this.local.length; i++) {\n      let span = this.local[i]\n      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n        result.push(span.copy(span.from + offset, span.to + offset))\n    }\n    for (let i = 0; i < this.children.length; i += 3) {\n      if (this.children[i] < end && this.children[i + 1] > start) {\n        let childOff = this.children[i] + 1\n        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate)\n      }\n    }\n  }\n\n  // :: (Mapping, Node, ?Object) → DecorationSet\n  // Map the set of decorations in response to a change in the\n  // document.\n  //\n  //   options::- An optional set of options.\n  //\n  //     onRemove:: ?(decorationSpec: Object)\n  //     When given, this function will be called for each decoration\n  //     that gets dropped as a result of the mapping, passing the\n  //     spec of that decoration.\n  map(mapping, doc, options) {\n    if (this == empty || mapping.maps.length == 0) return this\n    return this.mapInner(mapping, doc, 0, 0, options || noSpec)\n  }\n\n  mapInner(mapping, node, offset, oldOffset, options) {\n    let newLocal\n    for (let i = 0; i < this.local.length; i++) {\n      let mapped = this.local[i].map(mapping, offset, oldOffset)\n      if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped)\n      else if (options.onRemove) options.onRemove(this.local[i].spec)\n    }\n\n    if (this.children.length)\n      return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options)\n    else\n      return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty\n  }\n\n  // :: (Node, [Decoration]) → DecorationSet\n  // Add the given array of decorations to the ones in the set,\n  // producing a new set. Needs access to the current document to\n  // create the appropriate tree structure.\n  add(doc, decorations) {\n    if (!decorations.length) return this\n    if (this == empty) return DecorationSet.create(doc, decorations)\n    return this.addInner(doc, decorations, 0)\n  }\n\n  addInner(doc, decorations, offset) {\n    let children, childIndex = 0\n    doc.forEach((childNode, childOffset) => {\n      let baseOffset = childOffset + offset, found\n      if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return\n\n      if (!children) children = this.children.slice()\n      while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3\n      if (children[childIndex] == childOffset)\n        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1)\n      else\n        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec))\n      childIndex += 3\n    })\n\n    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset)\n    for (let i = 0; i < local.length; i++) if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1)\n\n    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                             children || this.children)\n  }\n\n  // :: ([Decoration]) → DecorationSet\n  // Create a new set that contains the decorations in this set, minus\n  // the ones in the given array.\n  remove(decorations) {\n    if (decorations.length == 0 || this == empty) return this\n    return this.removeInner(decorations, 0)\n  }\n\n  removeInner(decorations, offset) {\n    let children = this.children, local = this.local\n    for (let i = 0; i < children.length; i += 3) {\n      let found, from = children[i] + offset, to = children[i + 1] + offset\n      for (let j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {\n        if (span.from > from && span.to < to) {\n          decorations[j] = null\n          ;(found || (found = [])).push(span)\n        }\n      }\n      if (!found) continue\n      if (children == this.children) children = this.children.slice()\n      let removed = children[i + 2].removeInner(found, from + 1)\n      if (removed != empty) {\n        children[i + 2] = removed\n      } else {\n        children.splice(i, 3)\n        i -= 3\n      }\n    }\n    if (local.length) for (let i = 0, span; i < decorations.length; i++) if (span = decorations[i]) {\n      for (let j = 0; j < local.length; j++) if (local[j].eq(span, offset)) {\n        if (local == this.local) local = this.local.slice()\n        local.splice(j--, 1)\n      }\n    }\n    if (children == this.children && local == this.local) return this\n    return local.length || children.length ? new DecorationSet(local, children) : empty\n  }\n\n  forChild(offset, node) {\n    if (this == empty) return this\n    if (node.isLeaf) return DecorationSet.empty\n\n    let child, local\n    for (let i = 0; i < this.children.length; i += 3) if (this.children[i] >= offset) {\n      if (this.children[i] == offset) child = this.children[i + 2]\n      break\n    }\n    let start = offset + 1, end = start + node.content.size\n    for (let i = 0; i < this.local.length; i++) {\n      let dec = this.local[i]\n      if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start\n        if (from < to) (local || (local = [])).push(dec.copy(from, to))\n      }\n    }\n    if (local) {\n      let localSet = new DecorationSet(local.sort(byPos))\n      return child ? new DecorationGroup([localSet, child]) : localSet\n    }\n    return child || empty\n  }\n\n  eq(other) {\n    if (this == other) return true\n    if (!(other instanceof DecorationSet) ||\n        this.local.length != other.local.length ||\n        this.children.length != other.children.length) return false\n    for (let i = 0; i < this.local.length; i++)\n      if (!this.local[i].eq(other.local[i])) return false\n    for (let i = 0; i < this.children.length; i += 3)\n      if (this.children[i] != other.children[i] ||\n          this.children[i + 1] != other.children[i + 1] ||\n          !this.children[i + 2].eq(other.children[i + 2])) return false\n    return true\n  }\n\n  locals(node) {\n    return removeOverlap(this.localsInner(node))\n  }\n\n  localsInner(node) {\n    if (this == empty) return none\n    if (node.inlineContent || !this.local.some(InlineType.is)) return this.local\n    let result = []\n    for (let i = 0; i < this.local.length; i++) {\n      if (!(this.local[i].type instanceof InlineType))\n        result.push(this.local[i])\n    }\n    return result\n  }\n}\n\n// DecorationSource:: interface\n// An object that can [provide](#view.EditorProps.decorations)\n// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),\n// and passed to [node views](#view.EditorProps.nodeViews).\n\nconst empty = new DecorationSet()\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty\n\nDecorationSet.removeOverlap = removeOverlap\n\n// :- An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n  constructor(members) {\n    this.members = members\n  }\n\n  forChild(offset, child) {\n    if (child.isLeaf) return DecorationSet.empty\n    let found = []\n    for (let i = 0; i < this.members.length; i++) {\n      let result = this.members[i].forChild(offset, child)\n      if (result == empty) continue\n      if (result instanceof DecorationGroup) found = found.concat(result.members)\n      else found.push(result)\n    }\n    return DecorationGroup.from(found)\n  }\n\n  eq(other) {\n    if (!(other instanceof DecorationGroup) ||\n        other.members.length != this.members.length) return false\n    for (let i = 0; i < this.members.length; i++)\n      if (!this.members[i].eq(other.members[i])) return false\n    return true\n  }\n\n  locals(node) {\n    let result, sorted = true\n    for (let i = 0; i < this.members.length; i++) {\n      let locals = this.members[i].localsInner(node)\n      if (!locals.length) continue\n      if (!result) {\n        result = locals\n      } else {\n        if (sorted) {\n          result = result.slice()\n          sorted = false\n        }\n        for (let j = 0; j < locals.length; j++) result.push(locals[j])\n      }\n    }\n    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n  }\n\n  // : ([DecorationSet]) → union<DecorationSet, DecorationGroup>\n  // Create a group for the given array of decoration sets, or return\n  // a single set when possible.\n  static from(members) {\n    switch (members.length) {\n      case 0: return empty\n      case 1: return members[0]\n      default: return new DecorationGroup(members)\n    }\n  }\n}\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  let children = oldChildren.slice()\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  let shift = (oldStart, oldEnd, newStart, newEnd) => {\n    for (let i = 0; i < children.length; i += 3) {\n      let end = children[i + 1], dSize\n      if (end == -1 || oldStart > end + oldOffset) continue\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1\n      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {\n        children[i] += dSize\n        children[i + 1] += dSize\n      }\n    }\n  }\n  for (let i = 0; i < mapping.maps.length; i++) mapping.maps[i].forEach(shift)\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  let mustRebuild = false\n  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1) { // Touched nodes\n    let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset\n    let {index, offset: childOffset} = node.content.findIndex(fromLocal)\n    let childNode = node.maybeChild(index)\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options)\n      if (mapped != empty) {\n        children[i] = fromLocal\n        children[i + 1] = toLocal\n        children[i + 2] = mapped\n      } else {\n        children[i + 1] = -2\n        mustRebuild = true\n      }\n    } else {\n      mustRebuild = true\n    }\n  }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,\n                                                       offset, oldOffset, options)\n    let built = buildTree(decorations, node, 0, options)\n    newLocal = built.local\n    for (let i = 0; i < children.length; i += 3) if (children[i + 1] < 0) {\n      children.splice(i, 3)\n      i -= 3\n    }\n    for (let i = 0, j = 0; i < built.children.length; i += 3) {\n      let from = built.children[i]\n      while (j < children.length && children[j] < from) j += 3\n      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2])\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) return spans\n  let result = []\n  for (let i = 0; i < spans.length; i++) {\n    let span = spans[i]\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type))\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (let i = 0; i < set.local.length; i++) {\n      let mapped = set.local[i].map(mapping, offset, oldOffset)\n      if (mapped) decorations.push(mapped)\n      else if (options.onRemove) options.onRemove(set.local[i].spec)\n    }\n    for (let i = 0; i < set.children.length; i += 3)\n      gather(set.children[i + 2], set.children[i] + oldOffset + 1)\n  }\n  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1)\n    gather(children[i + 2], oldChildren[i] + oldOffset + 1)\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) return null\n  let end = offset + node.nodeSize, found = null\n  for (let i = 0, span; i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      ;(found || (found = [])).push(span)\n      spans[i] = null\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  let result = []\n  for (let i = 0; i < array.length; i++)\n    if (array[i] != null) result.push(array[i])\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtractet from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  let children = [], hasNulls = false\n  node.forEach((childNode, localStart) => {\n    let found = takeSpansForNode(spans, childNode, localStart + offset)\n    if (found) {\n      hasNulls = true\n      let subtree = buildTree(found, childNode, offset + localStart + 1, options)\n      if (subtree != empty)\n        children.push(localStart, localStart + childNode.nodeSize, subtree)\n    }\n  })\n  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos)\n  for (let i = 0; i < locals.length; i++) if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) options.onRemove(locals[i].spec)\n    locals.splice(i--, 1)\n  }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decoration]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  let working = spans\n  for (let i = 0; i < working.length - 1; i++) {\n    let span = working[i]\n    if (span.from != span.to) for (let j = i + 1; j < working.length; j++) {\n      let next = working[j]\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) working = spans.slice()\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to)\n          insertAhead(working, j + 1, next.copy(span.to, next.to))\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) working = spans.slice()\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from)\n          insertAhead(working, j, span.copy(next.from, span.to))\n        }\n        break\n      }\n    }\n  }\n  return working\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) i++\n  array.splice(i, 0, deco)\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nexport function viewDecorations(view) {\n  let found = []\n  view.someProp(\"decorations\", f => {\n    let result = f(view.state)\n    if (result && result != empty) found.push(result)\n  })\n  if (view.cursorWrapper)\n    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]))\n  return DecorationGroup.from(found)\n}\n","import {NodeSelection} from \"prosemirror-state\"\n\nimport {scrollRectIntoView, posAtCoords, coordsAtPos, endOfTextblock, storeScrollPos,\n        resetScrollPos, focusPreventScroll} from \"./domcoords\"\nimport {docViewDesc} from \"./viewdesc\"\nimport {initInput, destroyInput, dispatchEvent, ensureListeners, clearComposition} from \"./input\"\nimport {selectionToDOM, anchorInRightPlace, syncNodeSelection} from \"./selection\"\nimport {Decoration, viewDecorations} from \"./decoration\"\nimport browser from \"./browser\"\n\nexport {Decoration, DecorationSet} from \"./decoration\"\n\n// Exported for testing\nexport {serializeForClipboard as __serializeForClipboard, parseFromClipboard as __parseFromClipboard} from \"./clipboard\"\nexport {endComposition as __endComposition} from \"./input\"\n\n// ::- An editor view manages the DOM structure that represents an\n// editable document. Its state and behavior are determined by its\n// [props](#view.DirectEditorProps).\nexport class EditorView {\n  // :: (?union<dom.Node, (dom.Node), {mount: dom.Node}>, DirectEditorProps)\n  // Create a view. `place` may be a DOM node that the editor should\n  // be appended to, a function that will place it into the document,\n  // or an object whose `mount` property holds the node to use as the\n  // document container. If it is `null`, the editor will not be added\n  // to the document.\n  constructor(place, props) {\n    this._props = props\n    // :: EditorState\n    // The view's current [state](#state.EditorState).\n    this.state = props.state\n\n    this.dispatch = this.dispatch.bind(this)\n\n    this._root = null\n    this.focused = false\n    // Kludge used to work around a Chrome bug\n    this.trackWrites = null\n\n    // :: dom.Element\n    // An editable DOM node containing the document. (You probably\n    // should not directly interfere with its content.)\n    this.dom = (place && place.mount) || document.createElement(\"div\")\n    if (place) {\n      if (place.appendChild) place.appendChild(this.dom)\n      else if (place.apply) place(this.dom)\n      else if (place.mount) this.mounted = true\n    }\n\n    // :: bool\n    // Indicates whether the editor is currently [editable](#view.EditorProps.editable).\n    this.editable = getEditable(this)\n    this.markCursor = null\n    this.cursorWrapper = null\n    updateCursorWrapper(this)\n    this.nodeViews = buildNodeViews(this)\n    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this)\n\n    this.lastSelectedViewDesc = null\n    // :: ?{slice: Slice, move: bool}\n    // When editor content is being dragged, this object contains\n    // information about the dragged slice and whether it is being\n    // copied or moved. At any other time, it is null.\n    this.dragging = null\n\n    initInput(this)\n\n    this.pluginViews = []\n    this.updatePluginViews()\n  }\n\n  // composing:: boolean\n  // Holds `true` when a\n  // [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)\n  // is active.\n\n  // :: DirectEditorProps\n  // The view's current [props](#view.EditorProps).\n  get props() {\n    if (this._props.state != this.state) {\n      let prev = this._props\n      this._props = {}\n      for (let name in prev) this._props[name] = prev[name]\n      this._props.state = this.state\n    }\n    return this._props\n  }\n\n  // :: (DirectEditorProps)\n  // Update the view's props. Will immediately cause an update to\n  // the DOM.\n  update(props) {\n    if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this)\n    this._props = props\n    this.updateStateInner(props.state, true)\n  }\n\n  // :: (DirectEditorProps)\n  // Update the view by updating existing props object with the object\n  // given as argument. Equivalent to `view.update(Object.assign({},\n  // view.props, props))`.\n  setProps(props) {\n    let updated = {}\n    for (let name in this._props) updated[name] = this._props[name]\n    updated.state = this.state\n    for (let name in props) updated[name] = props[name]\n    this.update(updated)\n  }\n\n  // :: (EditorState)\n  // Update the editor's `state` prop, without touching any of the\n  // other props.\n  updateState(state) {\n    this.updateStateInner(state, this.state.plugins != state.plugins)\n  }\n\n  updateStateInner(state, reconfigured) {\n    let prev = this.state, redraw = false, updateSel = false\n    // When stored marks are added, stop composition, so that they can\n    // be displayed.\n    if (state.storedMarks && this.composing) {\n      clearComposition(this)\n      updateSel = true\n    }\n    this.state = state\n    if (reconfigured) {\n      let nodeViews = buildNodeViews(this)\n      if (changedNodeViews(nodeViews, this.nodeViews)) {\n        this.nodeViews = nodeViews\n        redraw = true\n      }\n      ensureListeners(this)\n    }\n\n    this.editable = getEditable(this)\n    updateCursorWrapper(this)\n    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this)\n\n    let scroll = reconfigured ? \"reset\"\n        : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\"\n    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco)\n    if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true\n    let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this)\n\n    if (updateSel) {\n      this.domObserver.stop()\n      // Work around an issue in Chrome, IE, and Edge where changing\n      // the DOM around an active selection puts it into a broken\n      // state where the thing the user sees differs from the\n      // selection reported by the Selection object (#710, #973,\n      // #1011, #1013, #1035).\n      let forceSelUpdate = updateDoc && (browser.ie || browser.chrome) && !this.composing &&\n          !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection)\n      if (updateDoc) {\n        // If the node that the selection points into is written to,\n        // Chrome sometimes starts misreporting the selection, so this\n        // tracks that and forces a selection reset when our update\n        // did write to the node.\n        let chromeKludge = browser.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null\n        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n          this.docView.updateOuterDeco([])\n          this.docView.destroy()\n          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this)\n        }\n        if (chromeKludge && !this.trackWrites) forceSelUpdate = true\n      }\n      // Work around for an issue where an update arriving right between\n      // a DOM selection change and the \"selectionchange\" event for it\n      // can cause a spurious DOM selection update, disrupting mouse\n      // drag selection.\n      if (forceSelUpdate ||\n          !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {\n        selectionToDOM(this, forceSelUpdate)\n      } else {\n        syncNodeSelection(this, state.selection)\n        this.domObserver.setCurSelection()\n      }\n      this.domObserver.start()\n    }\n\n    this.updatePluginViews(prev)\n\n    if (scroll == \"reset\") {\n      this.dom.scrollTop = 0\n    } else if (scroll == \"to selection\") {\n      let startDOM = this.root.getSelection().focusNode\n      if (this.someProp(\"handleScrollToSelection\", f => f(this)))\n        {} // Handled\n      else if (state.selection instanceof NodeSelection)\n        scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM)\n      else\n        scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM)\n    } else if (oldScrollPos) {\n      resetScrollPos(oldScrollPos)\n    }\n  }\n\n  destroyPluginViews() {\n    let view\n    while (view = this.pluginViews.pop()) if (view.destroy) view.destroy()\n  }\n\n  updatePluginViews(prevState) {\n    if (!prevState || prevState.plugins != this.state.plugins) {\n      this.destroyPluginViews()\n      for (let i = 0; i < this.state.plugins.length; i++) {\n        let plugin = this.state.plugins[i]\n        if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this))\n      }\n    } else {\n      for (let i = 0; i < this.pluginViews.length; i++) {\n        let pluginView = this.pluginViews[i]\n        if (pluginView.update) pluginView.update(this, prevState)\n      }\n    }\n  }\n\n  // :: (string, ?(prop: *) → *) → *\n  // Goes over the values of a prop, first those provided directly,\n  // then those from plugins (in order), and calls `f` every time a\n  // non-undefined value is found. When `f` returns a truthy value,\n  // that is immediately returned. When `f` isn't provided, it is\n  // treated as the identity function (the prop value is returned\n  // directly).\n  someProp(propName, f) {\n    let prop = this._props && this._props[propName], value\n    if (prop != null && (value = f ? f(prop) : prop)) return value\n    let plugins = this.state.plugins\n    if (plugins) for (let i = 0; i < plugins.length; i++) {\n      let prop = plugins[i].props[propName]\n      if (prop != null && (value = f ? f(prop) : prop)) return value\n    }\n  }\n\n  // :: () → bool\n  // Query whether the view has focus.\n  hasFocus() {\n    return this.root.activeElement == this.dom\n  }\n\n  // :: ()\n  // Focus the editor.\n  focus() {\n    this.domObserver.stop()\n    if (this.editable) focusPreventScroll(this.dom)\n    selectionToDOM(this)\n    this.domObserver.start()\n  }\n\n  // :: union<dom.Document, dom.DocumentFragment>\n  // Get the document root in which the editor exists. This will\n  // usually be the top-level `document`, but might be a [shadow\n  // DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n  // root if the editor is inside one.\n  get root() {\n    let cached = this._root\n    if (cached == null) for (let search = this.dom.parentNode; search; search = search.parentNode) {\n      if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n        if (!search.getSelection) Object.getPrototypeOf(search).getSelection = () => document.getSelection()\n        return this._root = search\n      }\n    }\n    return cached || document\n  }\n\n  // :: ({left: number, top: number}) → ?{pos: number, inside: number}\n  // Given a pair of viewport coordinates, return the document\n  // position that corresponds to them. May return null if the given\n  // coordinates aren't inside of the editor. When an object is\n  // returned, its `pos` property is the position nearest to the\n  // coordinates, and its `inside` property holds the position of the\n  // inner node that the position falls inside of, or -1 if it is at\n  // the top level, not in any node.\n  posAtCoords(coords) {\n    return posAtCoords(this, coords)\n  }\n\n  // :: (number, number) → {left: number, right: number, top: number, bottom: number}\n  // Returns the viewport rectangle at a given document position.\n  // `left` and `right` will be the same number, as this returns a\n  // flat cursor-ish rectangle. If the position is between two things\n  // that aren't directly adjacent, `side` determines which element is\n  // used. When < 0, the element before the position is used,\n  // otherwise the element after.\n  coordsAtPos(pos, side = 1) {\n    return coordsAtPos(this, pos, side)\n  }\n\n  // :: (number, number) → {node: dom.Node, offset: number}\n  // Find the DOM position that corresponds to the given document\n  // position. When `side` is negative, find the position as close as\n  // possible to the content before the position. When positive,\n  // prefer positions close to the content after the position. When\n  // zero, prefer as shallow a position as possible.\n  //\n  // Note that you should **not** mutate the editor's internal DOM,\n  // only inspect it (and even that is usually not necessary).\n  domAtPos(pos, side = 0) {\n    return this.docView.domFromPos(pos, side)\n  }\n\n  // :: (number) → ?dom.Node\n  // Find the DOM node that represents the document node after the\n  // given position. May return `null` when the position doesn't point\n  // in front of a node or if the node is inside an opaque node view.\n  //\n  // This is intended to be able to call things like\n  // `getBoundingClientRect` on that DOM node. Do **not** mutate the\n  // editor DOM directly, or add styling this way, since that will be\n  // immediately overriden by the editor as it redraws the node.\n  nodeDOM(pos) {\n    let desc = this.docView.descAt(pos)\n    return desc ? desc.nodeDOM : null\n  }\n\n  // :: (dom.Node, number, ?number) → number\n  // Find the document position that corresponds to a given DOM\n  // position. (Whenever possible, it is preferable to inspect the\n  // document structure directly, rather than poking around in the\n  // DOM, but sometimes—for example when interpreting an event\n  // target—you don't have a choice.)\n  //\n  // The `bias` parameter can be used to influence which side of a DOM\n  // node to use when the position is inside a leaf node.\n  posAtDOM(node, offset, bias = -1) {\n    let pos = this.docView.posFromDOM(node, offset, bias)\n    if (pos == null) throw new RangeError(\"DOM position not inside the editor\")\n    return pos\n  }\n\n  // :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n  // Find out whether the selection is at the end of a textblock when\n  // moving in a given direction. When, for example, given `\"left\"`,\n  // it will return true if moving left from the current cursor\n  // position would leave that position's parent textblock. Will apply\n  // to the view's current state by default, but it is possible to\n  // pass a different state.\n  endOfTextblock(dir, state) {\n    return endOfTextblock(this, state || this.state, dir)\n  }\n\n  // :: ()\n  // Removes the editor from the DOM and destroys all [node\n  // views](#view.NodeView).\n  destroy() {\n    if (!this.docView) return\n    destroyInput(this)\n    this.destroyPluginViews()\n    if (this.mounted) {\n      this.docView.update(this.state.doc, [], viewDecorations(this), this)\n      this.dom.textContent = \"\"\n    } else if (this.dom.parentNode) {\n      this.dom.parentNode.removeChild(this.dom)\n    }\n    this.docView.destroy()\n    this.docView = null\n  }\n\n  // Used for testing.\n  dispatchEvent(event) {\n    return dispatchEvent(this, event)\n  }\n\n  // :: (Transaction)\n  // Dispatch a transaction. Will call\n  // [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)\n  // when given, and otherwise defaults to applying the transaction to\n  // the current state and calling\n  // [`updateState`](#view.EditorView.updateState) with the result.\n  // This method is bound to the view instance, so that it can be\n  // easily passed around.\n  dispatch(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction\n    if (dispatchTransaction) dispatchTransaction.call(this, tr)\n    else this.updateState(this.state.apply(tr))\n  }\n}\n\nfunction computeDocDeco(view) {\n  let attrs = Object.create(null)\n  attrs.class = \"ProseMirror\"\n  attrs.contenteditable = String(view.editable)\n\n  view.someProp(\"attributes\", value => {\n    if (typeof value == \"function\") value = value(view.state)\n    if (value) for (let attr in value) {\n      if (attr == \"class\")\n        attrs.class += \" \" + value[attr]\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        attrs[attr] = String(value[attr])\n    }\n  })\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    let dom = document.createElement(\"img\")\n    dom.setAttribute(\"mark-placeholder\", \"true\")\n    view.cursorWrapper = {dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})}\n  } else {\n    view.cursorWrapper = null\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", value => value(view.state) === false)\n}\n\nfunction selectionContextChanged(sel1, sel2) {\n  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head))\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)\n}\n\nfunction buildNodeViews(view) {\n  let result = {}\n  view.someProp(\"nodeViews\", obj => {\n    for (let prop in obj) if (!Object.prototype.hasOwnProperty.call(result, prop))\n      result[prop] = obj[prop]\n  })\n  return result\n}\n\nfunction changedNodeViews(a, b) {\n  let nA = 0, nB = 0\n  for (let prop in a) {\n    if (a[prop] != b[prop]) return true\n    nA++\n  }\n  for (let _ in b) nB++\n  return nA != nB\n}\n\n// EditorProps:: interface\n//\n// Props are configuration values that can be passed to an editor view\n// or included in a plugin. This interface lists the supported props.\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// How a prop is resolved depends on the prop. Handler functions are\n// called one at a time, starting with the base props and then\n// searching through the plugins (in order of appearance) until one of\n// them returns true. For some props, the first plugin that yields a\n// value gets precedence.\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   behavior of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool\n//   Can be used to override the behavior of pasting. `slice` is the\n//   pasted content parsed by the editor, but you can directly access\n//   the event to get at the raw content.\n//\n//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool\n//   Called when something is dropped on the editor. `moved` will be\n//   true if this drop moves from the current selection (which should\n//   thus be deleted).\n//\n//   handleScrollToSelection:: ?(view: EditorView) → bool\n//   Called when the view, after updating its state, tries to scroll\n//   the selection into view. A handler function may return false to\n//   indicate that it did not handle the scrolling and further\n//   handlers or the default behavior should be tried.\n//\n//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection\n//   Can be used to override the way a selection is created when\n//   reading a DOM selection between the given anchor and head.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   transformPastedHTML:: ?(html: string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPastedText:: ?(text: string, plain: bool) → string\n//   Transform pasted plain text. The `plain` flag will be true when\n//   the text is pasted as plain text.\n//\n//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice\n//   A function to parse text from the clipboard into a document\n//   slice. Called after\n//   [`transformPastedText`](#view.EditorProps.transformPastedText).\n//   The default behavior is to split the text into lines, wrap them\n//   in `<p>` tags, and call\n//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.\n//   The `plain` flag will be true when the text is pasted as plain text.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor\n//   functions that produce a [`NodeView`](#view.NodeView) object\n//   implementing the node's display behavior. For nodes, the third\n//   argument `getPos` is a function that can be called to get the\n//   node's current position, which can be useful when creating\n//   transactions to update it. For marks, the third argument is a\n//   boolean that indicates whether the mark's content is inline.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   `innerDecorations` holds the decorations for the node's content.\n//   You can safely ignore this if your view has no content or a\n//   `contentDOM` property, since the editor will draw the decorations\n//   on the content. But if you, for example, want to create a nested\n//   editor with the content, it may make sense to provide it with the\n//   inner decorations.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used.\n//\n//   clipboardTextSerializer:: ?(Slice) → string\n//   A function that will be called to get the text for the current\n//   selection when copying text to the clipboard. By default, the\n//   editor will use [`textBetween`](#model.Node.textBetween) on the\n//   selected range.\n//\n//   decorations:: ?(state: EditorState) → ?DecorationSource\n//   A set of [document decorations](#view.Decoration) to show in the\n//   view.\n//\n//   editable:: ?(state: EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n// DirectEditorProps:: interface extends EditorProps\n//\n// The props object given directly to the editor view supports two\n// fields that can't be used in plugins:\n//\n//   state:: EditorState\n//   The current state of the editor.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. If you specify this, you probably want to\n//   make sure this ends up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply). The callback will be bound to have\n//   the view instance as its `this` binding.\n","import {Selection, NodeSelection} from \"prosemirror-state\"\nimport {Slice} from \"prosemirror-model\"\n\n// ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\nexport class GapCursor extends Selection {\n  // : (ResolvedPos)\n  constructor($pos) {\n    super($pos, $pos)\n  }\n\n  map(doc, mapping) {\n    let $pos = doc.resolve(mapping.map(this.head))\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n\n  content() { return Slice.empty }\n\n  eq(other) {\n    return other instanceof GapCursor && other.head == this.head\n  }\n\n  toJSON() {\n    return {type: \"gapcursor\", pos: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\")\n    return new GapCursor(doc.resolve(json.pos))\n  }\n\n  getBookmark() { return new GapBookmark(this.anchor) }\n\n  static valid($pos) {\n    let parent = $pos.parent\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false\n    let override = parent.type.spec.allowGapCursor\n    if (override != null) return override\n    let deflt = parent.contentMatchAt($pos.index()).defaultType\n    return deflt && deflt.isTextblock\n  }\n\n  static findFrom($pos, dir, mustMove) {\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) return $pos\n      let pos = $pos.pos, next = null\n      // Scan up from this position\n      for (let d = $pos.depth;; d--) {\n        let parent = $pos.node(d)\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1)\n          break\n        } else if (d == 0) {\n          return null\n        }\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      // And then down into the next node\n      for (;;) {\n        let inside = dir > 0 ? next.firstChild : next.lastChild\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir)\n            mustMove = false\n            continue search\n          }\n          break\n        }\n        next = inside\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      return null\n    }\n  }\n}\n\nGapCursor.prototype.visible = false\n\nSelection.jsonID(\"gapcursor\", GapCursor)\n\nclass GapBookmark {\n  constructor(pos) {\n    this.pos = pos\n  }\n  map(mapping) {\n    return new GapBookmark(mapping.map(this.pos))\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.pos)\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n}\n\nfunction closedBefore($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.index(d)\n    // At the start of this parent, look at next one\n    if (index == 0) continue\n    // See if the node before (or its first ancestor) is closed\n    for (let before = $pos.node(d).child(index - 1);; before = before.lastChild) {\n      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) return true\n      if (before.inlineContent) return false\n    }\n  }\n  // Hit start of document\n  return true\n}\n\nfunction closedAfter($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.indexAfter(d), parent = $pos.node(d)\n    if (index == parent.childCount) continue\n    for (let after = parent.child(index);; after = after.firstChild) {\n      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) return true\n      if (after.inlineContent) return false\n    }\n  }\n  return true\n}\n","import {keydownHandler} from \"prosemirror-keymap\"\nimport {TextSelection, NodeSelection, Plugin} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\n\nimport {GapCursor} from \"./gapcursor\"\n\n// :: () → Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\nexport const gapCursor = function() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n\n      createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) return new GapCursor($head)\n      },\n\n      handleClick,\n      handleKeyDown\n    }\n  })\n}\n\nexport {GapCursor}\n\nconst handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n})\n\nfunction arrow(axis, dir) {\n  let dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\")\n  return function(state, dispatch, view) {\n    let sel = state.selection\n    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false\n      mustMove = false\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before())\n    }\n    let $found = GapCursor.findFrom($start, dir, mustMove)\n    if (!$found) return false\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)))\n    return true\n  }\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view.editable) return false\n  let $pos = view.state.doc.resolve(pos)\n  if (!GapCursor.valid($pos)) return false\n  let {inside} = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) return false\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)))\n  return true\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null\n  let node = document.createElement(\"div\")\n  node.className = \"ProseMirror-gapcursor\"\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {key: \"gapcursor\"})])\n}\n","import { Node } from '@tiptap/core'\n\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n})\n","import { Command, Node, mergeAttributes } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       */\n      setParagraph: () => Command,\n    }\n  }\n}\n\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [\n      { tag: 'p' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setParagraph: () => ({ commands }) => {\n        return commands.toggleNode('paragraph', 'paragraph')\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n","import { Node } from '@tiptap/core'\n\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n})\n","var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n","import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) → Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n","import {\n  Command,\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface BoldOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => Command,\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => Command,\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => Command,\n    }\n  }\n}\n\nexport const starInputRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))$/gm\nexport const starPasteRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))/gm\nexport const underscoreInputRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))$/gm\nexport const underscorePasteRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))/gm\n\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['strong', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setBold: () => ({ commands }) => {\n        return commands.setMark('bold')\n      },\n      toggleBold: () => ({ commands }) => {\n        return commands.toggleMark('bold')\n      },\n      unsetBold: () => ({ commands }) => {\n        return commands.unsetMark('bold')\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule(starInputRegex, this.type),\n      markInputRule(underscoreInputRegex, this.type),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule(starPasteRegex, this.type),\n      markPasteRule(underscorePasteRegex, this.type),\n    ]\n  },\n})\n","import {\n  Command,\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface ItalicOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    italic: {\n      /**\n       * Set an italic mark\n       */\n      setItalic: () => Command,\n      /**\n       * Toggle an italic mark\n       */\n      toggleItalic: () => Command,\n      /**\n       * Unset an italic mark\n       */\n      unsetItalic: () => Command,\n    }\n  }\n}\n\nexport const starInputRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))$/gm\nexport const starPasteRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))/gm\nexport const underscoreInputRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))$/gm\nexport const underscorePasteRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))/gm\n\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic: () => ({ commands }) => {\n        return commands.setMark('italic')\n      },\n      toggleItalic: () => ({ commands }) => {\n        return commands.toggleMark('italic')\n      },\n      unsetItalic: () => ({ commands }) => {\n        return commands.unsetMark('italic')\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule(starInputRegex, this.type),\n      markInputRule(underscoreInputRegex, this.type),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule(starPasteRegex, this.type),\n      markPasteRule(underscorePasteRegex, this.type),\n    ]\n  },\n})\n","import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n","import { Command, Node } from '@tiptap/core'\nimport { textblockTypeInputRule } from 'prosemirror-inputrules'\n\nexport interface CodeBlockOptions {\n  languageClassPrefix: string,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    codeBlock: {\n      /**\n       * Set a code block\n       */\n      setCodeBlock: (attributes?: { language: string }) => Command,\n      /**\n       * Toggle a code block\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => Command,\n    }\n  }\n}\n\nexport const backtickInputRegex = /^```(?<language>[a-z]*)? $/\nexport const tildeInputRegex = /^~~~(?<language>[a-z]*)? $/\n\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  defaultOptions: {\n    languageClassPrefix: 'language-',\n    HTMLAttributes: {},\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: element => {\n          const classAttribute = element.firstElementChild?.getAttribute('class')\n\n          if (!classAttribute) {\n            return null\n          }\n\n          const regexLanguageClassPrefix = new RegExp(`^(${this.options.languageClassPrefix})`)\n\n          return {\n            language: classAttribute.replace(regexLanguageClassPrefix, ''),\n          }\n        },\n        renderHTML: attributes => {\n          if (!attributes.language) {\n            return null\n          }\n\n          return {\n            class: this.options.languageClassPrefix + attributes.language,\n          }\n        },\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['pre', this.options.HTMLAttributes, ['code', HTMLAttributes, 0]]\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock: attributes => ({ commands }) => {\n        return commands.setNode('codeBlock', attributes)\n      },\n      toggleCodeBlock: attributes => ({ commands }) => {\n        return commands.toggleNode('codeBlock', 'paragraph', attributes)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule(backtickInputRegex, this.type, ({ groups }: any) => groups),\n      textblockTypeInputRule(tildeInputRegex, this.type, ({ groups }: any) => groups),\n    ]\n  },\n})\n","import { Command, Node, mergeAttributes } from '@tiptap/core'\nimport { textblockTypeInputRule } from 'prosemirror-inputrules'\n\ntype Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  levels: Level[],\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    heading: {\n      /**\n       * Set a heading node\n       */\n      setHeading: (attributes: { level: Level }) => Command,\n      /**\n       * Toggle a heading node\n       */\n      toggleHeading: (attributes: { level: Level }) => Command,\n    }\n  }\n}\n\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  defaultOptions: {\n    levels: [1, 2, 3, 4, 5, 6],\n    HTMLAttributes: {},\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels\n      .map((level: Level) => ({\n        tag: `h${level}`,\n        attrs: { level },\n      }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel\n      ? node.attrs.level\n      : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setHeading: attributes => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false\n        }\n\n        return commands.setNode('heading', attributes)\n      },\n      toggleHeading: attributes => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false\n        }\n\n        return commands.toggleNode('heading', 'paragraph', attributes)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce((items, level) => ({\n      ...items,\n      ...{\n        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n      },\n    }), {})\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule(new RegExp(`^(#{1,${level}})\\\\s$`), this.type, { level })\n    })\n  },\n})\n","import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                      : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild))\n    if (node.isTextblock) return true\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                      : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from([deflt.create(), $from.parent])))\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && after.isTextblock && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    if (at.canReplace(at.childCount, at.childCount, after.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + 1, $cut.pos + after.nodeSize - 1,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable))\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n","import {\n  Command,\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface StrikeOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    strike: {\n      /**\n       * Set a strike mark\n       */\n      setStrike: () => Command,\n      /**\n       * Toggle a strike mark\n       */\n      toggleStrike: () => Command,\n      /**\n       * Unset a strike mark\n       */\n      unsetStrike: () => Command,\n    }\n  }\n}\n\nexport const inputRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))$/gm\nexport const pasteRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))/gm\n\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setStrike: () => ({ commands }) => {\n        return commands.setMark('strike')\n      },\n      toggleStrike: () => ({ commands }) => {\n        return commands.toggleMark('strike')\n      },\n      unsetStrike: () => ({ commands }) => {\n        return commands.unsetMark('strike')\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-x': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule(inputRegex, this.type),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule(inputRegex, this.type),\n    ]\n  },\n})\n","import { Command, Node, mergeAttributes } from '@tiptap/core'\nimport { wrappingInputRule } from 'prosemirror-inputrules'\n\nexport interface BlockquoteOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => Command,\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => Command,\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => Command,\n    }\n  }\n}\n\nexport const inputRegex = /^\\s*>\\s$/gm\n\nexport const Blockquote = Node.create<BlockquoteOptions>({\n\n  name: 'blockquote',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  content: 'block*',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      { tag: 'blockquote' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['blockquote', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setBlockquote: () => ({ commands }) => {\n        return commands.wrapIn('blockquote')\n      },\n      toggleBlockquote: () => ({ commands }) => {\n        return commands.toggleWrap('blockquote')\n      },\n      unsetBlockquote: () => ({ commands }) => {\n        return commands.lift('blockquote')\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule(inputRegex, this.type),\n    ]\n  },\n})\n","import {\n  Command,\n  Node,\n  nodeInputRule,\n  mergeAttributes,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => Command,\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'hr' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ tr, dispatch }) => {\n        if (dispatch) {\n          tr.replaceSelectionWith(this.type.create())\n\n          const { parent, pos } = tr.selection.$from\n          const posAfter = pos + 1\n          const nodeAfter = tr.doc.nodeAt(posAfter)\n\n          // end of document\n          if (!nodeAfter) {\n            const node = parent.type.contentMatch.defaultType?.create()\n\n            if (node) {\n              tr.insert(posAfter, node)\n              tr.setSelection(TextSelection.create(tr.doc, posAfter))\n            }\n          }\n\n          tr.scrollIntoView()\n        }\n\n        return true\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, this.type),\n    ]\n  },\n})\n","import { Command, Node, mergeAttributes } from '@tiptap/core'\nimport { wrappingInputRule } from 'prosemirror-inputrules'\n\nexport interface OrderedListOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       */\n      toggleOrderedList: () => Command,\n    }\n  }\n}\n\nexport const inputRegex = /^(\\d+)\\.\\s$/\n\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  group: 'block list',\n\n  content: 'listItem+',\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => ({\n          start: element.hasAttribute('start')\n            ? parseInt(element.getAttribute('start') || '', 10)\n            : 1,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands }) => {\n        return commands.toggleList('orderedList', 'listItem')\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule(\n        inputRegex,\n        this.type,\n        match => ({ order: +match[1] }),\n        (match, node) => node.childCount + node.attrs.order === +match[1],\n      ),\n    ]\n  },\n})\n","import { Node, mergeAttributes } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem('listItem'),\n      Tab: () => this.editor.commands.sinkListItem('listItem'),\n      'Shift-Tab': () => this.editor.commands.liftListItem('listItem'),\n    }\n  },\n})\n","import Dropcursor, { DropcursorOptions } from '@tiptap/extension-dropcursor'\nimport Gapcursor from '@tiptap/extension-gapcursor'\nimport Document from '@tiptap/extension-document'\nimport Paragraph, { ParagraphOptions } from '@tiptap/extension-paragraph'\nimport Text from '@tiptap/extension-text'\nimport History, { HistoryOptions } from '@tiptap/extension-history'\nimport Bold, { BoldOptions } from '@tiptap/extension-bold'\nimport Italic, { ItalicOptions } from '@tiptap/extension-italic'\nimport Code, { CodeOptions } from '@tiptap/extension-code'\nimport CodeBlock, { CodeBlockOptions } from '@tiptap/extension-code-block'\nimport Heading, { HeadingOptions } from '@tiptap/extension-heading'\nimport HardBreak, { HardBreakOptions } from '@tiptap/extension-hard-break'\nimport Strike, { StrikeOptions } from '@tiptap/extension-strike'\nimport Blockquote, { BlockquoteOptions } from '@tiptap/extension-blockquote'\nimport HorizontalRule, { HorizontalRuleOptions } from '@tiptap/extension-horizontal-rule'\nimport BulletList, { BulletListOptions } from '@tiptap/extension-bullet-list'\nimport OrderedList, { OrderedListOptions } from '@tiptap/extension-ordered-list'\nimport ListItem, { ListItemOptions } from '@tiptap/extension-list-item'\n\nexport function defaultExtensions(options?: Partial<{\n  dropcursor: Partial<DropcursorOptions>,\n  paragraph: Partial<ParagraphOptions>,\n  history: Partial<HistoryOptions>,\n  bold: Partial<BoldOptions>,\n  italic: Partial<ItalicOptions>,\n  code: Partial<CodeOptions>,\n  codeBlock: Partial<CodeBlockOptions>,\n  heading: Partial<HeadingOptions>,\n  hardBreak: Partial<HardBreakOptions>,\n  strike: Partial<StrikeOptions>,\n  blockquote: Partial<BlockquoteOptions>,\n  horizontalRule: Partial<HorizontalRuleOptions>,\n  bulletList: Partial<BulletListOptions>,\n  orderedList: Partial<OrderedListOptions>,\n  listItem: Partial<ListItemOptions>,\n}>) {\n  return [\n    Document,\n    Paragraph.configure(options?.paragraph),\n    Text,\n    Bold.configure(options?.bold),\n    Italic.configure(options?.italic),\n    Code.configure(options?.code),\n    Strike.configure(options?.strike),\n    HardBreak.configure(options?.hardBreak),\n    Heading.configure(options?.heading),\n    Blockquote.configure(options?.blockquote),\n    BulletList.configure(options?.bulletList),\n    OrderedList.configure(options?.orderedList),\n    ListItem.configure(options?.listItem),\n    HorizontalRule.configure(options?.horizontalRule),\n    CodeBlock.configure(options?.codeBlock),\n    History.configure(options?.history),\n    Dropcursor.configure(options?.dropcursor),\n    Gapcursor,\n  ]\n}\n"],"names":["findDiffStart","a","b","pos","let","i","childCount","childA","child","childB","sameMarkup","isText","text","j","content","size","inner","nodeSize","findDiffEnd","posA","posB","iA","iB","same","minSize","Math","min","length","Fragment","this","nodesBetween","from","to","f","nodeStart","parent","end","start","max","descendants","textBetween","blockSeparator","leafText","separated","node","slice","isLeaf","isBlock","append","other","last","lastChild","first","firstChild","withText","push","cut","result","cutByIndex","empty","replaceChild","index","current","copy","addToStart","concat","addToEnd","eq","found","RangeError","maybeChild","forEach","p","otherPos","findIndex","round","retIndex","curPos","toString","toStringInner","join","toJSON","map","n","fromJSON","schema","value","Array","isArray","nodeFromJSON","fromArray","array","joined","nodes","attrs","const","offset","compareDeep","Mark","type","ReplaceError","message","err","Error","call","__proto__","prototype","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","obj","name","_","json","marks","create","sameSet","setFrom","none","sort","Object","constructor","Slice","openStart","openEnd","removeRange","offsetTo","indexTo","insertInto","dist","insert","canReplace","replace","$from","$to","depth","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","close","replaceThreeWay","parentOffset","replaceTwoWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","insertAt","fragment","removeBetween","maxOpen","openIsolating","spec","isolating","ResolvedPos","path","resolveDepth","val","doc","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","next","sharedDepth","blockRange","pred","d","inlineContent","NodeRange","sameParent","str","resolve","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","emptyAttrs","Node","startPos","textContent","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","isTextblock","isAtom","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","m","markFromJSON","nodeType","ContentMatch","wrapCache","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","indexOf","state","cmp","dfa","connect","compile","edge","edges","exprs","reduce","loop","cur","work","dead","hasRequiredAttrs","checkForDeadEnds","frag","defaultType","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","active","via","shift","reverse","edgeCount","scan","inline","tokens","split","pop","parseExprSeq","eat","parseExprSubscript","test","typeName","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","undefined","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","atom","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","hasOwnProperty","MarkType","excluded","instance","DOMParser","rules","tags","styles","rule","tag","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","prop","charCodeAt","schemaRules","priority","splice","parseDOM","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","parser","open","isOpen","topContext","topOptions","topMatch","topNodeType","find","findPositions","needsBlock","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","prototypeAccessors","top","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","nodeName","insertNode","findInText","findInside","matchAfter","ruleID","toLowerCase","prevItem","nextSibling","appendChild","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","ok","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","toDOM","document","window","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNode","renderSpec","onContent","serializeNodeAndMarks","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","factor16","pow","recoverIndex","MapResult","deleted","recover","StepMap","ranges","inverted","diff","recoverOffset","mapResult","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","JSON","stringify","Mapping","maps","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","mapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","Transform","steps","docs","mustOverride","step","maybeStep","failed","apply","addStep","docChanged","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","jsonID","id","stepClass","StepResult","fail","fromReplace","e","ReplaceStep","super","contentBetween","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","canCut","liftTarget","range","withAttrs","canSplit","typesAfter","$pos","base","innerType","rest","baseType","canJoin","dropPoint","pass","bias","insertPos","fits","wrapping","mapFragment","mapped","lift","gapStart","gapEnd","splitting","wrappers","setBlockType","mapFrom","canChangeType","clearIncompatible","startM","endM","setNodeMarkup","newNode","replaceWith","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","fitsTrivially","addMark","removed","added","removing","adding","newSet","s","removeMark","matched","toRemove","parentType","delSteps","allowed","Fitter","fit","replaceStep","delete","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","move","replaceRange","deleteRange","targetDepths","preferredTarget","unshift","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","replaceRangeWith","point","insertPoint","covered","classesById","Selection","$anchor","$head","SelectionRange","anchor","tr","lastNode","lastParent","selectionToInsertionEnd","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","AllSelection","atStart","atEnd","cls","selectionClass","getBookmark","between","visible","prototypeAccessors$1","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","NodeBookmark","isSelectable","selectable","sel","selection","setSelection","AllBookmark","startLen","_from","_to","_newFrom","newTo","Transaction","time","Date","now","curSelection","curSelectionFor","storedMarks","updated","meta","selectionSet","setStoredMarks","addStoredMark","removeStoredMark","storedMarksSet","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","setMeta","key","getMeta","isGeneric","scrollIntoView","scrolledIntoView","bind","self","FieldDesc","desc","init","baseFields","config","_marks","_old","prev","Configuration","plugins","fields","pluginsByKey","plugin","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","Plugin","props","createKey","getState","keys","PluginKey","get","DropCursorView","editorView","width","color","class","cursorPos","element","timeout","handlers","handler","addEventListener","destroy","removeEventListener","update","prevState","updateOverlay","setCursor","parentNode","removeChild","rect","nodeRect","nodeDOM","getBoundingClientRect","bottom","left","right","coords","coordsAtPos","parentLeft","parentTop","offsetParent","className","cssText","body","getComputedStyle","position","pageXOffset","pageYOffset","scrollLeft","scrollTop","height","scheduleRemoval","clearTimeout","setTimeout","dragover","event","editable","posAtCoords","clientX","clientY","dragging","dragend","drop","dragleave","relatedTarget","view","8","9","10","12","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","106","107","108","109","110","111","144","145","160","161","162","163","164","165","173","186","187","188","189","190","191","192","219","220","221","222","229","48","49","50","51","52","53","54","55","56","57","chrome","navigator","userAgent","safari","vendor","gecko","mac","platform","ie","brokenModifierNames","String","fromCharCode","code","normalizeKeyName","alt","ctrl","mod","modifiers","altKey","ctrlKey","metaKey","shiftKey","ie_edge","ie_upto10","ie_11up","ie_version","documentMode","gecko_version","chrome_version","ios","maxTouchPoints","android","webkit","documentElement","webkit_version","domIndex","host","reusedRange","textRange","createRange","setEnd","setStart","isEquivalentPosition","off","targetNode","targetOff","scanFor","atomElements","hasBlockDesc","contentEditable","pmViewDesc","selectionCollapsed","domSel","collapsed","isCollapsed","browser","rangeCount","getRangeAt","keyEvent","keyCode","createEvent","initEvent","windowRect","clientWidth","clientHeight","getSide","side","clientRect","scaleX","offsetWidth","scaleY","offsetHeight","scrollRectIntoView","startDOM","scrollThreshold","someProp","scrollMargin","atTop","bounding","moveX","moveY","defaultView","scrollBy","startX","startY","dX","dY","scrollStack","stack","restoreScrollStack","dTop","preventScrollSupported","findOffsetInNode","closest","coordsClosest","dxClosest","rowBot","rowTop","childIndex","rects","getClientRects","dx","len","singleRect","inRect","findOffsetInText","elementFromPoint","box","startI","floor","root","caretPositionFromPoint","caretRangeFromPoint","elt","draggable","targetKludge","outside","docView","nearestDesc","posBefore","posAfter","posFromDOM","posFromCaret","posFromElement","inside","posAtStart","border","BIDI","domFromPos","supportEmptyRange","takeSide","flattenV","rectBefore","rectAfter","flattenH","x","y","withFlushedState","viewState","activeElement","updateState","focus","maybeRTL","cachedState","cachedDir","cachedResult","endOfTextblock","nearest","boxes","endOfTextblockVertical","getSelection","modify","oldRange","oldNode","focusNode","oldOff","focusOffset","oldBidiLevel","caretBidiLevel","domAfterPos","removeAllRanges","endOfTextblockHorizontal","ViewDesc","children","dirty","matchesWidget","matchesMark","matchesNode","matchesHack","beforePosition","parseRule","stopEvent","posBeforeChild","posAtEnd","localPosFromDOM","domBefore","domAfter","onlyNodes","getDesc","descAt","domAtom","parseRange","fromOffset","toOffset","childBase","emptyChildAt","force","anchorDOM","headDOM","brKludge","anchorNode","anchorOffset","domSelExtended","extend","collapse","DOMException","ignoreMutation","mutation","contentLost","markDirty","startInside","endInside","markParentsDirty","nothing","WidgetViewDesc","widget","raw","classList","stop","ignoreSelection","CompositionViewDesc","textDOM","prototypeAccessors$2","mut","oldValue","MarkViewDesc","custom","nodeViews","replaceNodes","NodeViewDesc","outerDeco","innerDeco","updateChildren","descObj","hasAttribute","applyOuterDeco","CustomNodeViewDesc","TextViewDesc","reparseInView","sameOuterDeco","prototypeAccessors$3","composition","composing","localCompositionNode","updater","ViewTreeUpdater","deco","onWidget","onNode","locals","forChild","decoIndex","restNode","parentIndex","widgets","compareSide","cutAt","filter","iterDeco","insideNode","syncToMarks","placeWidget","findNodeMatch","updateNextNode","addTextblockHacks","destroyRest","changed","protectLocalComposition","renderDescs","oldCSS","listStyle","iosHacks","nearbyTextNode","textPos","childStart","findTextInFragment","compositionNodes","updateInner","updateOuterDeco","needsWrap","oldDOM","patchOuterDeco","computeOuterDeco","selectNode","deselectNode","remove","removeAttribute","docViewDesc","pmIsDeco","inParent","trackWrites","parentDOM","prototypeAccessors$4","BRHackViewDesc","prototypeAccessors$5","descs","written","childDOM","rm","insertBefore","OuterDecoLevel","noDeco","outerDOM","prevComputed","curComputed","curDOM","patchAttributes","prevList","Boolean","curList","removeProperty","lockedNode","lock","preMatch","fI","dI","Map","selectionFromDOM","origin","inWidget","isOnEdge","selectionBetween","editorOwnsSelection","hasFocus","hasSelection","selectionToDOM","syncNodeSelection","domObserver","disconnectSelection","cursorWrapper","img","disabled","selectCursorWrapper","resetEditableFrom","resetEditableTo","brokenSelectBetweenUneditable","temporarilyEditableNear","resetEditable","hideSelectionGuard","removeClassOnSelectionChange","setCurSelection","connectSelection","destroyBetween","maxKeep","markDesc","has","nextDOM","setEditable","wasDraggable","lastSelectedViewDesc","clearNodeSelection","moveSelectionBlock","$side","dispatch","selectHorizontally","mods","nodePos","nodeLen","isIgnorable","skipIgnoredNodesLeft","moveNode","moveOffset","isBlockNode","setSelFocus","skipIgnoredNodesRight","selectVertically","beyond","stopNativeHorizontalDelete","nextNode","switchEditable","captureKeyDown","getMods","safariDownArrowBug","readDOMChange","typeOver","addedNodes","lastSelectionTime","lastSelectionOrigin","newSel","shared","from_","to_","lastKeyCode","startDoc","editableContent","parseBetween","preferredPos","preferredSide","compare","lastKeyCodeTime","change","endA","endB","findDiff","lastIOSEnter","resolveSelection","domChangeCount","nextSel","inlineChange","old","$newStart","$newEnd","skipClosingAndOpening","$next","looksLikeJoin","suppressSelectionUpdates","toB","lastAndroidDelete","markChange","$from1","chFrom","chTo","curMarks","prevMarks","isMarkChange","parsedSel","fromEnd","mayOpen","serializeForClipboard","serializer","detachedDoc","wrapMap","wrapper","parseFromClipboard","html","plainText","inCode","asText","parsed","metas","firstTag","innerHTML","readHTML","contextNode","sliceData","addContext","closeRange","closeSlice","lastWrap","inLast","addToSibling","closeRight","wrapped","withWrappers","normalizeSiblings","sibling","thead","tbody","caption","colgroup","col","td","th","_detachedDoc","implementation","createHTMLDocument","observeOptions","childList","characterData","characterDataOldValue","attributes","attributeOldValue","subtree","useCharData","SelectionState","DOMObserver","handleDOMChange","queue","flushingSoon","observer","MutationObserver","mutations","removedNodes","flushSoon","flush","currentSelection","onCharData","prevValue","onSelectionChange","suppressingSelectionUpdates","forceFlush","observe","take","takeRecords","disconnect","ignoreSelectionChange","container","commonAncestorContainer","registerMutation","brs","cssChecked","whiteSpace","console","checkCSS","attributeName","editHandlers","setSelectionOrigin","ensureListeners","currentHandlers","eventHandlers","runCustomHandler","defaultPrevented","eventCoords","runHandlerOnContext","propName","updateSelection","focused","handleSingleClick","selectedNode","selectAt","selectClickedNode","selectClickedLeaf","handleDoubleClick","handleTripleClick","defaultTripleClick","forceDOMFlush","endComposition","keydown","inOrNearComposition","preventDefault","lastIOSEnterFallbackTimeout","keyup","keypress","charCode","selectNodeModifier","mousedown","flushed","lastClick","click","dy","isNear","mouseDown","MouseDown","targetPos","allowDefault","mightDrag","targetDesc","addAttr","setUneditable","up","abs","timeStamp","compositionEndedAt","done","touchdown","contextmenu","timeoutComposition","scheduleComposeEnd","delay","composingTimeout","clearComposition","forceUpdate","compositionstart","compositionupdate","markCursor","compositionend","brokenClipboardAPI","doPaste","singleNode","sliceSingleNode","data","clipboardData","clearData","setData","selectNodeContents","blur","captureCopy","paste","getData","capturePaste","Dragging","dragCopyModifier","dragstart","dataTransfer","dragenter","eventPos","$mouse","isNode","beforeInsert","beforeinput","inputType","compareObjs","WidgetType","noSpec","span","oldOffset","Decoration","valid","InlineType","inclusiveStart","inclusiveEnd","is","DecorationSet","local","decorations","buildTree","predicate","findInner","childOff","mapInner","newLocal","onRemove","oldChildren","oldEnd","newEnd","dSize","mustRebuild","fromLocal","toLocal","childNode","childOffset","gather","mapAndGatherRemainingDecorations","byPos","mapChildren","addInner","baseOffset","takeSpansForNode","moveSpans","withoutNulls","removeInner","dec","localSet","DecorationGroup","removeOverlap","localsInner","members","spans","hasNulls","localStart","working","insertAhead","viewDecorations","sorted","EditorView","place","_props","_root","mount","mounted","getEditable","updateCursorWrapper","buildNodeViews","computeDocDeco","bubbles","eventBelongsToView","initInput","pluginViews","updatePluginViews","contenteditable","handleDOMEvents","updateStateInner","setProps","reconfigured","redraw","updateSel","nA","nB","changedNodeViews","scroll","scrollToSelection","updateDoc","sel1","sel2","newRefTop","oldScrollPos","overflowAnchor","refDOM","refTop","innerHeight","localRect","storeScrollPos","forceSelUpdate","chromeKludge","destroyPluginViews","pluginView","setActive","stored","preventScroll","focusPreventScroll","getPrototypeOf","domAtPos","posAtDOM","destroyInput","dispatchEvent","dispatchTransaction","GapCursor","GapBookmark","closedBefore","closedAfter","override","allowGapCursor","mustMove","$cur","bindings","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","normalize","baseName","keyName","isChar","direct","fromCode","withShift","axis","dirStr","$found","handleClick","drawGapCursor","createSelectionBetween","_view","Text","GOOD_LEAF_SIZE","RopeSequence","leafAppend","leafPrepend","appendInner","prepend","Append","sliceInner","getInner","forEachInner","forEachInvertedInner","values","Leaf","configurable","flatten","defineProperties","leftLen","ropeSequence","Branch","items","eventCount","popEvent","preserveItems","remap","remapping","remaining","transform","addAfter","addBefore","item","Item","addTransform","histOptions","newItems","oldItems","lastItem","merged","cutPoint","overflow","DEPTH_OVERFLOW","mirrorPos","mirrorOffset","addMaps","rebased","rebasedTransform","rebasedCount","rebasedItems","newUntil","iRebased","newMaps","branch","emptyItemCount","compress","events","newItem","HistoryState","undone","prevRanges","prevTime","rangesFor","mapRanges","histTransaction","history","redo","mustPreserveItems","historyKey","newHist","historyState","cachedPreserveItems","cachedPreserveItemsPlugins","historyPreserveItems","closeHistoryKey","newGroupDelay","hist","historyTr","appended","newGroup","adjacent","isAdjacentTo","underscoreInputRegex","Bold","starPasteRegex","InputRule","cutOff","wrappingInputRule","regexp","joinPredicate","innerRange","around","outer","findWrappingOutside","innerMatch","findWrappingInside","textblockTypeInputRule","classAttribute","language","textblockAt","findCutBefore","findCutAfter","defaultBlockAt","exitCode","above","deleteBarrier","$cut","conn","joinMaybeClear","canDelAfter","joinAt","selAfter","at","chainCommands","commands","can","os","Strike","HTMLAttributes","OrderedList","Document","Paragraph","configure","paragraph","bold","Italic","italic","Code","strike","HardBreak","hardBreak","Heading","heading","Blockquote","BulletList","bulletList","orderedList","ListItem","listItem","HorizontalRule","horizontalRule","CodeBlock","codeBlock","History","Dropcursor","dropcursor","Gapcursor"],"mappings":"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"}