{"version":3,"file":"tiptap-extension-history.bundle.umd.min.js","sources":["../../../node_modules/rope-sequence/dist/index.es.js","../../../node_modules/prosemirror-model/src/diff.js","../../../node_modules/prosemirror-model/src/fragment.js","../../../node_modules/prosemirror-model/src/comparedeep.js","../../../node_modules/prosemirror-model/src/mark.js","../../../node_modules/prosemirror-model/src/replace.js","../../../node_modules/prosemirror-model/src/resolvedpos.js","../../../node_modules/prosemirror-model/src/node.js","../../../node_modules/prosemirror-model/src/content.js","../../../node_modules/prosemirror-model/src/schema.js","../../../node_modules/prosemirror-model/src/from_dom.js","../../../node_modules/prosemirror-model/src/to_dom.js","../../../node_modules/prosemirror-transform/src/map.js","../../../node_modules/prosemirror-transform/src/transform.js","../../../node_modules/prosemirror-transform/src/step.js","../../../node_modules/prosemirror-transform/src/replace_step.js","../../../node_modules/prosemirror-transform/src/mark_step.js","../../../node_modules/prosemirror-transform/src/structure.js","../../../node_modules/prosemirror-transform/src/replace.js","../../../node_modules/prosemirror-transform/src/mark.js","../../../node_modules/prosemirror-state/src/selection.js","../../../node_modules/prosemirror-state/src/transaction.js","../../../node_modules/prosemirror-state/src/state.js","../../../node_modules/prosemirror-state/src/plugin.js","../../../node_modules/prosemirror-history/src/history.js","../src/history.ts"],"sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n","export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?string) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?string) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted whenever a new\n  // block node is started. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNode(node, options))\n    })\n\n    return target\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  serializeNodeAndMarks(node, options = {}) {\n    let dom = this.serializeNode(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d)) result.push(d)\n  }\n  return result\n}\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\nimport {ReplaceStep, ReplaceAroundStep} from \"prosemirror-transform\"\n\nconst classesById = Object.create(null)\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nexport class Selection {\n  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])\n  // Initialize a selection with the head and anchor and ranges. If no\n  // ranges are given, constructs a single range across `$anchor` and\n  // `$head`.\n  constructor($anchor, $head, ranges) {\n    // :: [SelectionRange]\n    // The ranges covered by the selection.\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))]\n    // :: ResolvedPos\n    // The resolved anchor of the selection (the side that stays in\n    // place when the selection is modified).\n    this.$anchor = $anchor\n    // :: ResolvedPos\n    // The resolved head of the selection (the side that moves when\n    // the selection is modified).\n    this.$head = $head\n  }\n\n  // :: number\n  // The selection's anchor, as an unresolved position.\n  get anchor() { return this.$anchor.pos }\n\n  // :: number\n  // The selection's head.\n  get head() { return this.$head.pos }\n\n  // :: number\n  // The lower bound of the selection's main range.\n  get from() { return this.$from.pos }\n\n  // :: number\n  // The upper bound of the selection's main range.\n  get to() { return this.$to.pos }\n\n  // :: ResolvedPos\n  // The resolved lower  bound of the selection's main range.\n  get $from() {\n    return this.ranges[0].$from\n  }\n\n  // :: ResolvedPos\n  // The resolved upper bound of the selection's main range.\n  get $to() {\n    return this.ranges[0].$to\n  }\n\n  // :: bool\n  // Indicates whether the selection contains any content.\n  get empty() {\n    let ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos) return false\n    return true\n  }\n\n  // eq:: (Selection) → bool\n  // Test whether the selection is the same as another selection.\n\n  // map:: (doc: Node, mapping: Mappable) → Selection\n  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n  // should be the new document to which we are mapping.\n\n  // :: () → Slice\n  // Get the content of this selection as a slice.\n  content() {\n    return this.$from.node(0).slice(this.from, this.to, true)\n  }\n\n  // :: (Transaction, ?Slice)\n  // Replace the selection with a slice or, if no slice is given,\n  // delete the selection. Will append to the given transaction.\n  replace(tr, content = Slice.empty) {\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild, lastParent = null\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    }\n  }\n\n  // :: (Transaction, Node)\n  // Replace the selection with the given node, appending the changes\n  // to the given transaction.\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      let from = mapping.map($from.pos), to = mapping.map($to.pos)\n      if (i) {\n        tr.deleteRange(from, to)\n      } else {\n        tr.replaceRangeWith(from, to, node)\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)\n      }\n    }\n  }\n\n  // toJSON:: () → Object\n  // Convert the selection to a JSON representation. When implementing\n  // this for a custom selection class, make sure to give the object a\n  // `type` property whose value matches the ID under which you\n  // [registered](#state.Selection^jsonID) your class.\n\n  // :: (ResolvedPos, number, ?bool) → ?Selection\n  // Find a valid cursor or leaf node selection starting at the given\n  // position and searching back if `dir` is negative, and forward if\n  // positive. When `textOnly` is true, only consider cursor\n  // selections. Will return null when no valid selection position is\n  // found.\n  static findFrom($pos, dir, textOnly) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n    if (inner) return inner\n\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0\n          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n      if (found) return found\n    }\n  }\n\n  // :: (ResolvedPos, ?number) → Selection\n  // Find a valid cursor or leaf node selection near the given\n  // position. Searches forward first by default, but if `bias` is\n  // negative, it will search backwards first.\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the start of\n  // the given document. Will return an\n  // [`AllSelection`](#state.AllSelection) if no valid position\n  // exists.\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the end of the\n  // given document.\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n  }\n\n  // :: (Node, Object) → Selection\n  // Deserialize the JSON representation of a selection. Must be\n  // implemented for custom classes (as a static class method).\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\")\n    let cls = classesById[json.type]\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)\n    return cls.fromJSON(doc, json)\n  }\n\n  // :: (string, constructor<Selection>)\n  // To be able to deserialize selections from JSON, custom selection\n  // classes must register themselves with an ID string, so that they\n  // can be disambiguated. Try to pick something that's unlikely to\n  // clash with classes from other modules.\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id)\n    classesById[id] = selectionClass\n    selectionClass.prototype.jsonID = id\n    return selectionClass\n  }\n\n  // :: () → SelectionBookmark\n  // Get a [bookmark](#state.SelectionBookmark) for this selection,\n  // which is a value that can be mapped without having access to a\n  // current document, and later resolved to a real selection for a\n  // given document again. (This is used mostly by the history to\n  // track and restore old selections.) The default implementation of\n  // this method just converts the selection to a text selection and\n  // returns the bookmark for that.\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark()\n  }\n}\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nexport class SelectionRange {\n  // :: (ResolvedPos, ResolvedPos)\n  constructor($from, $to) {\n    // :: ResolvedPos\n    // The lower bound of the range.\n    this.$from = $from\n    // :: ResolvedPos\n    // The upper bound of the range.\n    this.$to = $to\n  }\n}\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nexport class TextSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // Construct a text selection between the given points.\n  constructor($anchor, $head = $anchor) {\n    super($anchor, $head)\n  }\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }\n\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.inlineContent) return Selection.near($head)\n    let $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  }\n\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content)\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to)\n      if (marks) tr.ensureMarks(marks)\n    }\n  }\n\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  }\n\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head)\n  }\n\n  toJSON() {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\")\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  }\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true)\n      if (found) $head = found.$head\n      else return Selection.near($head, bias)\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor\n        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head\n      }\n    }\n    return new TextSelection($anchor, $head)\n  }\n}\n\nSelection.jsonID(\"text\", TextSelection)\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n  }\n}\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nexport class NodeSelection extends Selection {\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument.\n  constructor($pos) {\n    let node = $pos.nodeAfter\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize)\n    super($pos, $end)\n    // :: Node The selected node.\n    this.node = node\n  }\n\n  map(doc, mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    let $pos = doc.resolve(pos)\n    if (deleted) return Selection.near($pos)\n    return new NodeSelection($pos)\n  }\n\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  }\n\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  }\n\n  toJSON() {\n    return {type: \"node\", anchor: this.anchor}\n  }\n\n  getBookmark() { return new NodeBookmark(this.anchor) }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\")\n    return new NodeSelection(doc.resolve(json.anchor))\n  }\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  static create(doc, from) {\n    return new this(doc.resolve(from))\n  }\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false\n  }\n}\n\nNodeSelection.prototype.visible = false\n\nSelection.jsonID(\"node\", NodeSelection)\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor\n  }\n  map(mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)\n    return Selection.near($pos)\n  }\n}\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nexport class AllSelection extends Selection {\n  // :: (Node)\n  // Create an all-selection over the given document.\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size))\n  }\n\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size)\n      let sel = Selection.atStart(tr.doc)\n      if (!sel.eq(tr.selection)) tr.setSelection(sel)\n    } else {\n      super.replace(tr, content)\n    }\n  }\n\n  toJSON() { return {type: \"all\"} }\n\n  static fromJSON(doc) { return new AllSelection(doc) }\n\n  map(doc) { return new AllSelection(doc) }\n\n  eq(other) { return other instanceof AllSelection }\n\n  getBookmark() { return AllBookmark }\n}\n\nSelection.jsonID(\"all\", AllSelection)\n\nconst AllBookmark = {\n  map() { return this },\n  resolve(doc) { return new AllSelection(doc) }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) return TextSelection.create(doc, pos)\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i)\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) return inner\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1\n  if (last < startLen) return\n  let step = tr.steps[last]\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return\n  let map = tr.mapping.maps[last], end\n  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo })\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {Transform} from \"prosemirror-transform\"\nimport {Mark} from \"prosemirror-model\"\nimport {Selection} from \"./selection\"\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nexport class Transaction extends Transform {\n  constructor(state) {\n    super(state.doc)\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  }\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\")\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  }\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0\n  }\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  setStoredMarks(marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  }\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks)\n    return this\n  }\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0\n  }\n\n  addStep(step, doc) {\n    super.addStep(step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  }\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  setTime(time) {\n    this.time = time\n    return this\n  }\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  replaceSelection(slice) {\n    this.selection.replace(this, slice)\n    return this\n  }\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  replaceSelectionWith(node, inheritMarks) {\n    let selection = this.selection\n    if (inheritMarks !== false)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))\n    selection.replaceWith(this, node)\n    return this\n  }\n\n  // :: () → Transaction\n  // Delete the selection.\n  deleteSelection() {\n    this.selection.replace(this)\n    return this\n  }\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  insertText(text, from, to = from) {\n    let schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) return this.deleteSelection()\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) return this.deleteRange(from, to)\n      let marks = this.storedMarks\n      if (!marks) {\n        let $from = this.doc.resolve(from)\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks))\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))\n      return this\n    }\n  }\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  }\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  }\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  get isGeneric() {\n    for (let _ in this.meta) return false\n    return true\n  }\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL\n    return this\n  }\n\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0\n  }\n}\n","import {Node} from \"prosemirror-model\"\n\nimport {Selection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name\n    this.init = bind(desc.init, self)\n    this.apply = bind(desc.apply, self)\n  }\n}\n\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init(config) { return config.storedMarks || null },\n    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init() { return 0 },\n    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema\n    this.fields = baseFields.concat()\n    this.plugins = []\n    this.pluginsByKey = Object.create(null)\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key])\n        throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\")\n      this.plugins.push(plugin)\n      this.pluginsByKey[plugin.key] = plugin\n      if (plugin.spec.state)\n        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin))\n    })\n  }\n}\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nexport class EditorState {\n  constructor(config) {\n    this.config = config\n  }\n\n  // doc:: Node\n  // The current document.\n\n  // selection:: Selection\n  // The selection.\n\n  // storedMarks:: ?[Mark]\n  // A set of marks to apply to the next input. Will be null when\n  // no explicit marks have been set.\n\n  // :: Schema\n  // The schema of the state's document.\n  get schema() {\n    return this.config.schema\n  }\n\n  // :: [Plugin]\n  // The plugins that are active in this state.\n  get plugins() {\n    return this.config.plugins\n  }\n\n  // :: (Transaction) → EditorState\n  // Apply the given transaction to produce a new state.\n  apply(tr) {\n    return this.applyTransaction(tr).state\n  }\n\n  // : (Transaction) → bool\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i]\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n        return false\n    }\n    return true\n  }\n\n  // :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n  // Verbose variant of [`apply`](#state.EditorState.apply) that\n  // returns the precise transactions that were applied (which might\n  // be influenced by the [transaction\n  // hooks](#state.PluginSpec.filterTransaction) of\n  // plugins) along with the new state.\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}\n\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    outer: for (;;) {\n      let haveNew = false\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i]\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this\n          let tr = n < trs.length &&\n              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr)\n            if (!seen) {\n              seen = []\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0})\n            }\n            trs.push(tr)\n            newState = newState.applyInner(tr)\n            haveNew = true\n          }\n          if (seen) seen[i] = {state: newState, n: trs.length}\n        }\n      }\n      if (!haveNew) return {state: newState, transactions: trs}\n    }\n  }\n\n  // : (Transaction) → EditorState\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\")\n    let newInstance = new EditorState(this.config), fields = this.config.fields\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i]\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance)\n    }\n    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance)\n    return newInstance\n  }\n\n  // :: Transaction\n  // Start a [transaction](#state.Transaction) from this state.\n  get tr() { return new Transaction(this) }\n\n  // :: (Object) → EditorState\n  // Create a new state.\n  //\n  //   config::- Configuration options. Must contain `schema` or `doc` (or both).\n  //\n  //      schema:: ?Schema\n  //      The schema to use (only relevant if no `doc` is specified).\n  //\n  //      doc:: ?Node\n  //      The starting document.\n  //\n  //      selection:: ?Selection\n  //      A valid selection in the document.\n  //\n  //      storedMarks:: ?[Mark]\n  //      The initial set of [stored marks](#state.EditorState.storedMarks).\n  //\n  //      plugins:: ?[Plugin]\n  //      The plugins that should be active in this state.\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins)\n    let instance = new EditorState($config)\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance)\n    return instance\n  }\n\n  // :: (Object) → EditorState\n  // Create a new state based on this one, but with an adjusted set of\n  // active plugins. State fields that exist in both sets of plugins\n  // are kept unchanged. Those that no longer exist are dropped, and\n  // those that are new are initialized using their\n  // [`init`](#state.StateField.init) method, passing in the new\n  // configuration object..\n  //\n  //   config::- configuration options\n  //\n  //     plugins:: [Plugin]\n  //     New set of active plugins.\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins)\n    let fields = $config.fields, instance = new EditorState($config)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance)\n    }\n    return instance\n  }\n\n  // :: (?union<Object<Plugin>, string, number>) → Object\n  // Serialize this state to JSON. If you want to serialize the state\n  // of plugins, pass an object mapping property names to use in the\n  // resulting JSON object to plugin objects. The argument may also be\n  // a string or number, in which case it is ignored, to support the\n  // way `JSON.stringify` calls `toString` methods.\n  toJSON(pluginFields) {\n    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON())\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\")\n        throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\")\n      let plugin = pluginFields[prop], state = plugin.spec.state\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key])\n    }\n    return result\n  }\n\n  // :: (Object, Object, ?Object<Plugin>) → EditorState\n  // Deserialize a JSON representation of a state. `config` should\n  // have at least a `schema` field, and should contain array of\n  // plugins to initialize the state with. `pluginFields` can be used\n  // to deserialize the state of plugins, by associating plugin\n  // instances with the property names they use in the JSON object.\n  //\n  //   config::- configuration options\n  //\n  //     schema:: Schema\n  //     The schema to use.\n  //\n  //     plugins:: ?[Plugin]\n  //     The set of active plugins.\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\")\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\")\n    let $config = new Configuration(config.schema, config.plugins)\n    let instance = new EditorState($config)\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc)\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection)\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON)\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop], state = plugin.spec.state\n          if (plugin.key == field.name && state && state.fromJSON &&\n              Object.prototype.hasOwnProperty.call(json, prop)) {\n            // This field belongs to a plugin mapped to a JSON field, read it from there.\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n            return\n          }\n        }\n        instance[field.name] = field.init(config, instance)\n      }\n    })\n    return instance\n  }\n\n  // Kludge to allow the view to track mappings between different\n  // instances of a state.\n  //\n  // FIXME this is no longer needed as of prosemirror-view 1.9.0,\n  // though due to backwards-compat we should probably keep it around\n  // for a while (if only as a no-op)\n  static addApplyListener(f) {\n    applyListeners.push(f)\n  }\n  static removeApplyListener(f) {\n    let found = applyListeners.indexOf(f)\n    if (found > -1) applyListeners.splice(found, 1)\n  }\n}\n\nconst applyListeners = []\n","// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop]\n    if (val instanceof Function) val = val.bind(self)\n    else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {})\n    target[prop] = val\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nexport class Plugin {\n  // :: (PluginSpec)\n  // Create a plugin.\n  constructor(spec) {\n    // :: EditorProps\n    // The [props](#view.EditorProps) exported by this plugin.\n    this.props = {}\n    if (spec.props) bindProps(spec.props, this, this.props)\n    // :: Object\n    // The plugin's [spec object](#state.PluginSpec).\n    this.spec = spec\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\")\n  }\n\n  // :: (EditorState) → any\n  // Extract the plugin's state field from an editor state.\n  getState(state) { return state[this.key] }\n}\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nconst keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name]\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nexport class PluginKey {\n  // :: (?string)\n  // Create a plugin key.\n  constructor(name = \"key\") { this.key = createKey(name) }\n\n  // :: (EditorState) → ?Plugin\n  // Get the active plugin with this key, if any, from an editor\n  // state.\n  get(state) { return state.config.pluginsByKey[this.key] }\n\n  // :: (EditorState) → ?any\n  // Get the plugin's state from an editor state.\n  getState(state) { return state[this.key] }\n}\n","import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) → Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n","import { Command, Extension } from '@tiptap/core'\nimport { history, undo, redo } from 'prosemirror-history'\n\nexport interface HistoryOptions {\n  depth: number,\n  newGroupDelay: number,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    history: {\n      /**\n       * Undo recent changes\n       */\n      undo: () => Command,\n      /**\n       * Reapply reverted changes\n       */\n      redo: () => Command,\n    }\n  }\n}\n\nexport const History = Extension.create<HistoryOptions>({\n  name: 'history',\n\n  defaultOptions: {\n    depth: 100,\n    newGroupDelay: 500,\n  },\n\n  addCommands() {\n    return {\n      undo: () => ({ state, dispatch }) => {\n        return undo(state, dispatch)\n      },\n      redo: () => ({ state, dispatch }) => {\n        return redo(state, dispatch)\n      },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      history(this.options),\n    ]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Mod-y': () => this.editor.commands.redo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n    }\n  },\n})\n"],"names":["GOOD_LEAF_SIZE","RopeSequence","prototype","append","other","length","from","this","leafAppend","leafPrepend","appendInner","prepend","Append","slice","to","empty","sliceInner","Math","max","min","get","i","getInner","forEach","f","forEachInner","forEachInvertedInner","map","result","elt","push","values","Leaf","call","__proto__","Object","create","constructor","prototypeAccessors","configurable","depth","flatten","start","concat","defineProperties","left","right","leftLen","inner","ropeSequence","findDiffStart","a","b","pos","let","childCount","childA","child","childB","sameMarkup","isText","text","j","content","size","nodeSize","findDiffEnd","posA","posB","iA","iB","same","minSize","Fragment","nodesBetween","nodeStart","parent","end","descendants","textBetween","blockSeparator","leafText","separated","node","isLeaf","isBlock","last","lastChild","first","firstChild","withText","cut","cutByIndex","replaceChild","index","current","copy","addToStart","addToEnd","eq","found","RangeError","maybeChild","p","otherPos","findIndex","round","retIndex","curPos","toString","toStringInner","join","toJSON","n","fromJSON","schema","value","Array","isArray","nodeFromJSON","fromArray","array","joined","nodes","attrs","const","offset","compareDeep","Mark","type","ReplaceError","message","err","Error","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","obj","name","_","json","marks","sameSet","setFrom","none","sort","Slice","openStart","openEnd","removeRange","offsetTo","indexTo","insertInto","dist","insert","canReplace","replace","$from","$to","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","close","replaceThreeWay","parentOffset","replaceTwoWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","insertAt","fragment","removeBetween","maxOpen","openIsolating","spec","isolating","ResolvedPos","path","resolveDepth","val","doc","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","next","sharedDepth","blockRange","pred","d","inlineContent","NodeRange","sameParent","str","resolve","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","emptyAttrs","Node","startPos","textContent","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","isTextblock","isAtom","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","m","markFromJSON","nodeType","ContentMatch","wrapCache","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","indexOf","state","cmp","dfa","connect","compile","edge","edges","exprs","reduce","loop","cur","work","dead","hasRequiredAttrs","checkForDeadEnds","frag","defaultType","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","active","via","shift","reverse","edgeCount","scan","inline","tokens","split","pop","parseExprSeq","eat","parseExprSubscript","test","typeName","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","undefined","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","atom","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","hasOwnProperty","prototypeAccessors$1","MarkType","excluded","instance","DOMParser","rules","tags","styles","rule","tag","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","prop","charCodeAt","schemaRules","priority","splice","parseDOM","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","parser","open","isOpen","topContext","topOptions","topMatch","topNodeType","find","findPositions","needsBlock","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","top","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","nodeName","insertNode","findInText","findInside","matchAfter","ruleID","toLowerCase","prevItem","nextSibling","appendChild","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","ok","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","toDOM","document","window","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNode","renderSpec","onContent","serializeNodeAndMarks","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","factor16","pow","recoverIndex","MapResult","deleted","recover","StepMap","ranges","inverted","diff","recoverOffset","mapResult","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","JSON","stringify","Mapping","maps","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","mapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","Transform","steps","docs","mustOverride","step","maybeStep","failed","apply","addStep","docChanged","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","jsonID","id","stepClass","StepResult","fail","fromReplace","e","ReplaceStep","super","contentBetween","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","mapFragment","mapped","lift","range","gapStart","gapEnd","splitting","wrappers","setBlockType","mapFrom","$pos","canChangeType","clearIncompatible","startM","endM","setNodeMarkup","newNode","replaceWith","typesAfter","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","fitsTrivially","addMark","removed","added","removing","adding","newSet","s","removeMark","matched","toRemove","parentType","delSteps","allowed","Fitter","fit","replaceStep","delete","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","pass","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","move","replaceRange","deleteRange","targetDepths","preferredTarget","unshift","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","replaceRangeWith","point","insertPoint","covered","classesById","Selection","$anchor","$head","SelectionRange","anchor","tr","lastNode","lastParent","selectionToInsertionEnd","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","bias","AllSelection","atStart","atEnd","cls","selectionClass","getBookmark","between","visible","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","NodeBookmark","isSelectable","selectable","sel","selection","setSelection","AllBookmark","startLen","_from","_to","_newFrom","newTo","Transaction","time","Date","now","curSelection","curSelectionFor","storedMarks","updated","meta","selectionSet","setStoredMarks","addStoredMark","removeStoredMark","storedMarksSet","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","setMeta","key","getMeta","isGeneric","scrollIntoView","scrolledIntoView","bind","self","FieldDesc","desc","init","baseFields","config","_marks","_old","prev","Configuration","plugins","fields","pluginsByKey","plugin","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","Plugin","props","createKey","getState","keys","PluginKey","Branch","items","eventCount","popEvent","preserveItems","remap","remapping","remaining","transform","addAfter","addBefore","item","Item","addTransform","histOptions","newItems","oldItems","lastItem","merged","cutPoint","overflow","DEPTH_OVERFLOW","mirrorPos","mirrorOffset","addMaps","rebased","rebasedTransform","rebasedCount","rebasedItems","newUntil","iRebased","newMaps","branch","emptyItemCount","compress","events","newItem","HistoryState","done","undone","prevRanges","prevTime","rangesFor","mapRanges","histTransaction","history","dispatch","redo","mustPreserveItems","historyKey","newHist","historyState","cachedPreserveItems","cachedPreserveItemsPlugins","historyPreserveItems","closeHistoryKey","newGroupDelay","hist","historyTr","appended","newGroup","adjacent","isAdjacentTo","History","Extension","defaultOptions","addCommands","undo","[object Object]","Mod-z","editor","commands","Mod-y","Shift-Mod-z"],"mappings":"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"}