{"version":3,"file":"tiptap-core.bundle.umd.min.js","sources":["../../../node_modules/orderedmap/index.es.js","../../../node_modules/prosemirror-model/src/diff.js","../../../node_modules/prosemirror-model/src/fragment.js","../../../node_modules/prosemirror-model/src/comparedeep.js","../../../node_modules/prosemirror-model/src/mark.js","../../../node_modules/prosemirror-model/src/replace.js","../../../node_modules/prosemirror-model/src/resolvedpos.js","../../../node_modules/prosemirror-model/src/node.js","../../../node_modules/prosemirror-model/src/content.js","../../../node_modules/prosemirror-model/src/schema.js","../../../node_modules/prosemirror-model/src/from_dom.js","../../../node_modules/prosemirror-model/src/to_dom.js","../../../node_modules/prosemirror-transform/src/map.js","../../../node_modules/prosemirror-transform/src/transform.js","../../../node_modules/prosemirror-transform/src/step.js","../../../node_modules/prosemirror-transform/src/replace_step.js","../../../node_modules/prosemirror-transform/src/structure.js","../../../node_modules/prosemirror-transform/src/mark_step.js","../../../node_modules/prosemirror-transform/src/replace.js","../../../node_modules/prosemirror-transform/src/mark.js","../../../node_modules/prosemirror-state/src/selection.js","../../../node_modules/prosemirror-state/src/transaction.js","../../../node_modules/prosemirror-state/src/state.js","../../../node_modules/prosemirror-state/src/plugin.js","../../../node_modules/prosemirror-view/src/browser.js","../../../node_modules/prosemirror-view/src/dom.js","../../../node_modules/prosemirror-view/src/domcoords.js","../../../node_modules/prosemirror-view/src/viewdesc.js","../../../node_modules/prosemirror-view/src/selection.js","../../../node_modules/prosemirror-view/src/capturekeys.js","../../../node_modules/prosemirror-view/src/domchange.js","../../../node_modules/prosemirror-view/src/clipboard.js","../../../node_modules/prosemirror-view/src/domobserver.js","../../../node_modules/prosemirror-view/src/input.js","../../../node_modules/prosemirror-view/src/decoration.js","../../../node_modules/prosemirror-view/src/index.js","../src/helpers/getNodeType.ts","../src/helpers/getMarkType.ts","../src/helpers/getMarkAttributes.ts","../src/utilities/objectIncludes.ts","../src/helpers/isNodeActive.ts","../src/helpers/isMarkActive.ts","../src/helpers/getSchemaTypeNameByName.ts","../src/helpers/isActive.ts","../src/utilities/elementFromString.ts","../src/helpers/createNodeFromContent.ts","../src/helpers/createDocument.ts","../src/helpers/getHTMLFromFragment.ts","../src/helpers/isNodeEmpty.ts","../src/CommandManager.ts","../../../node_modules/w3c-keyname/index.es.js","../../../node_modules/prosemirror-keymap/src/keymap.js","../../../node_modules/prosemirror-inputrules/src/inputrules.js","../src/helpers/getExtensionField.ts","../src/helpers/splitExtensions.ts","../src/helpers/getAttributesFromExtensions.ts","../src/utilities/mergeAttributes.ts","../src/helpers/getRenderedAttributes.ts","../src/helpers/injectExtensionAttributesToParseRule.ts","../src/utilities/fromString.ts","../src/utilities/callOrReturn.ts","../src/helpers/getSchema.ts","../src/utilities/isEmptyObject.ts","../src/helpers/getSchemaTypeByName.ts","../src/ExtensionManager.ts","../src/utilities/isPlainObject.ts","../src/utilities/mergeDeep.ts","../src/Extension.ts","../src/extensions/clipboardTextSerializer.ts","../src/commands/blur.ts","../src/commands/clearContent.ts","../src/commands/clearNodes.ts","../src/commands/command.ts","../../../node_modules/prosemirror-commands/src/commands.js","../src/commands/createParagraphNear.ts","../src/commands/deleteRange.ts","../src/commands/deleteSelection.ts","../src/commands/enter.ts","../src/commands/exitCode.ts","../src/helpers/getMarkRange.ts","../src/commands/extendMarkRange.ts","../src/commands/first.ts","../src/utilities/minMax.ts","../src/utilities/isObject.ts","../src/utilities/isClass.ts","../src/helpers/isTextSelection.ts","../src/commands/focus.ts","../src/helpers/selectionToInsertionEnd.ts","../src/commands/insertContent.ts","../src/commands/insertHTML.ts","../src/commands/insertNode.ts","../src/commands/insertText.ts","../src/commands/joinBackward.ts","../src/commands/joinForward.ts","../src/commands/keyboardShortcut.ts","../src/commands/lift.ts","../src/commands/liftEmptyBlock.ts","../../../node_modules/prosemirror-schema-list/src/schema-list.js","../src/commands/liftListItem.ts","../src/commands/newlineInCode.ts","../src/commands/replace.ts","../src/commands/replaceRange.ts","../src/utilities/deleteProps.ts","../src/commands/resetAttributes.ts","../src/commands/resetNodeAttributes.ts","../src/commands/scrollIntoView.ts","../src/commands/selectAll.ts","../src/commands/selectNodeBackward.ts","../src/commands/selectNodeForward.ts","../src/commands/selectParentNode.ts","../src/commands/setContent.ts","../src/commands/setMark.ts","../src/commands/setNode.ts","../src/commands/sinkListItem.ts","../src/helpers/getSplittedAttributes.ts","../src/commands/splitBlock.ts","../src/commands/splitListItem.ts","../src/helpers/findParentNodeClosestToPos.ts","../src/helpers/findParentNode.ts","../src/helpers/isList.ts","../src/commands/toggleList.ts","../src/commands/toggleMark.ts","../src/commands/toggleNode.ts","../src/commands/toggleWrap.ts","../src/commands/undoInputRule.ts","../src/commands/unsetAllMarks.ts","../src/commands/unsetMark.ts","../src/commands/updateAttributes.ts","../src/commands/updateNodeAttributes.ts","../src/commands/wrapIn.ts","../src/commands/wrapInList.ts","../src/extensions/commands.ts","../src/extensions/editable.ts","../src/extensions/focusEvents.ts","../src/extensions/keymap.ts","../src/Node.ts","../src/Mark.ts","../src/helpers/coordsAtPos.ts","../src/EventEmitter.ts","../src/Editor.ts","../src/utilities/createStyleTag.ts","../src/style.ts","../src/helpers/getNodeAttributes.ts","../src/utilities/removeElement.ts","../src/NodeView.ts","../src/helpers/findChildren.ts","../src/helpers/generateHTML.ts","../src/helpers/isNodeSelection.ts","../src/inputRules/markInputRule.ts","../src/helpers/getMarksBetween.ts","../src/pasteRules/markPasteRule.ts","../src/inputRules/nodeInputRule.ts","../src/helpers/posToDOMRect.ts"],"sourcesContent":["// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?string) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?string) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted whenever a new\n  // block node is started. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNode(node, options))\n    })\n\n    return target\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  serializeNodeAndMarks(node, options = {}) {\n    let dom = this.serializeNode(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d)) result.push(d)\n  }\n  return result\n}\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\nimport {ReplaceStep, ReplaceAroundStep} from \"prosemirror-transform\"\n\nconst classesById = Object.create(null)\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nexport class Selection {\n  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])\n  // Initialize a selection with the head and anchor and ranges. If no\n  // ranges are given, constructs a single range across `$anchor` and\n  // `$head`.\n  constructor($anchor, $head, ranges) {\n    // :: [SelectionRange]\n    // The ranges covered by the selection.\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))]\n    // :: ResolvedPos\n    // The resolved anchor of the selection (the side that stays in\n    // place when the selection is modified).\n    this.$anchor = $anchor\n    // :: ResolvedPos\n    // The resolved head of the selection (the side that moves when\n    // the selection is modified).\n    this.$head = $head\n  }\n\n  // :: number\n  // The selection's anchor, as an unresolved position.\n  get anchor() { return this.$anchor.pos }\n\n  // :: number\n  // The selection's head.\n  get head() { return this.$head.pos }\n\n  // :: number\n  // The lower bound of the selection's main range.\n  get from() { return this.$from.pos }\n\n  // :: number\n  // The upper bound of the selection's main range.\n  get to() { return this.$to.pos }\n\n  // :: ResolvedPos\n  // The resolved lower  bound of the selection's main range.\n  get $from() {\n    return this.ranges[0].$from\n  }\n\n  // :: ResolvedPos\n  // The resolved upper bound of the selection's main range.\n  get $to() {\n    return this.ranges[0].$to\n  }\n\n  // :: bool\n  // Indicates whether the selection contains any content.\n  get empty() {\n    let ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos) return false\n    return true\n  }\n\n  // eq:: (Selection) → bool\n  // Test whether the selection is the same as another selection.\n\n  // map:: (doc: Node, mapping: Mappable) → Selection\n  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n  // should be the new document to which we are mapping.\n\n  // :: () → Slice\n  // Get the content of this selection as a slice.\n  content() {\n    return this.$from.node(0).slice(this.from, this.to, true)\n  }\n\n  // :: (Transaction, ?Slice)\n  // Replace the selection with a slice or, if no slice is given,\n  // delete the selection. Will append to the given transaction.\n  replace(tr, content = Slice.empty) {\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild, lastParent = null\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    }\n  }\n\n  // :: (Transaction, Node)\n  // Replace the selection with the given node, appending the changes\n  // to the given transaction.\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      let from = mapping.map($from.pos), to = mapping.map($to.pos)\n      if (i) {\n        tr.deleteRange(from, to)\n      } else {\n        tr.replaceRangeWith(from, to, node)\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)\n      }\n    }\n  }\n\n  // toJSON:: () → Object\n  // Convert the selection to a JSON representation. When implementing\n  // this for a custom selection class, make sure to give the object a\n  // `type` property whose value matches the ID under which you\n  // [registered](#state.Selection^jsonID) your class.\n\n  // :: (ResolvedPos, number, ?bool) → ?Selection\n  // Find a valid cursor or leaf node selection starting at the given\n  // position and searching back if `dir` is negative, and forward if\n  // positive. When `textOnly` is true, only consider cursor\n  // selections. Will return null when no valid selection position is\n  // found.\n  static findFrom($pos, dir, textOnly) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n    if (inner) return inner\n\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0\n          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n      if (found) return found\n    }\n  }\n\n  // :: (ResolvedPos, ?number) → Selection\n  // Find a valid cursor or leaf node selection near the given\n  // position. Searches forward first by default, but if `bias` is\n  // negative, it will search backwards first.\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the start of\n  // the given document. Will return an\n  // [`AllSelection`](#state.AllSelection) if no valid position\n  // exists.\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the end of the\n  // given document.\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n  }\n\n  // :: (Node, Object) → Selection\n  // Deserialize the JSON representation of a selection. Must be\n  // implemented for custom classes (as a static class method).\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\")\n    let cls = classesById[json.type]\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)\n    return cls.fromJSON(doc, json)\n  }\n\n  // :: (string, constructor<Selection>)\n  // To be able to deserialize selections from JSON, custom selection\n  // classes must register themselves with an ID string, so that they\n  // can be disambiguated. Try to pick something that's unlikely to\n  // clash with classes from other modules.\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id)\n    classesById[id] = selectionClass\n    selectionClass.prototype.jsonID = id\n    return selectionClass\n  }\n\n  // :: () → SelectionBookmark\n  // Get a [bookmark](#state.SelectionBookmark) for this selection,\n  // which is a value that can be mapped without having access to a\n  // current document, and later resolved to a real selection for a\n  // given document again. (This is used mostly by the history to\n  // track and restore old selections.) The default implementation of\n  // this method just converts the selection to a text selection and\n  // returns the bookmark for that.\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark()\n  }\n}\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nexport class SelectionRange {\n  // :: (ResolvedPos, ResolvedPos)\n  constructor($from, $to) {\n    // :: ResolvedPos\n    // The lower bound of the range.\n    this.$from = $from\n    // :: ResolvedPos\n    // The upper bound of the range.\n    this.$to = $to\n  }\n}\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nexport class TextSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // Construct a text selection between the given points.\n  constructor($anchor, $head = $anchor) {\n    super($anchor, $head)\n  }\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }\n\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.inlineContent) return Selection.near($head)\n    let $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  }\n\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content)\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to)\n      if (marks) tr.ensureMarks(marks)\n    }\n  }\n\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  }\n\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head)\n  }\n\n  toJSON() {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\")\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  }\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true)\n      if (found) $head = found.$head\n      else return Selection.near($head, bias)\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor\n        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head\n      }\n    }\n    return new TextSelection($anchor, $head)\n  }\n}\n\nSelection.jsonID(\"text\", TextSelection)\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n  }\n}\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nexport class NodeSelection extends Selection {\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument.\n  constructor($pos) {\n    let node = $pos.nodeAfter\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize)\n    super($pos, $end)\n    // :: Node The selected node.\n    this.node = node\n  }\n\n  map(doc, mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    let $pos = doc.resolve(pos)\n    if (deleted) return Selection.near($pos)\n    return new NodeSelection($pos)\n  }\n\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  }\n\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  }\n\n  toJSON() {\n    return {type: \"node\", anchor: this.anchor}\n  }\n\n  getBookmark() { return new NodeBookmark(this.anchor) }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\")\n    return new NodeSelection(doc.resolve(json.anchor))\n  }\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  static create(doc, from) {\n    return new this(doc.resolve(from))\n  }\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false\n  }\n}\n\nNodeSelection.prototype.visible = false\n\nSelection.jsonID(\"node\", NodeSelection)\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor\n  }\n  map(mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)\n    return Selection.near($pos)\n  }\n}\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nexport class AllSelection extends Selection {\n  // :: (Node)\n  // Create an all-selection over the given document.\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size))\n  }\n\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size)\n      let sel = Selection.atStart(tr.doc)\n      if (!sel.eq(tr.selection)) tr.setSelection(sel)\n    } else {\n      super.replace(tr, content)\n    }\n  }\n\n  toJSON() { return {type: \"all\"} }\n\n  static fromJSON(doc) { return new AllSelection(doc) }\n\n  map(doc) { return new AllSelection(doc) }\n\n  eq(other) { return other instanceof AllSelection }\n\n  getBookmark() { return AllBookmark }\n}\n\nSelection.jsonID(\"all\", AllSelection)\n\nconst AllBookmark = {\n  map() { return this },\n  resolve(doc) { return new AllSelection(doc) }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) return TextSelection.create(doc, pos)\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i)\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) return inner\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1\n  if (last < startLen) return\n  let step = tr.steps[last]\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return\n  let map = tr.mapping.maps[last], end\n  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo })\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {Transform} from \"prosemirror-transform\"\nimport {Mark} from \"prosemirror-model\"\nimport {Selection} from \"./selection\"\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nexport class Transaction extends Transform {\n  constructor(state) {\n    super(state.doc)\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  }\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\")\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  }\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0\n  }\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  setStoredMarks(marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  }\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks)\n    return this\n  }\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0\n  }\n\n  addStep(step, doc) {\n    super.addStep(step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  }\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  setTime(time) {\n    this.time = time\n    return this\n  }\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  replaceSelection(slice) {\n    this.selection.replace(this, slice)\n    return this\n  }\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  replaceSelectionWith(node, inheritMarks) {\n    let selection = this.selection\n    if (inheritMarks !== false)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))\n    selection.replaceWith(this, node)\n    return this\n  }\n\n  // :: () → Transaction\n  // Delete the selection.\n  deleteSelection() {\n    this.selection.replace(this)\n    return this\n  }\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  insertText(text, from, to = from) {\n    let schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) return this.deleteSelection()\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) return this.deleteRange(from, to)\n      let marks = this.storedMarks\n      if (!marks) {\n        let $from = this.doc.resolve(from)\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks))\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))\n      return this\n    }\n  }\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  }\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  }\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  get isGeneric() {\n    for (let _ in this.meta) return false\n    return true\n  }\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL\n    return this\n  }\n\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0\n  }\n}\n","import {Node} from \"prosemirror-model\"\n\nimport {Selection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name\n    this.init = bind(desc.init, self)\n    this.apply = bind(desc.apply, self)\n  }\n}\n\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init(config) { return config.storedMarks || null },\n    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init() { return 0 },\n    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema\n    this.fields = baseFields.concat()\n    this.plugins = []\n    this.pluginsByKey = Object.create(null)\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key])\n        throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\")\n      this.plugins.push(plugin)\n      this.pluginsByKey[plugin.key] = plugin\n      if (plugin.spec.state)\n        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin))\n    })\n  }\n}\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nexport class EditorState {\n  constructor(config) {\n    this.config = config\n  }\n\n  // doc:: Node\n  // The current document.\n\n  // selection:: Selection\n  // The selection.\n\n  // storedMarks:: ?[Mark]\n  // A set of marks to apply to the next input. Will be null when\n  // no explicit marks have been set.\n\n  // :: Schema\n  // The schema of the state's document.\n  get schema() {\n    return this.config.schema\n  }\n\n  // :: [Plugin]\n  // The plugins that are active in this state.\n  get plugins() {\n    return this.config.plugins\n  }\n\n  // :: (Transaction) → EditorState\n  // Apply the given transaction to produce a new state.\n  apply(tr) {\n    return this.applyTransaction(tr).state\n  }\n\n  // : (Transaction) → bool\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i]\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n        return false\n    }\n    return true\n  }\n\n  // :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n  // Verbose variant of [`apply`](#state.EditorState.apply) that\n  // returns the precise transactions that were applied (which might\n  // be influenced by the [transaction\n  // hooks](#state.PluginSpec.filterTransaction) of\n  // plugins) along with the new state.\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}\n\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    outer: for (;;) {\n      let haveNew = false\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i]\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this\n          let tr = n < trs.length &&\n              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr)\n            if (!seen) {\n              seen = []\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0})\n            }\n            trs.push(tr)\n            newState = newState.applyInner(tr)\n            haveNew = true\n          }\n          if (seen) seen[i] = {state: newState, n: trs.length}\n        }\n      }\n      if (!haveNew) return {state: newState, transactions: trs}\n    }\n  }\n\n  // : (Transaction) → EditorState\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\")\n    let newInstance = new EditorState(this.config), fields = this.config.fields\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i]\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance)\n    }\n    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance)\n    return newInstance\n  }\n\n  // :: Transaction\n  // Start a [transaction](#state.Transaction) from this state.\n  get tr() { return new Transaction(this) }\n\n  // :: (Object) → EditorState\n  // Create a new state.\n  //\n  //   config::- Configuration options. Must contain `schema` or `doc` (or both).\n  //\n  //      schema:: ?Schema\n  //      The schema to use (only relevant if no `doc` is specified).\n  //\n  //      doc:: ?Node\n  //      The starting document.\n  //\n  //      selection:: ?Selection\n  //      A valid selection in the document.\n  //\n  //      storedMarks:: ?[Mark]\n  //      The initial set of [stored marks](#state.EditorState.storedMarks).\n  //\n  //      plugins:: ?[Plugin]\n  //      The plugins that should be active in this state.\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins)\n    let instance = new EditorState($config)\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance)\n    return instance\n  }\n\n  // :: (Object) → EditorState\n  // Create a new state based on this one, but with an adjusted set of\n  // active plugins. State fields that exist in both sets of plugins\n  // are kept unchanged. Those that no longer exist are dropped, and\n  // those that are new are initialized using their\n  // [`init`](#state.StateField.init) method, passing in the new\n  // configuration object..\n  //\n  //   config::- configuration options\n  //\n  //     plugins:: [Plugin]\n  //     New set of active plugins.\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins)\n    let fields = $config.fields, instance = new EditorState($config)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance)\n    }\n    return instance\n  }\n\n  // :: (?union<Object<Plugin>, string, number>) → Object\n  // Serialize this state to JSON. If you want to serialize the state\n  // of plugins, pass an object mapping property names to use in the\n  // resulting JSON object to plugin objects. The argument may also be\n  // a string or number, in which case it is ignored, to support the\n  // way `JSON.stringify` calls `toString` methods.\n  toJSON(pluginFields) {\n    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON())\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\")\n        throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\")\n      let plugin = pluginFields[prop], state = plugin.spec.state\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key])\n    }\n    return result\n  }\n\n  // :: (Object, Object, ?Object<Plugin>) → EditorState\n  // Deserialize a JSON representation of a state. `config` should\n  // have at least a `schema` field, and should contain array of\n  // plugins to initialize the state with. `pluginFields` can be used\n  // to deserialize the state of plugins, by associating plugin\n  // instances with the property names they use in the JSON object.\n  //\n  //   config::- configuration options\n  //\n  //     schema:: Schema\n  //     The schema to use.\n  //\n  //     plugins:: ?[Plugin]\n  //     The set of active plugins.\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\")\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\")\n    let $config = new Configuration(config.schema, config.plugins)\n    let instance = new EditorState($config)\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc)\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection)\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON)\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop], state = plugin.spec.state\n          if (plugin.key == field.name && state && state.fromJSON &&\n              Object.prototype.hasOwnProperty.call(json, prop)) {\n            // This field belongs to a plugin mapped to a JSON field, read it from there.\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n            return\n          }\n        }\n        instance[field.name] = field.init(config, instance)\n      }\n    })\n    return instance\n  }\n\n  // Kludge to allow the view to track mappings between different\n  // instances of a state.\n  //\n  // FIXME this is no longer needed as of prosemirror-view 1.9.0,\n  // though due to backwards-compat we should probably keep it around\n  // for a while (if only as a no-op)\n  static addApplyListener(f) {\n    applyListeners.push(f)\n  }\n  static removeApplyListener(f) {\n    let found = applyListeners.indexOf(f)\n    if (found > -1) applyListeners.splice(found, 1)\n  }\n}\n\nconst applyListeners = []\n","// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop]\n    if (val instanceof Function) val = val.bind(self)\n    else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {})\n    target[prop] = val\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nexport class Plugin {\n  // :: (PluginSpec)\n  // Create a plugin.\n  constructor(spec) {\n    // :: EditorProps\n    // The [props](#view.EditorProps) exported by this plugin.\n    this.props = {}\n    if (spec.props) bindProps(spec.props, this, this.props)\n    // :: Object\n    // The plugin's [spec object](#state.PluginSpec).\n    this.spec = spec\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\")\n  }\n\n  // :: (EditorState) → any\n  // Extract the plugin's state field from an editor state.\n  getState(state) { return state[this.key] }\n}\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nconst keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name]\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nexport class PluginKey {\n  // :: (?string)\n  // Create a plugin key.\n  constructor(name = \"key\") { this.key = createKey(name) }\n\n  // :: (EditorState) → ?Plugin\n  // Get the active plugin with this key, if any, from an editor\n  // state.\n  get(state) { return state.config.pluginsByKey[this.key] }\n\n  // :: (EditorState) → ?any\n  // Get the plugin's state from an editor state.\n  getState(state) { return state[this.key] }\n}\n","const result = {}\nexport default result\n\nif (typeof navigator != \"undefined\" && typeof document != \"undefined\") {\n  const ie_edge = /Edge\\/(\\d+)/.exec(navigator.userAgent)\n  const ie_upto10 = /MSIE \\d/.test(navigator.userAgent)\n  const ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n  result.mac = /Mac/.test(navigator.platform)\n  let ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge)\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null\n  result.gecko = !ie && /gecko\\/(\\d+)/i.test(navigator.userAgent)\n  result.gecko_version = result.gecko && +(/Firefox\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1]\n  let chrome = !ie && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\n  result.chrome = !!chrome\n  result.chrome_version = chrome && +chrome[1]\n  // Is true for both iOS and iPadOS for convenience\n  result.safari = !ie && /Apple Computer/.test(navigator.vendor)\n  result.ios = result.safari && (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2)\n  result.android = /Android \\d/.test(navigator.userAgent)\n  result.webkit = \"webkitFontSmoothing\" in document.documentElement.style\n  result.webkit_version = result.webkit && +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1]\n}\n","import browser from \"./browser\"\n\nexport const domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling\n    if (!node) return index\n  }\n}\n\nexport const parentNode = function(node) {\n  let parent = node.parentNode\n  return parent && parent.nodeType == 11 ? parent.host : parent\n}\n\nlet reusedRange = null\n\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nexport const textRange = function(node, from, to) {\n  let range = reusedRange || (reusedRange = document.createRange())\n  range.setEnd(node, to == null ? node.nodeValue.length : to)\n  range.setStart(node, from || 0)\n  return range\n}\n\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nexport const isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n                        scanFor(node, off, targetNode, targetOff, 1))\n}\n\nconst atomElements = /^(img|br|input|textarea|hr)$/i\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      let parent = node.parentNode\n      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        return false\n      off = domIndex(node) + (dir < 0 ? 0 : 1)\n      node = parent\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)]\n      if (node.contentEditable == \"false\") return false\n      off = dir < 0 ? nodeSize(node) : 0\n    } else {\n      return false\n    }\n  }\n}\n\nexport function nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nexport function isOnEdge(node, offset, parent) {\n  for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n    if (node == parent) return true\n    let index = domIndex(node)\n    node = node.parentNode\n    if (!node) return false\n    atStart = atStart && index == 0\n    atEnd = atEnd && index == nodeSize(node)\n  }\n}\n\nfunction hasBlockDesc(dom) {\n  let desc\n  for (let cur = dom; cur; cur = cur.parentNode) if (desc = cur.pmViewDesc) break\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)\n}\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nexport const selectionCollapsed = function(domSel) {\n  let collapsed = domSel.isCollapsed\n  if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n    collapsed = false\n  return collapsed\n}\n\nexport function keyEvent(keyCode, key) {\n  let event = document.createEvent(\"Event\")\n  event.initEvent(\"keydown\", true, true)\n  event.keyCode = keyCode\n  event.key = event.code = key\n  return event\n}\n","import {nodeSize, textRange, parentNode} from \"./dom\"\nimport browser from \"./browser\"\n\nfunction windowRect(doc) {\n  return {left: 0, right: doc.documentElement.clientWidth,\n          top: 0, bottom: doc.documentElement.clientHeight}\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side]\n}\n\nfunction clientRect(node) {\n  let rect = node.getBoundingClientRect()\n  // Adjust for elements with style \"transform: scale()\"\n  let scaleX = (rect.width / node.offsetWidth) || 1\n  let scaleY = (rect.height / node.offsetHeight) || 1\n  // Make sure scrollbar width isn't included in the rectangle\n  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,\n          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}\n}\n\nexport function scrollRectIntoView(view, rect, startDOM) {\n  let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5\n  let doc = view.dom.ownerDocument\n  for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) break\n    if (parent.nodeType != 1) continue\n    let atTop = parent == doc.body || parent.nodeType != 1\n    let bounding = atTop ? windowRect(doc) : clientRect(parent)\n    let moveX = 0, moveY = 0\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"))\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\")\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"))\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\")\n    if (moveX || moveY) {\n      if (atTop) {\n        doc.defaultView.scrollBy(moveX, moveY)\n      } else {\n        let startX = parent.scrollLeft, startY = parent.scrollTop\n        if (moveY) parent.scrollTop += moveY\n        if (moveX) parent.scrollLeft += moveX\n        let dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY\n        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY}\n      }\n    }\n    if (atTop) break\n  }\n}\n\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nexport function storeScrollPos(view) {\n  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top)\n  let refDOM, refTop\n  for (let x = (rect.left + rect.right) / 2, y = startY + 1;\n       y < Math.min(innerHeight, rect.bottom); y += 5) {\n    let dom = view.root.elementFromPoint(x, y)\n    if (dom == view.dom || !view.dom.contains(dom)) continue\n    let localRect = dom.getBoundingClientRect()\n    if (localRect.top >= startY - 20) {\n      refDOM = dom\n      refTop = localRect.top\n      break\n    }\n  }\n  return {refDOM, refTop, stack: scrollStack(view.dom)}\n}\n\nfunction scrollStack(dom) {\n  let stack = [], doc = dom.ownerDocument\n  for (; dom; dom = parentNode(dom)) {\n    stack.push({dom, top: dom.scrollTop, left: dom.scrollLeft})\n    if (dom == doc) break\n  }\n  return stack\n}\n\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nexport function resetScrollPos({refDOM, refTop, stack}) {\n  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop)\n}\n\nfunction restoreScrollStack(stack, dTop) {\n  for (let i = 0; i < stack.length; i++) {\n    let {dom, top, left} = stack[i]\n    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop\n    if (dom.scrollLeft != left) dom.scrollLeft = left\n  }\n}\n\nlet preventScrollSupported = null\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nexport function focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive() // in IE\n  if (preventScrollSupported) return dom.focus(preventScrollSupported)\n\n  let stored = scrollStack(dom)\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {preventScroll: true}\n      return true\n    }\n  } : undefined)\n  if (!preventScrollSupported) {\n    preventScrollSupported = false\n    restoreScrollStack(stored, 0)\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  let closest, dxClosest = 2e8, coordsClosest, offset = 0\n  let rowBot = coords.top, rowTop = coords.top\n  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    let rects\n    if (child.nodeType == 1) rects = child.getClientRects()\n    else if (child.nodeType == 3) rects = textRange(child).getClientRects()\n    else continue\n\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i]\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot)\n        rowTop = Math.min(rect.top, rowTop)\n        let dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0\n        if (dx < dxClosest) {\n          closest = child\n          dxClosest = dx\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords\n          if (child.nodeType == 1 && dx)\n            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        offset = childIndex + 1\n    }\n  }\n  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest)\n  if (!closest || (dxClosest && closest.nodeType == 1)) return {node, offset}\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  let len = node.nodeValue.length\n  let range = document.createRange()\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1)\n    range.setStart(node, i)\n    let rect = singleRect(range, 1)\n    if (rect.top == rect.bottom) continue\n    if (inRect(coords, rect))\n      return {node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)}\n  }\n  return {node, offset: 0}\n}\n\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&\n    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1\n}\n\nfunction targetKludge(dom, coords) {\n  let parent = dom.parentNode\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    return parent\n  return dom\n}\n\nfunction posFromElement(view, elt, coords) {\n  let {node, offset} = findOffsetInNode(elt, coords), bias = -1\n  if (node.nodeType == 1 && !node.firstChild) {\n    let rect = node.getBoundingClientRect()\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1\n  }\n  return view.docView.posFromDOM(node, offset, bias)\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  // Browser (in caretPosition/RangeFromPoint) will agressively\n  // normalize towards nearby inline nodes. Since we are interested in\n  // positions between block nodes too, we first walk up the hierarchy\n  // of nodes to see if there are block nodes that the coordinates\n  // fall outside of. If so, we take the position before/after that\n  // block. If not, we call `posFromDOM` on the raw node/offset.\n  let outside = -1\n  for (let cur = node;;) {\n    if (cur == view.dom) break\n    let desc = view.docView.nearestDesc(cur, true)\n    if (!desc) return null\n    if (desc.node.isBlock && desc.parent) {\n      let rect = desc.dom.getBoundingClientRect()\n      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore\n      else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter\n      else break\n    }\n    cur = desc.dom.parentNode\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)\n}\n\nfunction elementFromPoint(element, coords, box) {\n  let len = element.childNodes.length\n  if (len && box.top < box.bottom) {\n    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n      let child = element.childNodes[i]\n      if (child.nodeType == 1) {\n        let rects = child.getClientRects()\n        for (let j = 0; j < rects.length; j++) {\n          let rect = rects[j]\n          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect)\n        }\n      }\n      if ((i = (i + 1) % len) == startI) break\n    }\n  }\n  return element\n}\n\n// Given an x,y position on the editor, get the position in the document.\nexport function posAtCoords(view, coords) {\n  let root = view.root, node, offset\n  if (root.caretPositionFromPoint) {\n    try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n      let pos = root.caretPositionFromPoint(coords.left, coords.top)\n      if (pos) ({offsetNode: node, offset} = pos)\n    } catch (_) {}\n  }\n  if (!node && root.caretRangeFromPoint) {\n    let range = root.caretRangeFromPoint(coords.left, coords.top)\n    if (range) ({startContainer: node, startOffset: offset} = range)\n  }\n\n  let elt = root.elementFromPoint(coords.left, coords.top + 1), pos\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    let box = view.dom.getBoundingClientRect()\n    if (!inRect(coords, box)) return null\n    elt = elementFromPoint(view.dom, coords, box)\n    if (!elt) return null\n  }\n  // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n  if (browser.safari && elt.draggable) node = offset = null\n  elt = targetKludge(elt, coords)\n  if (node) {\n    if (browser.gecko && node.nodeType == 1) {\n      // Firefox will sometimes return offsets into <input> nodes, which\n      // have no actual children, from caretPositionFromPoint (#953)\n      offset = Math.min(offset, node.childNodes.length)\n      // It'll also move the returned position before image nodes,\n      // even if those are behind it.\n      if (offset < node.childNodes.length) {\n        let next = node.childNodes[offset], box\n        if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left &&\n            box.bottom > coords.top)\n          offset++\n      }\n    }\n    // Suspiciously specific kludge to work around caret*FromPoint\n    // never returning a position at the end of the document\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n        coords.top > node.lastChild.getBoundingClientRect().bottom)\n      pos = view.state.doc.content.size\n    // Ignore positions directly after a BR, since caret*FromPoint\n    // 'round up' positions that would be more accurately placed\n    // before the BR node.\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      pos = posFromCaret(view, node, offset, coords)\n  }\n  if (pos == null) pos = posFromElement(view, elt, coords)\n\n  let desc = view.docView.nearestDesc(elt, true)\n  return {pos, inside: desc ? desc.posAtStart - desc.border : -1}\n}\n\nfunction singleRect(object, bias) {\n  let rects = object.getClientRects()\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/\n\n// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nexport function coordsAtPos(view, pos, side) {\n  let {node, offset} = view.docView.domFromPos(pos, side < 0 ? -1 : 1)\n\n  let supportEmptyRange = browser.webkit || browser.gecko\n  if (node.nodeType == 3) {\n    // These browsers support querying empty text ranges. Prefer that in\n    // bidi context or when at the end of a node.\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      let rect = singleRect(textRange(node, offset, offset), side)\n      // Firefox returns bad results (the position before the space)\n      // when querying a position directly after line-broken\n      // whitespace. Detect this situation and and kludge around it\n      if (browser.gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1)\n        if (rectBefore.top == rect.top) {\n          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1)\n          if (rectAfter.top != rect.top)\n            return flattenV(rectAfter, rectAfter.left < rectBefore.left)\n        }\n      }\n      return rect\n    } else {\n      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1\n      if (side < 0 && !offset) { to++; takeSide = -1 }\n      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1 }\n      else if (side < 0) { from-- }\n      else { to ++ }\n      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)\n    }\n  }\n\n  // Return a horizontal line in block context\n  if (!view.state.doc.resolve(pos).parent.inlineContent) {\n    if (offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1]\n      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false)\n    }\n    if (offset < nodeSize(node)) {\n      let after = node.childNodes[offset]\n      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true)\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0)\n  }\n\n  // Inline, not in text node (this is not Bidi-safe)\n  if (offset && (side < 0 || offset == nodeSize(node))) {\n    let before = node.childNodes[offset - 1]\n    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n        // BR nodes tend to only return the rectangle before them.\n        // Only use them if they are the last element in their parent\n        : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null\n    if (target) return flattenV(singleRect(target, 1), false)\n  }\n  if (offset < nodeSize(node)) {\n    let after = node.childNodes[offset]\n    let target = after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n        : after.nodeType == 1 ? after : null\n    if (target) return flattenV(singleRect(target, -1), true)\n  }\n  // All else failed, just try to get a rectangle for the target node\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)\n}\n\nfunction flattenV(rect, left) {\n  if (rect.width == 0) return rect\n  let x = left ? rect.left : rect.right\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\n\nfunction flattenH(rect, top) {\n  if (rect.height == 0) return rect\n  let y = top ? rect.top : rect.bottom\n  return {top: y, bottom: y, left: rect.left, right: rect.right}\n}\n\nfunction withFlushedState(view, state, f) {\n  let viewState = view.state, active = view.root.activeElement\n  if (viewState != state) view.updateState(state)\n  if (active != view.dom) view.focus()\n  try {\n    return f()\n  } finally {\n    if (viewState != state) view.updateState(viewState)\n    if (active != view.dom && active) active.focus()\n  }\n}\n\n// : (EditorView, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  let sel = state.selection\n  let $pos = dir == \"up\" ? sel.$from : sel.$to\n  return withFlushedState(view, state, () => {\n    let {node: dom} = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1)\n    for (;;) {\n      let nearest = view.docView.nearestDesc(dom, true)\n      if (!nearest) break\n      if (nearest.node.isBlock) { dom = nearest.dom; break }\n      dom = nearest.dom.parentNode\n    }\n    let coords = coordsAtPos(view, $pos.pos, 1)\n    for (let child = dom.firstChild; child; child = child.nextSibling) {\n      let boxes\n      if (child.nodeType == 1) boxes = child.getClientRects()\n      else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects()\n      else continue\n      for (let i = 0; i < boxes.length; i++) {\n        let box = boxes[i]\n        if (box.bottom > box.top && (dir == \"up\" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))\n          return false\n      }\n    }\n    return true\n  })\n}\n\nconst maybeRTL = /[\\u0590-\\u08ac]/\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  let {$head} = state.selection\n  if (!$head.parent.isTextblock) return false\n  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size\n  let sel = getSelection()\n  // If the textblock is all LTR, or the browser doesn't support\n  // Selection.modify (Edge), fall back to a primitive approach\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    return dir == \"left\" || dir == \"backward\" ? atStart : atEnd\n\n  return withFlushedState(view, state, () => {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset\n    let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n    sel.modify(\"move\", dir, \"character\")\n    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom\n    let result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        (oldNode == sel.focusNode && oldOff == sel.focusOffset)\n    // Restore the previous selection\n    sel.removeAllRanges()\n    sel.addRange(oldRange)\n    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel\n    return result\n  })\n}\n\nlet cachedState = null, cachedDir = null, cachedResult = false\nexport function endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) return cachedResult\n  cachedState = state; cachedDir = dir\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\n","import {DOMSerializer, Fragment, Mark} from \"prosemirror-model\"\nimport {TextSelection} from \"prosemirror-state\"\n\nimport {domIndex, isEquivalentPosition, nodeSize} from \"./dom\"\nimport browser from \"./browser\"\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, you want more control over\n// the behavior of a node's in-editor representation, and need to\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n// Mark views only support `dom` and `contentDOM`, and don't support\n// any of the node view methods.\n//\n// Objects returned as node views must conform to this interface.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), an array\n//   of active decorations around the node (which are automatically\n//   drawn, and the node view may ignore if it isn't interested in\n//   them), and a [decoration source](#view.DecorationSource) that\n//   represents any decorations that apply to the content of the node\n//   (which again may be ignored). It should return true if it was\n//   able to update to that node, and false otherwise. If the node\n//   view has a `contentDOM` property (or no `dom` property), updating\n//   its child nodes will be handled by ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to remove the effect again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. The `anchor` and `head` positions are relative to the start\n//   of the node. By default, a DOM selection will be created between\n//   the DOM positions corresponding to those positions, but if you\n//   override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view. Events for\n//   which this returns true are not handled by the editor.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   or a selection change happens within the view. When the change is\n//   a selection change, the record will have a `type` property of\n//   `\"selection\"` (which doesn't occur for native mutation records).\n//   Return false if the editor should re-read the selection or\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is destroyed. (Not available for marks.)\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n  // : (?ViewDesc, [ViewDesc], dom.Node, ?dom.Node)\n  constructor(parent, children, dom, contentDOM) {\n    this.parent = parent\n    this.children = children\n    this.dom = dom\n    // An expando property on the DOM node provides a link back to its\n    // description.\n    dom.pmViewDesc = this\n    // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    this.contentDOM = contentDOM\n    this.dirty = NOT_DIRTY\n  }\n\n  // Used to check whether a given description corresponds to a\n  // widget/mark/node.\n  matchesWidget() { return false }\n  matchesMark() { return false }\n  matchesNode() { return false }\n  matchesHack() { return false }\n\n  get beforePosition() { return false }\n\n  // : () → ?ParseRule\n  // When parsing in-editor content (in domchange.js), we allow\n  // descriptions to determine the parse rules that should be used to\n  // parse them.\n  parseRule() { return null }\n\n  // : (dom.Event) → bool\n  // Used by the editor's event handler to ignore events that come\n  // from certain descs.\n  stopEvent() { return false }\n\n  // The size of the content represented by this desc.\n  get size() {\n    let size = 0\n    for (let i = 0; i < this.children.length; i++) size += this.children[i].size\n    return size\n  }\n\n  // For block nodes, this represents the space taken up by their\n  // start/end tokens.\n  get border() { return 0 }\n\n  destroy() {\n    this.parent = null\n    if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = null\n    for (let i = 0; i < this.children.length; i++)\n      this.children[i].destroy()\n  }\n\n  posBeforeChild(child) {\n    for (let i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n      let cur = this.children[i]\n      if (cur == child) return pos\n      pos += cur.size\n    }\n  }\n\n  get posBefore() {\n    return this.parent.posBeforeChild(this)\n  }\n\n  get posAtStart() {\n    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n  }\n\n  get posAfter() {\n    return this.posBefore + this.size\n  }\n\n  get posAtEnd() {\n    return this.posAtStart + this.size - 2 * this.border\n  }\n\n  // : (dom.Node, number, ?number) → number\n  localPosFromDOM(dom, offset, bias) {\n    // If the DOM position is in the content, use the child desc after\n    // it to figure out a position.\n    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n      if (bias < 0) {\n        let domBefore, desc\n        if (dom == this.contentDOM) {\n          domBefore = dom.childNodes[offset - 1]\n        } else {\n          while (dom.parentNode != this.contentDOM) dom = dom.parentNode\n          domBefore = dom.previousSibling\n        }\n        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling\n        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n      } else {\n        let domAfter, desc\n        if (dom == this.contentDOM) {\n          domAfter = dom.childNodes[offset]\n        } else {\n          while (dom.parentNode != this.contentDOM) dom = dom.parentNode\n          domAfter = dom.nextSibling\n        }\n        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this)) domAfter = domAfter.nextSibling\n        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd\n      }\n    }\n    // Otherwise, use various heuristics, falling back on the bias\n    // parameter, to determine whether to return the position at the\n    // start or at the end of this view desc.\n    let atEnd\n    if (dom == this.dom && this.contentDOM) {\n      atEnd = offset > domIndex(this.contentDOM)\n    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2\n    } else if (this.dom.firstChild) {\n      if (offset == 0) for (let search = dom;; search = search.parentNode) {\n        if (search == this.dom) { atEnd = false; break }\n        if (search.parentNode.firstChild != search) break\n      }\n      if (atEnd == null && offset == dom.childNodes.length) for (let search = dom;; search = search.parentNode) {\n        if (search == this.dom) { atEnd = true; break }\n        if (search.parentNode.lastChild != search) break\n      }\n    }\n    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n  }\n\n  // Scan up the dom finding the first desc that is a descendant of\n  // this one.\n  nearestDesc(dom, onlyNodes) {\n    for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n      let desc = this.getDesc(cur)\n      if (desc && (!onlyNodes || desc.node)) {\n        // If dom is outside of this desc's nodeDOM, don't count it.\n        if (first && desc.nodeDOM &&\n            !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))\n          first = false\n        else\n          return desc\n      }\n    }\n  }\n\n  getDesc(dom) {\n    let desc = dom.pmViewDesc\n    for (let cur = desc; cur; cur = cur.parent) if (cur == this) return desc\n  }\n\n  posFromDOM(dom, offset, bias) {\n    for (let scan = dom; scan; scan = scan.parentNode) {\n      let desc = this.getDesc(scan)\n      if (desc) return desc.localPosFromDOM(dom, offset, bias)\n    }\n    return -1\n  }\n\n  // : (number) → ?NodeViewDesc\n  // Find the desc for the node after the given pos, if any. (When a\n  // parent node overrode rendering, there might not be one.)\n  descAt(pos) {\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (offset == pos && end != offset) {\n        while (!child.border && child.children.length) child = child.children[0]\n        return child\n      }\n      if (pos < end) return child.descAt(pos - offset - child.border)\n      offset = end\n    }\n  }\n\n  // : (number, number) → {node: dom.Node, offset: number}\n  domFromPos(pos, side) {\n    if (!this.contentDOM) return {node: this.dom, offset: 0}\n    for (let offset = 0, i = 0, first = true;; i++, first = false) {\n      // Skip removed or always-before children\n      while (i < this.children.length && (this.children[i].beforePosition ||\n                                          this.children[i].dom.parentNode != this.contentDOM))\n        offset += this.children[i++].size\n      let child = i == this.children.length ? null : this.children[i]\n      if (offset == pos && (side == 0 || !child || !child.size || child.border || (side < 0 && first)) ||\n          child && child.domAtom && pos < offset + child.size) return {\n        node: this.contentDOM,\n        offset: child ? domIndex(child.dom) : this.contentDOM.childNodes.length\n      }\n      if (!child) throw new Error(\"Invalid position \" + pos)\n      let end = offset + child.size\n      if (!child.domAtom && (side < 0 && !child.border ? end >= pos : end > pos) &&\n          (end > pos || i + 1 >= this.children.length || !this.children[i + 1].beforePosition))\n        return child.domFromPos(pos - offset - child.border, side)\n      offset = end\n    }\n  }\n\n  // Used to find a DOM range in a single parent for a given changed\n  // range.\n  parseRange(from, to, base = 0) {\n    if (this.children.length == 0)\n      return {node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length}\n\n    let fromOffset = -1, toOffset = -1\n    for (let offset = base, i = 0;; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (fromOffset == -1 && from <= end) {\n        let childBase = offset + child.border\n        // FIXME maybe descend mark views to parse a narrower range?\n        if (from >= childBase && to <= end - child.border && child.node &&\n            child.contentDOM && this.contentDOM.contains(child.contentDOM))\n          return child.parseRange(from, to, childBase)\n\n        from = offset\n        for (let j = i; j > 0; j--) {\n          let prev = this.children[j - 1]\n          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n            fromOffset = domIndex(prev.dom) + 1\n            break\n          }\n          from -= prev.size\n        }\n        if (fromOffset == -1) fromOffset = 0\n      }\n      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n        to = end\n        for (let j = i + 1; j < this.children.length; j++) {\n          let next = this.children[j]\n          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n            toOffset = domIndex(next.dom)\n            break\n          }\n          to += next.size\n        }\n        if (toOffset == -1) toOffset = this.contentDOM.childNodes.length\n        break\n      }\n      offset = end\n    }\n    return {node: this.contentDOM, from, to, fromOffset, toOffset}\n  }\n\n  emptyChildAt(side) {\n    if (this.border || !this.contentDOM || !this.children.length) return false\n    let child = this.children[side < 0 ? 0 : this.children.length - 1]\n    return child.size == 0 || child.emptyChildAt(side)\n  }\n\n  // : (number) → dom.Node\n  domAfterPos(pos) {\n    let {node, offset} = this.domFromPos(pos, 0)\n    if (node.nodeType != 1 || offset == node.childNodes.length)\n      throw new RangeError(\"No node after pos \" + pos)\n    return node.childNodes[offset]\n  }\n\n  // : (number, number, dom.Document)\n  // View descs are responsible for setting any selection that falls\n  // entirely inside of them, so that custom implementations can do\n  // custom things with the selection. Note that this falls apart when\n  // a selection starts in such a node and ends in another, in which\n  // case we just use whatever domFromPos produces as a best effort.\n  setSelection(anchor, head, root, force) {\n    // If the selection falls entirely in a child, give it to that child\n    let from = Math.min(anchor, head), to = Math.max(anchor, head)\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (from > offset && to < end)\n        return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force)\n      offset = end\n    }\n\n    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1)\n    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1)\n    let domSel = root.getSelection()\n\n    let brKludge = false\n    // On Firefox, using Selection.collapse to put the cursor after a\n    // BR node for some reason doesn't always work (#1073). On Safari,\n    // the cursor sometimes inexplicable visually lags behind its\n    // reported position in such situations (#1092).\n    if ((browser.gecko || browser.safari) && anchor == head) {\n      let {node, offset} = anchorDOM\n      if (node.nodeType == 3) {\n        brKludge = offset && node.nodeValue[offset - 1] == \"\\n\"\n        // Issue #1128\n        if (brKludge && offset == node.nodeValue.length &&\n            node.nextSibling && node.nextSibling.nodeName == \"BR\")\n          anchorDOM = headDOM = {node: node.parentNode, offset: domIndex(node) + 1}\n      } else {\n        let prev = node.childNodes[offset - 1]\n        brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\")\n      }\n    }\n\n    if (!(force || brKludge && browser.safari) &&\n        isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n        isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n      return\n\n    // Selection.extend can be used to create an 'inverted' selection\n    // (one where the focus is before the anchor), but not all\n    // browsers support it yet.\n    let domSelExtended = false\n    if ((domSel.extend || anchor == head) && !brKludge) {\n      domSel.collapse(anchorDOM.node, anchorDOM.offset)\n      try {\n        if (anchor != head) domSel.extend(headDOM.node, headDOM.offset)\n        domSelExtended = true\n      } catch (err) {\n        // In some cases with Chrome the selection is empty after calling\n        // collapse, even when it should be valid. This appears to be a bug, but\n        // it is difficult to isolate. If this happens fallback to the old path\n        // without using extend.\n        if (!(err instanceof DOMException)) throw err\n        // declare global: DOMException\n      }\n    }\n    if (!domSelExtended) {\n      if (anchor > head) { let tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp }\n      let range = document.createRange()\n      range.setEnd(headDOM.node, headDOM.offset)\n      range.setStart(anchorDOM.node, anchorDOM.offset)\n      domSel.removeAllRanges()\n      domSel.addRange(range)\n    }\n  }\n\n  // : (dom.MutationRecord) → bool\n  ignoreMutation(mutation) {\n    return !this.contentDOM && mutation.type != \"selection\"\n  }\n\n  get contentLost() {\n    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)\n  }\n\n  // Remove a subtree of the element tree that has been touched\n  // by a DOM change, so that the next update will redraw it.\n  markDirty(from, to) {\n    for (let offset = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n        let startInside = offset + child.border, endInside = end - child.border\n        if (from >= startInside && to <= endInside) {\n          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY\n          if (from == startInside && to == endInside &&\n              (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY\n          else child.markDirty(from - startInside, to - startInside)\n          return\n        } else {\n          child.dirty = NODE_DIRTY\n        }\n      }\n      offset = end\n    }\n    this.dirty = CONTENT_DIRTY\n  }\n\n  markParentsDirty() {\n    let level = 1\n    for (let node = this.parent; node; node = node.parent, level++) {\n      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY\n      if (node.dirty < dirty) node.dirty = dirty\n    }\n  }\n\n  get domAtom() { return false }\n}\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nconst nothing = []\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n  // : (ViewDesc, Decoration)\n  constructor(parent, widget, view, pos) {\n    let self, dom = widget.type.toDOM\n    if (typeof dom == \"function\") dom = dom(view, () => {\n      if (!self) return pos\n      if (self.parent) return self.parent.posBeforeChild(self)\n    })\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        let wrap = document.createElement(\"span\")\n        wrap.appendChild(dom)\n        dom = wrap\n      }\n      dom.contentEditable = false\n      dom.classList.add(\"ProseMirror-widget\")\n    }\n    super(parent, nothing, dom, null)\n    this.widget = widget\n    self = this\n  }\n\n  get beforePosition() {\n    return this.widget.type.side < 0\n  }\n\n  matchesWidget(widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)\n  }\n\n  parseRule() { return {ignore: true} }\n\n  stopEvent(event) {\n    let stop = this.widget.spec.stopEvent\n    return stop ? stop(event) : false\n  }\n\n  ignoreMutation(mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection\n  }\n\n  get domAtom() { return true }\n}\n\nclass CompositionViewDesc extends ViewDesc {\n  constructor(parent, dom, textDOM, text) {\n    super(parent, nothing, dom, null)\n    this.textDOM = textDOM\n    this.text = text\n  }\n\n  get size() { return this.text.length }\n\n  localPosFromDOM(dom, offset) {\n    if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0)\n    return this.posAtStart + offset\n  }\n\n  domFromPos(pos) {\n    return {node: this.textDOM, offset: pos}\n  }\n\n  ignoreMutation(mut) {\n    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue\n   }\n}\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n  // : (ViewDesc, Mark, dom.Node)\n  constructor(parent, mark, dom, contentDOM) {\n    super(parent, [], dom, contentDOM)\n    this.mark = mark\n  }\n\n  static create(parent, mark, inline, view) {\n    let custom = view.nodeViews[mark.type.name]\n    let spec = custom && custom(mark, view, inline)\n    if (!spec || !spec.dom)\n      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline))\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)\n  }\n\n  parseRule() { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} }\n\n  matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) }\n\n  markDirty(from, to) {\n    super.markDirty(from, to)\n    // Move dirty info to nearest node view\n    if (this.dirty != NOT_DIRTY) {\n      let parent = this.parent\n      while (!parent.node) parent = parent.parent\n      if (parent.dirty < this.dirty) parent.dirty = this.dirty\n      this.dirty = NOT_DIRTY\n    }\n  }\n\n  slice(from, to, view) {\n    let copy = MarkViewDesc.create(this.parent, this.mark, true, view)\n    let nodes = this.children, size = this.size\n    if (to < size) nodes = replaceNodes(nodes, to, size, view)\n    if (from > 0) nodes = replaceNodes(nodes, 0, from, view)\n    for (let i = 0; i < nodes.length; i++) nodes[i].parent = copy\n    copy.children = nodes\n    return copy\n  }\n}\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n  // : (?ViewDesc, Node, [Decoration], DecorationSource, dom.Node, ?dom.Node, EditorView)\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    super(parent, node.isLeaf ? nothing : [], dom, contentDOM)\n    this.nodeDOM = nodeDOM\n    this.node = node\n    this.outerDeco = outerDeco\n    this.innerDeco = innerDeco\n    if (contentDOM) this.updateChildren(view, pos)\n  }\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finnicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  static create(parent, node, outerDeco, innerDeco, view, pos) {\n    let custom = view.nodeViews[node.type.name], descObj\n    let spec = custom && custom(node, view, () => {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (!descObj) return pos\n      if (descObj.parent) return descObj.parent.posBeforeChild(descObj)\n    }, outerDeco, innerDeco)\n\n    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM\n    if (node.isText) {\n      if (!dom) dom = document.createTextNode(node.text)\n      else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\")\n    } else if (!dom) {\n      ;({dom, contentDOM} = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)))\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n      if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = false\n      if (node.type.spec.draggable) dom.draggable = true\n    }\n\n    let nodeDOM = dom\n    dom = applyOuterDeco(dom, outerDeco, node)\n\n    if (spec)\n      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,\n                                              spec, view, pos + 1)\n    else if (node.isText)\n      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view)\n    else\n      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1)\n  }\n\n  parseRule() {\n    // Experimental kludge to allow opt-in re-parsing of nodes\n    if (this.node.type.spec.reparseInView) return null\n    // FIXME the assumption that this can always return the current\n    // attrs means that if the user somehow manages to change the\n    // attrs in the dom, that won't be picked up. Not entirely sure\n    // whether this is a problem\n    let rule = {node: this.node.type.name, attrs: this.node.attrs}\n    if (this.node.type.spec.code) rule.preserveWhitespace = \"full\"\n    if (this.contentDOM && !this.contentLost) rule.contentElement = this.contentDOM\n    else rule.getContent = () => this.contentDOM ? Fragment.empty : this.node.content\n    return rule\n  }\n\n  matchesNode(node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  }\n\n  get size() { return this.node.nodeSize }\n\n  get border() { return this.node.isLeaf ? 0 : 1 }\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  updateChildren(view, pos) {\n    let inline = this.node.inlineContent, off = pos\n    let composition = inline && view.composing && this.localCompositionNode(view, pos)\n    let updater = new ViewTreeUpdater(this, composition && composition.node)\n    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n      if (widget.spec.marks)\n        updater.syncToMarks(widget.spec.marks, inline, view)\n      else if (widget.type.side >= 0 && !insideNode)\n        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view)\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget, view, off)\n    }, (child, outerDeco, innerDeco, i) => {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, inline, view)\n      // Either find an existing desc that exactly matches this node,\n      // and drop the descs before it.\n      updater.findNodeMatch(child, outerDeco, innerDeco, i) ||\n        // Or try updating the next desc to reflect this node.\n        updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||\n        // Or just add it as a new desc.\n        updater.addNode(child, outerDeco, innerDeco, view, off)\n      off += child.nodeSize\n    })\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, inline, view)\n    if (this.node.isTextblock) updater.addTextblockHacks()\n    updater.destroyRest()\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      // May have to protect focused DOM from being changed if a composition is active\n      if (composition) this.protectLocalComposition(view, composition)\n      renderDescs(this.contentDOM, this.children, view)\n      if (browser.ios) iosHacks(this.dom)\n    }\n  }\n\n  localCompositionNode(view, pos) {\n    // Only do something if both the selection and a focused text node\n    // are inside of this node, and the node isn't already part of a\n    // view that's a child of this view\n    let {from, to} = view.state.selection\n    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) return\n    let sel = view.root.getSelection()\n    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset)\n    if (!textNode || !this.dom.contains(textNode.parentNode)) return\n\n    // Find the text in the focused node in the node, stop if it's not\n    // there (may have been modified through other means, in which\n    // case it should overwritten)\n    let text = textNode.nodeValue\n    let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos)\n\n    return textPos < 0 ? null : {node: textNode, pos: textPos, text}\n  }\n\n  protectLocalComposition(view, {node, pos, text}) {\n    // The node is already part of a local view desc, leave it there\n    if (this.getDesc(node)) return\n\n    // Create a composition view for the orphaned nodes\n    let topNode = node\n    for (;; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM) break\n      while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling)\n      while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling)\n      if (topNode.pmViewDesc) topNode.pmViewDesc = null\n    }\n    let desc = new CompositionViewDesc(this, topNode, node, text)\n    view.compositionNodes.push(desc)\n\n    // Patch up this.children to contain the composition view\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc)\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) return false\n    this.updateInner(node, outerDeco, innerDeco, view)\n    return true\n  }\n\n  updateInner(node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco)\n    this.node = node\n    this.innerDeco = innerDeco\n    if (this.contentDOM) this.updateChildren(view, this.posAtStart)\n    this.dirty = NOT_DIRTY\n  }\n\n  updateOuterDeco(outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) return\n    let needsWrap = this.nodeDOM.nodeType != 1\n    let oldDOM = this.dom\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap))\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = null\n      this.dom.pmViewDesc = this\n    }\n    this.outerDeco = outerDeco\n  }\n\n  // Mark this node as being the selected node.\n  selectNode() {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\")\n    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true\n  }\n\n  // Remove selected node marking from this node.\n  deselectNode() {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\")\n    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\")\n  }\n\n  get domAtom() { return this.node.isAtom }\n}\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nexport function docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc)\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)\n}\n\nclass TextViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view)\n  }\n\n  parseRule() {\n    let skip = this.nodeDOM.parentNode\n    while (skip && skip != this.dom && !skip.pmIsDeco) skip = skip.parentNode\n    return {skip: skip || true}\n  }\n\n  update(node, outerDeco, _, view) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n        !node.sameMarkup(this.node)) return false\n    this.updateOuterDeco(outerDeco)\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text\n      if (view.trackWrites == this.nodeDOM) view.trackWrites = null\n    }\n    this.node = node\n    this.dirty = NOT_DIRTY\n    return true\n  }\n\n  inParent() {\n    let parentDOM = this.parent.contentDOM\n    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true\n    return false\n  }\n\n  domFromPos(pos) {\n    return {node: this.nodeDOM, offset: pos}\n  }\n\n  localPosFromDOM(dom, offset, bias) {\n    if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length)\n    return super.localPosFromDOM(dom, offset, bias)\n  }\n\n  ignoreMutation(mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\"\n  }\n\n  slice(from, to, view) {\n    let node = this.node.cut(from, to), dom = document.createTextNode(node.text)\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)\n  }\n\n  get domAtom() { return false }\n}\n\n// A dummy desc used to tag trailing BR or span nodes created to work\n// around contentEditable terribleness.\nclass BRHackViewDesc extends ViewDesc {\n  parseRule() { return {ignore: true} }\n  matchesHack() { return this.dirty == NOT_DIRTY }\n  get domAtom() { return true }\n}\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n  // : (?ViewDesc, Node, [Decoration], DecorationSource, dom.Node, ?dom.Node, NodeView, EditorView)\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos)\n    this.spec = spec\n  }\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY) return false\n    if (this.spec.update) {\n      let result = this.spec.update(node, outerDeco, innerDeco)\n      if (result) this.updateInner(node, outerDeco, innerDeco, view)\n      return result\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return super.update(node, outerDeco, innerDeco, view)\n    }\n  }\n\n  selectNode() {\n    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()\n  }\n\n  deselectNode() {\n    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()\n  }\n\n  setSelection(anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n      : super.setSelection(anchor, head, root, force)\n  }\n\n  destroy() {\n    if (this.spec.destroy) this.spec.destroy()\n    super.destroy()\n  }\n\n  stopEvent(event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  }\n\n  ignoreMutation(mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation)\n  }\n}\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n  let dom = parentDOM.firstChild, written = false\n  for (let i = 0; i < descs.length; i++) {\n    let desc = descs[i], childDOM = desc.dom\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom); written = true }\n      dom = dom.nextSibling\n    } else {\n      written = true\n      parentDOM.insertBefore(childDOM, dom)\n    }\n    if (desc instanceof MarkViewDesc) {\n      let pos = dom ? dom.previousSibling : parentDOM.lastChild\n      renderDescs(desc.contentDOM, desc.children, view)\n      dom = pos ? pos.nextSibling : parentDOM.firstChild\n    }\n  }\n  while (dom) { dom = rm(dom); written = true }\n  if (written && view.trackWrites == parentDOM) view.trackWrites = null\n}\n\nfunction OuterDecoLevel(nodeName) {\n  if (nodeName) this.nodeName = nodeName\n}\nOuterDecoLevel.prototype = Object.create(null)\n\nconst noDeco = [new OuterDecoLevel]\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) return noDeco\n\n  let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top]\n\n  for (let i = 0; i < outerDeco.length; i++) {\n    let attrs = outerDeco[i].type.attrs\n    if (!attrs) continue\n    if (attrs.nodeName)\n      result.push(top = new OuterDecoLevel(attrs.nodeName))\n\n    for (let name in attrs) {\n      let val = attrs[name]\n      if (val == null) continue\n      if (needsWrap && result.length == 1)\n        result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"))\n      if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val\n      else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val\n      else if (name != \"nodeName\") top[name] = val\n    }\n  }\n\n  return result\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM\n\n  let curDOM = nodeDOM\n  for (let i = 0; i < curComputed.length; i++) {\n    let deco = curComputed[i], prev = prevComputed[i]\n    if (i) {\n      let parent\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent\n      } else {\n        parent = document.createElement(deco.nodeName)\n        parent.pmIsDeco = true\n        parent.appendChild(curDOM)\n        prev = noDeco[0]\n        curDOM = parent\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco)\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (let name in prev)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      dom.removeAttribute(name)\n  for (let name in cur)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n      dom.setAttribute(name, cur[name])\n  if (prev.class != cur.class) {\n    let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : nothing\n    let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : nothing\n    for (let i = 0; i < prevList.length; i++) if (curList.indexOf(prevList[i]) == -1)\n      dom.classList.remove(prevList[i])\n    for (let i = 0; i < curList.length; i++) if (prevList.indexOf(curList[i]) == -1)\n      dom.classList.add(curList[i])\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m\n      while (m = prop.exec(prev.style))\n        dom.style.removeProperty(m[1])\n    }\n    if (cur.style)\n      dom.style.cssText += cur.style\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (!a[i].type.eq(b[i].type)) return false\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  let next = dom.nextSibling\n  dom.parentNode.removeChild(dom)\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n  // : (NodeViewDesc)\n  constructor(top, lockedNode) {\n    this.top = top\n    this.lock = lockedNode\n    // Index into `this.top`'s child array, represents the current\n    // update position.\n    this.index = 0\n    // When entering a mark, the current top and index are pushed\n    // onto this.\n    this.stack = []\n    // Tracks whether anything was changed\n    this.changed = false\n\n    this.preMatch = preMatch(top.node.content, top.children)\n  }\n\n  // Destroy and remove the children between the given indices in\n  // `this.top`.\n  destroyBetween(start, end) {\n    if (start == end) return\n    for (let i = start; i < end; i++) this.top.children[i].destroy()\n    this.top.children.splice(start, end - start)\n    this.changed = true\n  }\n\n  // Destroy all remaining children in `this.top`.\n  destroyRest() {\n    this.destroyBetween(this.index, this.top.children.length)\n  }\n\n  // : ([Mark], EditorView)\n  // Sync the current stack of mark descs with the given array of\n  // marks, reusing existing mark descs when possible.\n  syncToMarks(marks, inline, view) {\n    let keep = 0, depth = this.stack.length >> 1\n    let maxKeep = Math.min(depth, marks.length)\n    while (keep < maxKeep &&\n           (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n      keep++\n\n    while (keep < depth) {\n      this.destroyRest()\n      this.top.dirty = NOT_DIRTY\n      this.index = this.stack.pop()\n      this.top = this.stack.pop()\n      depth--\n    }\n    while (depth < marks.length) {\n      this.stack.push(this.top, this.index + 1)\n      let found = -1\n      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n        if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }\n      }\n      if (found > -1) {\n        if (found > this.index) {\n          this.changed = true\n          this.destroyBetween(this.index, found)\n        }\n        this.top = this.top.children[this.index]\n      } else {\n        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view)\n        this.top.children.splice(this.index, 0, markDesc)\n        this.top = markDesc\n        this.changed = true\n      }\n      this.index = 0\n      depth++\n    }\n  }\n\n  // : (Node, [Decoration], DecorationSource) → bool\n  // Try to find a node desc matching the given data. Skip over it and\n  // return true when successful.\n  findNodeMatch(node, outerDeco, innerDeco, index) {\n    let children = this.top.children, found = -1\n    if (index >= this.preMatch.index) {\n      for (let i = this.index; i < children.length; i++) if (children[i].matchesNode(node, outerDeco, innerDeco)) {\n        found = i\n        break\n      }\n    } else {\n      for (let i = this.index, e = Math.min(children.length, i + 1); i < e; i++) {\n        let child = children[i]\n        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n          found = i\n          break\n        }\n      }\n    }\n    if (found < 0) return false\n    this.destroyBetween(this.index, found)\n    this.index++\n    return true\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool\n  // Try to update the next node, if any, to the given data. Checks\n  // pre-matches to avoid overwriting nodes that could still be used.\n  updateNextNode(node, outerDeco, innerDeco, view, index) {\n    for (let i = this.index; i < this.top.children.length; i++) {\n      let next = this.top.children[i]\n      if (next instanceof NodeViewDesc) {\n        let preMatch = this.preMatch.matched.get(next)\n        if (preMatch != null && preMatch != index) return false\n        let nextDOM = next.dom\n\n        // Can't update if nextDOM is or contains this.lock, except if\n        // it's a text node whose content already matches the new text\n        // and whose decorations match the new ones.\n        let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&\n            !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n              next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco))\n        if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n          this.destroyBetween(this.index, i)\n          if (next.dom != nextDOM) this.changed = true\n          this.index++\n          return true\n        }\n        break\n      }\n    }\n    return false\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView)\n  // Insert the node as a newly created node desc.\n  addNode(node, outerDeco, innerDeco, view, pos) {\n    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos))\n    this.changed = true\n  }\n\n  placeWidget(widget, view, pos) {\n    let next = this.index < this.top.children.length ? this.top.children[this.index] : null\n    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n      this.index++\n    } else {\n      let desc = new WidgetViewDesc(this.top, widget, view, pos)\n      this.top.children.splice(this.index++, 0, desc)\n      this.changed = true\n    }\n  }\n\n  // Make sure a textblock looks and behaves correctly in\n  // contentEditable.\n  addTextblockHacks() {\n    let lastChild = this.top.children[this.index - 1]\n    while (lastChild instanceof MarkViewDesc) lastChild = lastChild.children[lastChild.children.length - 1]\n\n    if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) ||\n        /\\n$/.test(lastChild.node.text)) {\n      if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {\n        this.index++\n      } else {\n        let dom = document.createElement(\"br\")\n        this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null))\n        this.changed = true\n      }\n    }\n  }\n}\n\n// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, descs) {\n  let fI = frag.childCount, dI = descs.length, matched = new Map\n  for (; fI > 0 && dI > 0; dI--) {\n    let desc = descs[dI - 1], node = desc.node\n    if (!node) continue\n    if (node != frag.child(fI - 1)) break\n    --fI\n    matched.set(desc, fI)\n  }\n  return {index: fI, matched}\n}\n\nfunction compareSide(a, b) { return a.type.side - b.type.side }\n\n// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  let locals = deco.locals(parent), offset = 0\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (let i = 0; i < parent.childCount; i++) {\n      let child = parent.child(i)\n      onNode(child, locals, deco.forChild(offset, child), i)\n      offset += child.nodeSize\n    }\n    return\n  }\n\n  let decoIndex = 0, active = [], restNode = null\n  for (let parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      let widget = locals[decoIndex++], widgets\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        (widgets || (widgets = [widget])).push(locals[decoIndex++])\n      if (widgets) {\n        widgets.sort(compareSide)\n        for (let i = 0; i < widgets.length; i++) onWidget(widgets[i], parentIndex, !!restNode)\n      } else {\n        onWidget(widget, parentIndex, !!restNode)\n      }\n    }\n\n    let child, index\n    if (restNode) {\n      index = -1\n      child = restNode\n      restNode = null\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex\n      child = parent.child(parentIndex++)\n    } else {\n      break\n    }\n\n    for (let i = 0; i < active.length; i++) if (active[i].to <= offset) active.splice(i--, 1)\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      active.push(locals[decoIndex++])\n\n    let end = offset + child.nodeSize\n    if (child.isText) {\n      let cutAt = end\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from\n      for (let i = 0; i < active.length; i++) if (active[i].to < cutAt) cutAt = active[i].to\n      if (cutAt < end) {\n        restNode = child.cut(cutAt - offset)\n        child = child.cut(0, cutAt - offset)\n        end = cutAt\n        index = -1\n      }\n    }\n\n    let outerDeco = !active.length ? nothing\n        : child.isInline && !child.isLeaf ? active.filter(d => !d.inline)\n        : active.slice()\n    onNode(child, outerDeco, deco.forChild(offset, child), index)\n    offset = end\n  }\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    let oldCSS = dom.style.cssText\n    dom.style.cssText = oldCSS + \"; list-style: square !important\"\n    window.getComputedStyle(dom).listStyle\n    dom.style.cssText = oldCSS\n  }\n}\n\nfunction nearbyTextNode(node, offset) {\n  for (;;) {\n    if (node.nodeType == 3) return node\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n        return node.childNodes[offset]\n      node = node.childNodes[offset - 1]\n      offset = nodeSize(node)\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset]\n      offset = 0\n    } else {\n      return null\n    }\n  }\n}\n\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n  for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n    let child = frag.child(i++), childStart = pos\n    pos += child.nodeSize\n    if (!child.isText) continue\n    let str = child.text\n    while (i < frag.childCount) {\n      let next = frag.child(i++)\n      pos += next.nodeSize\n      if (!next.isText) break\n      str += next.text\n    }\n    if (pos >= from) {\n      let found = str.lastIndexOf(text, to - childStart)\n      if (found >= 0 && found + text.length + childStart >= from)\n        return childStart + found\n    }\n  }\n  return -1\n}\n\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  let result = []\n  for (let i = 0, off = 0; i < nodes.length; i++) {\n    let child = nodes[i], start = off, end = off += child.size\n    if (start >= to || end <= from) {\n      result.push(child)\n    } else {\n      if (start < from) result.push(child.slice(0, from - start, view))\n      if (replacement) {\n        result.push(replacement)\n        replacement = null\n      }\n      if (end > to) result.push(child.slice(to - start, child.size, view))\n    }\n  }\n  return result\n}\n","import {TextSelection, NodeSelection} from \"prosemirror-state\"\n\nimport browser from \"./browser\"\nimport {selectionCollapsed, isEquivalentPosition, domIndex, isOnEdge} from \"./dom\"\n\nexport function selectionFromDOM(view, origin) {\n  let domSel = view.root.getSelection(), doc = view.state.doc\n  if (!domSel.focusNode) return null\n  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0\n  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)\n  if (head < 0) return null\n  let $head = doc.resolve(head), $anchor, selection\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head\n    while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent\n    if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent\n        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      let pos = nearestDesc.posBefore\n      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos))\n    }\n  } else {\n    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset)\n    if (anchor < 0) return null\n    $anchor = doc.resolve(anchor)\n  }\n\n  if (!selection) {\n    let bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1\n    selection = selectionBetween(view, $anchor, $head, bias)\n  }\n  return selection\n}\n\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() :\n    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)\n}\n\nexport function selectionToDOM(view, force) {\n  let sel = view.state.selection\n  syncNodeSelection(view, sel)\n\n  if (!editorOwnsSelection(view)) return\n\n  view.domObserver.disconnectSelection()\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view)\n  } else {\n    let {anchor, head} = sel, resetEditableFrom, resetEditableTo\n    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        resetEditableFrom = temporarilyEditableNear(view, sel.from)\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        resetEditableTo = temporarilyEditableNear(view, sel.to)\n    }\n    view.docView.setSelection(anchor, head, view.root, force)\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) resetEditable(resetEditableFrom)\n      if (resetEditableTo) resetEditable(resetEditableTo)\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\")\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\")\n      if (\"onselectionchange\" in document) removeClassOnSelectionChange(view)\n    }\n  }\n\n  view.domObserver.setCurSelection()\n  view.domObserver.connectSelection()\n}\n\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\n\nconst brokenSelectBetweenUneditable = browser.safari || browser.chrome && browser.chrome_version < 63\n\nfunction temporarilyEditableNear(view, pos) {\n  let {node, offset} = view.docView.domFromPos(pos, 0)\n  let after = offset < node.childNodes.length ? node.childNodes[offset] : null\n  let before = offset ? node.childNodes[offset - 1] : null\n  if (browser.safari && after && after.contentEditable == \"false\") return setEditable(after)\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) return setEditable(after)\n    else if (before) return setEditable(before)\n  }\n}\n\nfunction setEditable(element) {\n  element.contentEditable = \"true\"\n  if (browser.safari && element.draggable) { element.draggable = false; element.wasDraggable = true }\n  return element\n}\n\nfunction resetEditable(element) {\n  element.contentEditable = \"false\"\n  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  let doc = view.dom.ownerDocument\n  doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard)\n  let domSel = view.root.getSelection()\n  let node = domSel.anchorNode, offset = domSel.anchorOffset\n  doc.addEventListener(\"selectionchange\", view.hideSelectionGuard = () => {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard)\n      setTimeout(() => {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          view.dom.classList.remove(\"ProseMirror-hideselection\")\n      }, 20)\n    }\n  })\n}\n\nfunction selectCursorWrapper(view) {\n  let domSel = view.root.getSelection(), range = document.createRange()\n  let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\"\n  if (img) range.setEnd(node.parentNode, domIndex(node) + 1)\n  else range.setEnd(node, 0)\n  range.collapse(false)\n  domSel.removeAllRanges()\n  domSel.addRange(range)\n  // Kludge to kill 'control selection' in IE11 when selecting an\n  // invisible cursor wrapper, since that would result in those weird\n  // resize handles and a selection that considers the absolutely\n  // positioned wrapper, rather than the root editable node, the\n  // focused element.\n  if (!img && !view.state.selection.visible && browser.ie && browser.ie_version <= 11) {\n    node.disabled = true\n    node.disabled = false\n  }\n}\n\nexport function syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    let desc = view.docView.descAt(sel.from)\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view)\n      if (desc) desc.selectNode()\n      view.lastSelectedViewDesc = desc\n    }\n  } else {\n    clearNodeSelection(view)\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      view.lastSelectedViewDesc.deselectNode()\n    view.lastSelectedViewDesc = null\n  }\n}\n\nexport function selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", f => f(view, $anchor, $head))\n    || TextSelection.between($anchor, $head, bias)\n}\n\nexport function hasFocusAndSelection(view) {\n  if (view.editable && view.root.activeElement != view.dom) return false\n  return hasSelection(view)\n}\n\nexport function hasSelection(view) {\n  let sel = view.root.getSelection()\n  if (!sel.anchorNode) return false\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))\n  } catch(_) {\n    return false\n  }\n}\n\nexport function anchorInRightPlace(view) {\n  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0)\n  let domSel = view.root.getSelection()\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)\n}\n","import {Selection, NodeSelection, TextSelection, AllSelection} from \"prosemirror-state\"\nimport browser from \"./browser\"\nimport {domIndex, selectionCollapsed} from \"./dom\"\nimport {selectionToDOM} from \"./selection\"\n\nfunction moveSelectionBlock(state, dir) {\n  let {$anchor, $head} = state.selection\n  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head)\n  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null\n  return $start && Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView())\n  return true\n}\n\nfunction selectHorizontally(view, dir, mods) {\n  let sel = view.state.selection\n  if (sel instanceof TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      let next = moveSelectionBlock(view.state, dir)\n      if (next && (next instanceof NodeSelection)) return apply(view, next)\n      return false\n    } else if (!(browser.mac && mods.indexOf(\"m\") > -1)) {\n      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc\n      if (!node || node.isText) return false\n      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false\n      if (NodeSelection.isSelectable(node)) {\n        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))\n      } else if (browser.webkit) {\n        // Chrome and Safari will introduce extra pointless cursor\n        // positions around inline uneditable nodes, so we have to\n        // take over and move the cursor past them (#937)\n        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))\n      } else {\n        return false\n      }\n    }\n  } else if (sel instanceof NodeSelection && sel.node.isInline) {\n    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))\n  } else {\n    let next = moveSelectionBlock(view.state, dir)\n    if (next) return apply(view, next)\n    return false\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  let desc = dom.pmViewDesc\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\")\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  let sel = view.root.getSelection()\n  let node = sel.focusNode, offset = sel.focusOffset\n  if (!node) return\n  let moveNode, moveOffset, force = false\n  // Gecko will do odd things when the selection is directly in front\n  // of a non-editable node, so in that case, move it into the next\n  // node if possible. Issue prosemirror/prosemirror#832.\n  if (browser.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break\n      } else {\n        let before = node.childNodes[offset - 1]\n        if (isIgnorable(before)) {\n          moveNode = node\n          moveOffset = --offset\n        } else if (before.nodeType == 3) {\n          node = before\n          offset = node.nodeValue.length\n        } else break\n      }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      let prev = node.previousSibling\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode\n        moveOffset = domIndex(prev)\n        prev = prev.previousSibling\n      }\n      if (!prev) {\n        node = node.parentNode\n        if (node == view.dom) break\n        offset = 0\n      } else {\n        node = prev\n        offset = nodeLen(node)\n      }\n    }\n  }\n  if (force) setSelFocus(view, sel, node, offset)\n  else if (moveNode) setSelFocus(view, sel, moveNode, moveOffset)\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  let sel = view.root.getSelection()\n  let node = sel.focusNode, offset = sel.focusOffset\n  if (!node) return\n  let len = nodeLen(node)\n  let moveNode, moveOffset\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) break\n      let after = node.childNodes[offset]\n      if (isIgnorable(after)) {\n        moveNode = node\n        moveOffset = ++offset\n      }\n      else break\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      let next = node.nextSibling\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode\n        moveOffset = domIndex(next) + 1\n        next = next.nextSibling\n      }\n      if (!next) {\n        node = node.parentNode\n        if (node == view.dom) break\n        offset = len = 0\n      } else {\n        node = next\n        offset = 0\n        len = nodeLen(node)\n      }\n    }\n  }\n  if (moveNode) setSelFocus(view, sel, moveNode, moveOffset)\n}\n\nfunction isBlockNode(dom) {\n  let desc = dom.pmViewDesc\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSelFocus(view, sel, node, offset) {\n  if (selectionCollapsed(sel)) {\n    let range = document.createRange()\n    range.setEnd(node, offset)\n    range.setStart(node, offset)\n    sel.removeAllRanges()\n    sel.addRange(range)\n  } else if (sel.extend) {\n    sel.extend(node, offset)\n  }\n  view.domObserver.setCurSelection()\n  let {state} = view\n  // If no state update ends up happening, reset the selection.\n  setTimeout(() => {\n    if (view.state == state) selectionToDOM(view)\n  }, 50)\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n  let sel = view.state.selection\n  if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false\n  if (browser.mac && mods.indexOf(\"m\") > -1) return false\n  let {$from, $to} = sel\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    let next = moveSelectionBlock(view.state, dir)\n    if (next && (next instanceof NodeSelection))\n      return apply(view, next)\n  }\n  if (!$from.parent.inlineContent) {\n    let side = dir < 0 ? $from : $to\n    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir)\n    return beyond ? apply(view, beyond) : false\n  }\n  return false\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return true\n  let {$head, $anchor, empty} = view.state.selection\n  if (!$head.sameParent($anchor)) return true\n  if (!empty) return false\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true\n  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter)\n  if (nextNode && !nextNode.isText) {\n    let tr = view.state.tr\n    if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos)\n    else tr.delete($head.pos, $head.pos + nextNode.nodeSize)\n    view.dispatch(tr)\n    return true\n  }\n  return false\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop()\n  node.contentEditable = state\n  view.domObserver.start()\n}\n\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n  if (!browser.safari || view.state.selection.$head.parentOffset > 0) return\n  let {focusNode, focusOffset} = view.root.getSelection()\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n      focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    let child = focusNode.firstChild\n    switchEditable(view, child, true)\n    setTimeout(() => switchEditable(view, child, false), 20)\n  }\n}\n\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction getMods(event) {\n  let result = \"\"\n  if (event.ctrlKey) result += \"c\"\n  if (event.metaKey) result += \"m\"\n  if (event.altKey) result += \"a\"\n  if (event.shiftKey) result += \"s\"\n  return result\n}\n\nexport function captureKeyDown(view, event) {\n  let code = event.keyCode, mods = getMods(event)\n  if (code == 8 || (browser.mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46 || (browser.mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 40) { // Down arrow\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (mods == (browser.mac ? \"m\" : \"c\") &&\n             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n    return true\n  }\n  return false\n}\n","import {Fragment, DOMParser} from \"prosemirror-model\"\nimport {Selection, TextSelection} from \"prosemirror-state\"\n\nimport {selectionBetween, selectionFromDOM, selectionToDOM} from \"./selection\"\nimport {selectionCollapsed, keyEvent} from \"./dom\"\nimport browser from \"./browser\"\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, from_, to_) {\n  let {node: parent, fromOffset, toOffset, from, to} = view.docView.parseRange(from_, to_)\n\n  let domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{node: anchor, offset: domSel.anchorOffset}]\n    if (!selectionCollapsed(domSel))\n      find.push({node: domSel.focusNode, offset: domSel.focusOffset})\n  }\n  // Work around issue in Chrome where backspacing sometimes replaces\n  // the deleted content with a random BR node (issues #799, #831)\n  if (browser.chrome && view.lastKeyCode === 8) {\n    for (let off = toOffset; off > fromOffset; off--) {\n      let node = parent.childNodes[off - 1], desc = node.pmViewDesc\n      if (node.nodeType == \"BR\" && !desc) { toOffset = off; break }\n      if (!desc || desc.size) break\n    }\n  }\n  let startDoc = view.state.doc\n  let parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n  let $from = startDoc.resolve(from)\n\n  let sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.spec.code ? \"full\" : true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode,\n    context: $from\n  })\n  if (find && find[0].pos != null) {\n    let anchor = find[0].pos, head = find[1] && find[1].pos\n    if (head == null) head = anchor\n    sel = {anchor: anchor + from, head: head + from}\n  }\n  return {doc, sel, from, to}\n}\n\nfunction ruleFromNode(dom) {\n  let desc = dom.pmViewDesc\n  if (desc) {\n    return desc.parseRule()\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    // Safari replaces the list item or table cell with a BR\n    // directly in the list node (?!) if you delete the last\n    // character in a list item or table cell (#708, #862)\n    if (browser.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      let skip = document.createElement(\"div\")\n      skip.appendChild(document.createElement(\"li\"))\n      return {skip}\n    } else if (dom.parentNode.lastChild == dom || browser.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return {ignore: true}\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return {ignore: true}\n  }\n}\n\nexport function readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    let origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null\n    let newSel = selectionFromDOM(view, origin)\n    if (newSel && !view.state.selection.eq(newSel)) {\n      let tr = view.state.tr.setSelection(newSel)\n      if (origin == \"pointer\") tr.setMeta(\"pointer\", true)\n      else if (origin == \"key\") tr.scrollIntoView()\n      view.dispatch(tr)\n    }\n    return\n  }\n\n  let $before = view.state.doc.resolve(from)\n  let shared = $before.sharedDepth(to)\n  from = $before.before(shared + 1)\n  to = view.state.doc.resolve(to).after(shared + 1)\n\n  let sel = view.state.selection\n  let parse = parseBetween(view, from, to)\n  // Chrome sometimes leaves the cursor before the inserted text when\n  // composing after a cursor wrapper. This moves it forward.\n  if (browser.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {\n    let text = view.cursorWrapper.deco.type.toDOM.nextSibling\n    let size = text && text.nodeValue ? text.nodeValue.length : 1\n    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size}\n  }\n\n  let doc = view.state.doc, compare = doc.slice(parse.from, parse.to)\n  let preferredPos, preferredSide\n  // Prefer anchoring to end when Backspace is pressed\n  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to\n    preferredSide = \"end\"\n  } else {\n    preferredPos = view.state.selection.from\n    preferredSide = \"start\"\n  }\n  view.lastKeyCode = null\n\n  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide)\n  if (!change) {\n    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = {start: sel.from, endA: sel.to, endB: sel.to}\n    } else if ((browser.ios && view.lastIOSEnter > Date.now() - 225 || browser.android) &&\n               addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\") &&\n               view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n      view.lastIOSEnter = 0\n      return\n    } else {\n      if (parse.sel) {\n        let sel = resolveSelection(view, view.state.doc, parse.sel)\n        if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel))\n      }\n      return\n    }\n  }\n  view.domChangeCount++\n  // Handle the case where overwriting a selection by typing matches\n  // the start or end of the selected content, creating a change\n  // that's smaller than what was actually overwritten.\n  if (view.state.selection.from < view.state.selection.to &&\n      change.start == change.endB &&\n      view.state.selection instanceof TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {\n      change.start = view.state.selection.from\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {\n      change.endB += (view.state.selection.to - change.endA)\n      change.endA = view.state.selection.to\n    }\n  }\n\n  // IE11 will insert a non-breaking space _ahead_ of the space after\n  // the cursor space when adding a space before another space. When\n  // that happened, adjust the change to cover the space instead.\n  if (browser.ie && browser.ie_version <= 11 && change.endB == change.start + 1 &&\n      change.endA == change.start && change.start > parse.from &&\n      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n    change.start--\n    change.endA--\n    change.endB--\n  }\n\n  let $from = parse.doc.resolveNoCache(change.start - parse.from)\n  let $to = parse.doc.resolveNoCache(change.endB - parse.from)\n  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent\n  let nextSel\n  // If this looks like the effect of pressing Enter (or was recorded\n  // as being an iOS enter press), just dispatch an Enter key instead.\n  if (((browser.ios && view.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\"))) ||\n       (!inlineChange && $from.pos < parse.doc.content.size &&\n        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n        nextSel.head == $to.pos)) &&\n      view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n    view.lastIOSEnter = 0\n    return\n  }\n  // Same for backspace\n  if (view.state.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) {\n    if (browser.android && browser.chrome) view.domObserver.suppressSelectionUpdates() // #820\n    return\n  }\n\n  // Chrome Android will occasionally, during composition, delete the\n  // entire composition and then immediately insert it again. This is\n  // used to detect that situation.\n  if (browser.chrome && browser.android && change.toB == change.from)\n    view.lastAndroidDelete = Date.now()\n\n  // This tries to detect Android virtual keyboard\n  // enter-and-pick-suggestion action. That sometimes (see issue\n  // #1059) first fires a DOM mutation, before moving the selection to\n  // the newly created block. And then, because ProseMirror cleans up\n  // the DOM selection, it gives up moving the selection entirely,\n  // leaving the cursor in the wrong place. When that happens, we drop\n  // the new paragraph from the initial change, and fire a simulated\n  // enter key afterwards.\n  if (browser.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2\n    $to = parse.doc.resolveNoCache(change.endB - parse.from)\n    setTimeout(() => {\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })\n    }, 20)\n  }\n\n  let chFrom = change.start, chTo = change.endA\n\n  let tr, storedMarks, markChange, $from1\n  if (inlineChange) {\n    if ($from.pos == $to.pos) { // Deletion\n      // IE11 sometimes weirdly moves the DOM selection around after\n      // backspacing out the first element in a textblock\n      if (browser.ie && browser.ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates()\n        setTimeout(() => selectionToDOM(view), 20)\n      }\n      tr = view.state.tr.delete(chFrom, chTo)\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA))\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr\n      if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark)\n      else tr.removeMark(chFrom, chTo, markChange.mark)\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset)\n      if (view.someProp(\"handleTextInput\", f => f(view, chFrom, chTo, text))) return\n      tr = view.state.tr.insertText(text, chFrom, chTo)\n    }\n  }\n\n  if (!tr)\n    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from))\n  if (parse.sel) {\n    let sel = resolveSelection(view, tr.doc, parse.sel)\n    // Chrome Android will sometimes, during composition, report the\n    // selection in the wrong place. If it looks like that is\n    // happening, don't update the selection.\n    // Edge just doesn't move the cursor forward when you start typing\n    // in an empty block or between br nodes.\n    if (sel && !(browser.chrome && browser.android && view.composing && sel.empty &&\n                 (change.from != change.toB || view.lastAndroidDelete < Date.now() - 100) &&\n                 (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n                 browser.ie && sel.empty && sel.head == chFrom))\n      tr.setSelection(sel)\n  }\n  if (storedMarks) tr.ensureMarks(storedMarks)\n  view.dispatch(tr.scrollIntoView())\n}\n\nfunction resolveSelection(view, doc, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null\n  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks\n  let added = curMarks, removed = prevMarks, type, mark, update\n  for (let i = 0; i < prevMarks.length; i++) added = prevMarks[i].removeFromSet(added)\n  for (let i = 0; i < curMarks.length; i++) removed = curMarks[i].removeFromSet(removed)\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0]\n    type = \"add\"\n    update = node => node.mark(mark.addToSet(node.marks))\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0]\n    type = \"remove\"\n    update = node => node.mark(mark.removeFromSet(node.marks))\n  } else {\n    return null\n  }\n  let updated = []\n  for (let i = 0; i < prev.childCount; i++) updated.push(update(prev.child(i)))\n  if (Fragment.from(updated).eq(cur)) return {mark, type}\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    return false\n\n  let $start = old.resolve(start)\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    return false\n  let $next = old.resolve(skipClosingAndOpening($start, true, true))\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    return false\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--\n    end++\n    fromEnd = false\n  }\n  if (mayOpen) {\n    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth))\n    while (next && !next.isLeaf) {\n      next = next.firstChild\n      end++\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  let start = a.findDiffStart(b, pos)\n  if (start == null) return null\n  let {a: endA, b: endB} = a.findDiffEnd(b, pos + a.size, pos + b.size)\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, start - Math.min(endA, endB))\n    preferredPos -= endA + adjust - start\n  }\n  if (endA < start && a.size < b.size) {\n    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0\n    start -= move\n    endB = start + (endB - endA)\n    endA = start\n  } else if (endB < start) {\n    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0\n    start -= move\n    endA = start + (endA - endB)\n    endB = start\n  }\n  return {start, endA, endB}\n}\n","import {Slice, Fragment, DOMParser, DOMSerializer} from \"prosemirror-model\"\n\nexport function serializeForClipboard(view, slice) {\n  let context = [], {content, openStart, openEnd} = slice\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--\n    openEnd--\n    let node = content.firstChild\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null)\n    content = node.content\n  }\n\n  let serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema)\n  let doc = detachedDoc(), wrap = doc.createElement(\"div\")\n  wrap.appendChild(serializer.serializeFragment(content, {document: doc}))\n\n  let firstChild = wrap.firstChild, needsWrap\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (let i = needsWrap.length - 1; i >= 0; i--) {\n      let wrapper = doc.createElement(needsWrap[i])\n      while (wrap.firstChild) wrapper.appendChild(wrap.firstChild)\n      wrap.appendChild(wrapper)\n    }\n    firstChild = wrap.firstChild\n  }\n\n  if (firstChild && firstChild.nodeType == 1)\n    firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd} ${JSON.stringify(context)}`)\n\n  let text = view.someProp(\"clipboardTextSerializer\", f => f(slice)) ||\n      slice.content.textBetween(0, slice.content.size, \"\\n\\n\")\n\n  return {dom: wrap, text}\n}\n\n// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nexport function parseFromClipboard(view, text, html, plainText, $context) {\n  let dom, inCode = $context.parent.type.spec.code, slice\n  if (!html && !text) return null\n  let asText = text && (plainText || inCode || !html)\n  if (asText) {\n    view.someProp(\"transformPastedText\", f => { text = f(text, inCode || plainText) })\n    if (inCode) return new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0)\n    let parsed = view.someProp(\"clipboardTextParser\", f => f(text, $context, plainText))\n    if (parsed) {\n      slice = parsed\n    } else {\n      dom = document.createElement(\"div\")\n      text.trim().split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n        dom.appendChild(document.createElement(\"p\")).textContent = block\n      })\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", f => { html = f(html) })\n    dom = readHTML(html)\n  }\n\n  let contextNode = dom && dom.querySelector(\"[data-pm-slice]\")\n  let sliceData = contextNode && /^(\\d+) (\\d+) (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\"))\n  if (!slice) {\n    let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context})\n  }\n  if (sliceData)\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3])\n  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), false)\n\n  view.someProp(\"transformPasted\", f => { slice = f(slice) })\n  return slice\n}\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) return fragment\n  for (let d = $context.depth; d >= 0; d--) {\n    let parent = $context.node(d)\n    let match = parent.contentMatchAt($context.index(d))\n    let lastWrap, result = []\n    fragment.forEach(node => {\n      if (!result) return\n      let wrap = match.findWrapping(node.type), inLast\n      if (!wrap) return result = null\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast\n      } else {\n        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length)\n        let wrapped = withWrappers(node, wrap)\n        result.push(wrapped)\n        match = match.matchType(wrapped.type, wrapped.attrs)\n        lastWrap = wrap\n      }\n    })\n    if (result) return Fragment.from(result)\n  }\n  return fragment\n}\n\nfunction withWrappers(node, wrap, from = 0) {\n  for (let i = wrap.length - 1; i >= from; i--)\n    node = wrap[i].create(null, Fragment.from(node))\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1)\n    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner))\n    let match = sibling.contentMatchAt(sibling.childCount)\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))))\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) return node\n  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1))\n  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)\n  return node.copy(fragment.append(fill))\n}\n\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content\n  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd)\n  if (depth >= from)\n    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)\n      : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true))\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))\n}\n\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd)\n  if (openEnd < slice.openEnd)\n    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd)\n  return slice\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n}\n\nlet _detachedDoc = null\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n}\n\nfunction readHTML(html) {\n  let metas = /^(\\s*<meta [^>]*>)*/.exec(html)\n  if (metas) html = html.slice(metas[0].length)\n  let elt = detachedDoc().createElement(\"div\")\n  let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    html = wrap.map(n => \"<\" + n + \">\").join(\"\") + html + wrap.map(n => \"</\" + n + \">\").reverse().join(\"\")\n  elt.innerHTML = html\n  if (wrap) for (let i = 0; i < wrap.length; i++) elt = elt.querySelector(wrap[i]) || elt\n  return elt\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) return slice\n  let schema = slice.content.firstChild.type.schema, array\n  try { array = JSON.parse(context) }\n  catch(e) { return slice }\n  let {content, openStart, openEnd} = slice\n  for (let i = array.length - 2; i >= 0; i -= 2) {\n    let type = schema.nodes[array[i]]\n    if (!type || type.hasRequiredAttrs()) break\n    content = Fragment.from(type.create(array[i + 1], content))\n    openStart++; openEnd++\n  }\n  return new Slice(content, openStart, openEnd)\n}\n","import browser from \"./browser\"\nimport {domIndex, isEquivalentPosition} from \"./dom\"\nimport {hasFocusAndSelection, hasSelection, selectionToDOM} from \"./selection\"\n\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n}\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = browser.ie && browser.ie_version <= 11\n\nclass SelectionState {\n  constructor() {\n    this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null\n  }\n\n  set(sel) {\n    this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset\n    this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset\n  }\n\n  eq(sel) {\n    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n      sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset\n  }\n}\n\nexport class DOMObserver {\n  constructor(view, handleDOMChange) {\n    this.view = view\n    this.handleDOMChange = handleDOMChange\n    this.queue = []\n    this.flushingSoon = -1\n    this.observer = window.MutationObserver &&\n      new window.MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) this.queue.push(mutations[i])\n        // IE11 will sometimes (on backspacing out a single character\n        // text node after a BR node) call the observer callback\n        // before actually updating the DOM, which will cause\n        // ProseMirror to miss the change (see #930)\n        if (browser.ie && browser.ie_version <= 11 && mutations.some(\n          m => m.type == \"childList\" && m.removedNodes.length ||\n               m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n          this.flushSoon()\n        else\n          this.flush()\n      })\n    this.currentSelection = new SelectionState\n    if (useCharData) {\n      this.onCharData = e => {\n        this.queue.push({target: e.target, type: \"characterData\", oldValue: e.prevValue})\n        this.flushSoon()\n      }\n    }\n    this.onSelectionChange = this.onSelectionChange.bind(this)\n    this.suppressingSelectionUpdates = false\n  }\n\n  flushSoon() {\n    if (this.flushingSoon < 0)\n      this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush() }, 20)\n  }\n\n  forceFlush() {\n    if (this.flushingSoon > -1) {\n      window.clearTimeout(this.flushingSoon)\n      this.flushingSoon = -1\n      this.flush()\n    }\n  }\n\n  start() {\n    if (this.observer)\n      this.observer.observe(this.view.dom, observeOptions)\n    if (useCharData)\n      this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData)\n    this.connectSelection()\n  }\n\n  stop() {\n    if (this.observer) {\n      let take = this.observer.takeRecords()\n      if (take.length) {\n        for (let i = 0; i < take.length; i++) this.queue.push(take[i])\n        window.setTimeout(() => this.flush(), 20)\n      }\n      this.observer.disconnect()\n    }\n    if (useCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData)\n    this.disconnectSelection()\n  }\n\n  connectSelection() {\n    this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange)\n  }\n\n  disconnectSelection() {\n    this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange)\n  }\n\n  suppressSelectionUpdates() {\n    this.suppressingSelectionUpdates = true\n    setTimeout(() => this.suppressingSelectionUpdates = false, 50)\n  }\n\n  onSelectionChange() {\n    if (!hasFocusAndSelection(this.view)) return\n    if (this.suppressingSelectionUpdates) return selectionToDOM(this.view)\n    // Deletions on IE11 fire their events in the wrong order, giving\n    // us a selection change event before the DOM changes are\n    // reported.\n    if (browser.ie && browser.ie_version <= 11 && !this.view.state.selection.empty) {\n      let sel = this.view.root.getSelection()\n      // Selection.isCollapsed isn't reliable on IE\n      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n        return this.flushSoon()\n    }\n    this.flush()\n  }\n\n  setCurSelection() {\n    this.currentSelection.set(this.view.root.getSelection())\n  }\n\n  ignoreSelectionChange(sel) {\n    if (sel.rangeCount == 0) return true\n    let container = sel.getRangeAt(0).commonAncestorContainer\n    let desc = this.view.docView.nearestDesc(container)\n    if (desc && desc.ignoreMutation({type: \"selection\", target: container.nodeType == 3 ? container.parentNode : container})) {\n      this.setCurSelection()\n      return true\n    }\n  }\n\n  flush() {\n    if (!this.view.docView || this.flushingSoon > -1) return\n    let mutations = this.observer ? this.observer.takeRecords() : []\n    if (this.queue.length) {\n      mutations = this.queue.concat(mutations)\n      this.queue.length = 0\n    }\n\n    let sel = this.view.root.getSelection()\n    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel)\n\n    let from = -1, to = -1, typeOver = false, added = []\n    if (this.view.editable) {\n      for (let i = 0; i < mutations.length; i++) {\n        let result = this.registerMutation(mutations[i], added)\n        if (result) {\n          from = from < 0 ? result.from : Math.min(result.from, from)\n          to = to < 0 ? result.to : Math.max(result.to, to)\n          if (result.typeOver) typeOver = true\n        }\n      }\n    }\n\n    if (browser.gecko && added.length > 1) {\n      let brs = added.filter(n => n.nodeName == \"BR\")\n      if (brs.length == 2) {\n        let [a, b] = brs\n        if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove()\n        else a.remove()\n      }\n    }\n\n    if (from > -1 || newSel) {\n      if (from > -1) {\n        this.view.docView.markDirty(from, to)\n        checkCSS(this.view)\n      }\n      this.handleDOMChange(from, to, typeOver, added)\n      if (this.view.docView.dirty) this.view.updateState(this.view.state)\n      else if (!this.currentSelection.eq(sel)) selectionToDOM(this.view)\n      this.currentSelection.set(sel)\n    }\n  }\n\n  registerMutation(mut, added) {\n    // Ignore mutations inside nodes that were already noted as inserted\n    if (added.indexOf(mut.target) > -1) return null\n    let desc = this.view.docView.nearestDesc(mut.target)\n    if (mut.type == \"attributes\" &&\n        (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n         // Firefox sometimes fires spurious events for null/empty styles\n         (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n      return null\n    if (!desc || desc.ignoreMutation(mut)) return null\n\n    if (mut.type == \"childList\") {\n      for (let i = 0; i < mut.addedNodes.length; i++) added.push(mut.addedNodes[i])\n      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n        return {from: desc.posBefore, to: desc.posAfter}\n      let prev = mut.previousSibling, next = mut.nextSibling\n      if (browser.ie && browser.ie_version <= 11 && mut.addedNodes.length) {\n        // IE11 gives us incorrect next/prev siblings for some\n        // insertions, so if there are added nodes, recompute those\n        for (let i = 0; i < mut.addedNodes.length; i++) {\n          let {previousSibling, nextSibling} = mut.addedNodes[i]\n          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling\n          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling\n        }\n      }\n      let fromOffset = prev && prev.parentNode == mut.target\n          ? domIndex(prev) + 1 : 0\n      let from = desc.localPosFromDOM(mut.target, fromOffset, -1)\n      let toOffset = next && next.parentNode == mut.target\n          ? domIndex(next) : mut.target.childNodes.length\n      let to = desc.localPosFromDOM(mut.target, toOffset, 1)\n      return {from, to}\n    } else if (mut.type == \"attributes\") {\n      return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}\n    } else { // \"characterData\"\n      return {\n        from: desc.posAtStart,\n        to: desc.posAtEnd,\n        // An event was generated for a text change that didn't change\n        // any text. Mark the dom change to fall back to assuming the\n        // selection was typed over with an identical value if it can't\n        // find another change.\n        typeOver: mut.target.nodeValue == mut.oldValue\n      }\n    }\n  }\n}\n\nlet cssChecked = false\n\nfunction checkCSS(view) {\n  if (cssChecked) return\n  cssChecked = true\n  if (getComputedStyle(view.dom).whiteSpace == \"normal\")\n    console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\")\n}\n","import {Selection, NodeSelection, TextSelection} from \"prosemirror-state\"\nimport {dropPoint} from \"prosemirror-transform\"\nimport {Slice} from \"prosemirror-model\"\n\nimport browser from \"./browser\"\nimport {captureKeyDown} from \"./capturekeys\"\nimport {readDOMChange} from \"./domchange\"\nimport {parseFromClipboard, serializeForClipboard} from \"./clipboard\"\nimport {DOMObserver} from \"./domobserver\"\nimport {selectionBetween, selectionToDOM, selectionFromDOM} from \"./selection\"\nimport {keyEvent} from \"./dom\"\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {}, editHandlers = {}\n\nexport function initInput(view) {\n  view.shiftKey = false\n  view.mouseDown = null\n  view.lastKeyCode = null\n  view.lastKeyCodeTime = 0\n  view.lastClick = {time: 0, x: 0, y: 0, type: \"\"}\n  view.lastSelectionOrigin = null\n  view.lastSelectionTime = 0\n\n  view.lastIOSEnter = 0\n  view.lastIOSEnterFallbackTimeout = null\n  view.lastAndroidDelete = 0\n\n  view.composing = false\n  view.composingTimeout = null\n  view.compositionNodes = []\n  view.compositionEndedAt = -2e8\n\n  view.domObserver = new DOMObserver(view, (from, to, typeOver, added) => readDOMChange(view, from, to, typeOver, added))\n  view.domObserver.start()\n  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM\n  view.domChangeCount = 0\n\n  view.eventHandlers = Object.create(null)\n  for (let event in handlers) {\n    let handler = handlers[event]\n    view.dom.addEventListener(event, view.eventHandlers[event] = event => {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        handler(view, event)\n    })\n  }\n  // On Safari, for reasons beyond my understanding, adding an input\n  // event handler makes an issue where the composition vanishes when\n  // you press enter go away.\n  if (browser.safari) view.dom.addEventListener(\"input\", () => null)\n\n  ensureListeners(view)\n}\n\nfunction setSelectionOrigin(view, origin) {\n  view.lastSelectionOrigin = origin\n  view.lastSelectionTime = Date.now()\n}\n\nexport function destroyInput(view) {\n  view.domObserver.stop()\n  for (let type in view.eventHandlers)\n    view.dom.removeEventListener(type, view.eventHandlers[type])\n  clearTimeout(view.composingTimeout)\n  clearTimeout(view.lastIOSEnterFallbackTimeout)\n}\n\nexport function ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", currentHandlers => {\n    for (let type in currentHandlers) if (!view.eventHandlers[type])\n      view.dom.addEventListener(type, view.eventHandlers[type] = event => runCustomHandler(view, event))\n  })\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", handlers => {\n    let handler = handlers[event.type]\n    return handler ? handler(view, event) || event.defaultPrevented : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) return true\n  if (event.defaultPrevented) return false\n  for (let node = event.target; node != view.dom; node = node.parentNode)\n    if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      return false\n  return true\n}\n\nexport function dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    handlers[event.type](view, event)\n}\n\neditHandlers.keydown = (view, event) => {\n  view.shiftKey = event.keyCode == 16 || event.shiftKey\n  if (inOrNearComposition(view, event)) return\n  view.domObserver.forceFlush()\n  view.lastKeyCode = event.keyCode\n  view.lastKeyCodeTime = Date.now()\n  // On iOS, if we preventDefault enter key presses, the virtual\n  // keyboard gets confused. So the hack here is to set a flag that\n  // makes the DOM change code recognize that what just happens should\n  // be replaced by whatever the Enter key handlers do.\n  if (browser.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    let now = Date.now()\n    view.lastIOSEnter = now\n    view.lastIOSEnterFallbackTimeout = setTimeout(() => {\n      if (view.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))\n        view.lastIOSEnter = 0\n      }\n    }, 200)\n  } else if (view.someProp(\"handleKeyDown\", f => f(view, event)) || captureKeyDown(view, event)) {\n    event.preventDefault()\n  } else {\n    setSelectionOrigin(view, \"key\")\n  }\n}\n\neditHandlers.keyup = (view, e) => {\n  if (e.keyCode == 16) view.shiftKey = false\n}\n\neditHandlers.keypress = (view, event) => {\n  if (inOrNearComposition(view, event) || !event.charCode ||\n      event.ctrlKey && !event.altKey || browser.mac && event.metaKey) return\n\n  if (view.someProp(\"handleKeyPress\", f => f(view, event))) {\n    event.preventDefault()\n    return\n  }\n\n  let sel = view.state.selection\n  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    let text = String.fromCharCode(event.charCode)\n    if (!view.someProp(\"handleTextInput\", f => f(view, sel.$from.pos, sel.$to.pos, text)))\n      view.dispatch(view.state.tr.insertText(text).scrollIntoView())\n    event.preventDefault()\n  }\n}\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nfunction isNear(event, click) {\n  let dx = click.x - event.clientX, dy = click.y - event.clientY\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) return false\n  let $pos = view.state.doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n      return true\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) view.focus()\n  let tr = view.state.tr.setSelection(selection)\n  if (origin == \"pointer\") tr.setMeta(\"pointer\", true)\n  view.dispatch(tr)\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) return false\n  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter\n  if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\")\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) return false\n  let sel = view.state.selection, selectedNode, selectAt\n  if (sel instanceof NodeSelection) selectedNode = sel.node\n\n  let $pos = view.state.doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    if (NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 &&\n          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        selectAt = $pos.before(sel.$from.depth)\n      else\n        selectAt = $pos.before(i)\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\")\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", f => f(view, pos, event)) ||\n    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", f => f(view, pos, event))\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", f => f(view, pos, event)) ||\n    defaultTripleClick(view, inside)\n}\n\nfunction defaultTripleClick(view, inside) {\n  let doc = view.state.doc\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\")\n      return true\n    }\n    return false\n  }\n\n  let $pos = doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    let nodePos = $pos.before(i)\n    if (node.inlineContent)\n      updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\")\n    else if (NodeSelection.isSelectable(node))\n      updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\")\n    else\n      continue\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  return endComposition(view)\n}\n\nconst selectNodeModifier = browser.mac ? \"metaKey\" : \"ctrlKey\"\n\nhandlers.mousedown = (view, event) => {\n  view.shiftKey = event.shiftKey\n  let flushed = forceDOMFlush(view)\n  let now = Date.now(), type = \"singleClick\"\n  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {\n    if (view.lastClick.type == \"singleClick\") type = \"doubleClick\"\n    else if (view.lastClick.type == \"doubleClick\") type = \"tripleClick\"\n  }\n  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type}\n\n  let pos = view.posAtCoords(eventCoords(event))\n  if (!pos) return\n\n  if (type == \"singleClick\")\n    view.mouseDown = new MouseDown(view, pos, event, flushed)\n  else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))\n    event.preventDefault()\n  else\n    setSelectionOrigin(view, \"pointer\")\n}\n\nclass MouseDown {\n  constructor(view, pos, event, flushed) {\n    this.view = view\n    this.startDoc = view.state.doc\n    this.pos = pos\n    this.event = event\n    this.flushed = flushed\n    this.selectNode = event[selectNodeModifier]\n    this.allowDefault = event.shiftKey\n\n    let targetNode, targetPos\n    if (pos.inside > -1) {\n      targetNode = view.state.doc.nodeAt(pos.inside)\n      targetPos = pos.inside\n    } else {\n      let $pos = view.state.doc.resolve(pos.pos)\n      targetNode = $pos.parent\n      targetPos = $pos.depth ? $pos.before() : 0\n    }\n\n    this.mightDrag = null\n\n    const target = flushed ? null : event.target\n    const targetDesc = target ? view.docView.nearestDesc(target, true) : null\n    this.target = targetDesc ? targetDesc.dom : null\n\n    if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n        view.state.selection instanceof NodeSelection && targetPos == view.state.selection.from)\n      this.mightDrag = {node: targetNode,\n                        pos: targetPos,\n                        addAttr: this.target && !this.target.draggable,\n                        setUneditable: this.target && browser.gecko && !this.target.hasAttribute(\"contentEditable\")}\n\n    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n      this.view.domObserver.stop()\n      if (this.mightDrag.addAttr) this.target.draggable = true\n      if (this.mightDrag.setUneditable)\n        setTimeout(() => this.target.setAttribute(\"contentEditable\", \"false\"), 20)\n      this.view.domObserver.start()\n    }\n\n    view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this))\n    view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this))\n    setSelectionOrigin(view, \"pointer\")\n  }\n\n  done() {\n    this.view.root.removeEventListener(\"mouseup\", this.up)\n    this.view.root.removeEventListener(\"mousemove\", this.move)\n    if (this.mightDrag && this.target) {\n      this.view.domObserver.stop()\n      if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\")\n      if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\")\n      this.view.domObserver.start()\n    }\n    this.view.mouseDown = null\n  }\n\n  up(event) {\n    this.done()\n\n    if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n      return\n\n    let pos = this.pos\n    if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event))\n\n    if (this.allowDefault || !pos) {\n      setSelectionOrigin(this.view, \"pointer\")\n    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n      event.preventDefault()\n    } else if (this.flushed ||\n               // Safari ignores clicks on draggable elements\n               (browser.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n               // Chrome will sometimes treat a node selection as a\n               // cursor, but still report that the node is selected\n               // when asked through getSelection. You'll then get a\n               // situation where clicking at the point where that\n               // (hidden) cursor is doesn't change the selection, and\n               // thus doesn't get a reaction from ProseMirror. This\n               // works around that.\n               (browser.chrome && !(this.view.state.selection instanceof TextSelection) &&\n                (pos.pos == this.view.state.selection.from || pos.pos == this.view.state.selection.to))) {\n      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\")\n      event.preventDefault()\n    } else {\n      setSelectionOrigin(this.view, \"pointer\")\n    }\n  }\n\n  move(event) {\n    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n                               Math.abs(this.event.y - event.clientY) > 4))\n      this.allowDefault = true\n    setSelectionOrigin(this.view, \"pointer\")\n  }\n}\n\nhandlers.touchdown = view => {\n  forceDOMFlush(view)\n  setSelectionOrigin(view, \"pointer\")\n}\n\nhandlers.contextmenu = view => forceDOMFlush(view)\n\nfunction inOrNearComposition(view, event) {\n  if (view.composing) return true\n  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n  // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n  // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n  // emitted. The keydown event triggers newline insertion, which we don't want.\n  // This method returns true if the keydown event should be ignored.\n  // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n  // This guards against the case where compositionend is triggered without the keyboard\n  // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n  // afterwards- we wouldn't want to ignore the keydown event in this case.\n  if (browser.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {\n    view.compositionEndedAt = -2e8\n    return true\n  }\n  return false\n}\n\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = browser.android ? 5000 : -1\n\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n  if (!view.composing) {\n    view.domObserver.flush()\n    let {state} = view, $pos = state.selection.$from\n    if (state.selection.empty &&\n        (state.storedMarks ||\n         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {\n      // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n      view.markCursor = view.state.storedMarks || $pos.marks()\n      endComposition(view, true)\n      view.markCursor = null\n    } else {\n      endComposition(view)\n      // In firefox, if the cursor is after but outside a marked node,\n      // the inserted text won't inherit the marks. So this moves it\n      // inside if necessary.\n      if (browser.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        let sel = view.root.getSelection()\n        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1]\n          if (!before) break\n          if (before.nodeType == 3) {\n            sel.collapse(before, before.nodeValue.length)\n            break\n          } else {\n            node = before\n            offset = -1\n          }\n        }\n      }\n    }\n    view.composing = true\n  }\n  scheduleComposeEnd(view, timeoutComposition)\n}\n\neditHandlers.compositionend = (view, event) => {\n  if (view.composing) {\n    view.composing = false\n    view.compositionEndedAt = event.timeStamp\n    scheduleComposeEnd(view, 20)\n  }\n}\n\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.composingTimeout)\n  if (delay > -1) view.composingTimeout = setTimeout(() => endComposition(view), delay)\n}\n\nexport function clearComposition(view) {\n  view.composing = false\n  while (view.compositionNodes.length > 0) view.compositionNodes.pop().markParentsDirty()\n}\n\nexport function endComposition(view, forceUpdate) {\n  view.domObserver.forceFlush()\n  clearComposition(view)\n  if (forceUpdate || view.docView.dirty) {\n    let sel = selectionFromDOM(view)\n    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel))\n    else view.updateState(view.state)\n    return true\n  }\n  return false\n}\n\nfunction captureCopy(view, dom) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  if (!view.dom.parentNode) return\n  let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"))\n  wrap.appendChild(dom)\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\"\n  let sel = getSelection(), range = document.createRange()\n  range.selectNodeContents(dom)\n  // Done because IE will fire a selectionchange moving the selection\n  // to its start when removeAllRanges is called and the editor still\n  // has focus (which will mess up the editor's selection state).\n  view.dom.blur()\n  sel.removeAllRanges()\n  sel.addRange(range)\n  setTimeout(() => {\n    if (wrap.parentNode) wrap.parentNode.removeChild(wrap)\n    view.focus()\n  }, 50)\n}\n\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n      (browser.ios && browser.webkit_version < 604)\n\nhandlers.copy = editHandlers.cut = (view, e) => {\n  let sel = view.state.selection, cut = e.type == \"cut\"\n  if (sel.empty) return\n\n  // IE and Edge's clipboard interface is completely broken\n  let data = brokenClipboardAPI ? null : e.clipboardData\n  let slice = sel.content(), {dom, text} = serializeForClipboard(view, slice)\n  if (data) {\n    e.preventDefault()\n    data.clearData()\n    data.setData(\"text/html\", dom.innerHTML)\n    data.setData(\"text/plain\", text)\n  } else {\n    captureCopy(view, dom)\n  }\n  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"))\n}\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\nfunction capturePaste(view, e) {\n  if (!view.dom.parentNode) return\n  let plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code\n  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"))\n  if (!plainText) target.contentEditable = \"true\"\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\"\n  target.focus()\n  setTimeout(() => {\n    view.focus()\n    if (target.parentNode) target.parentNode.removeChild(target)\n    if (plainText) doPaste(view, target.value, null, e)\n    else doPaste(view, target.textContent, target.innerHTML, e)\n  }, 50)\n}\n\nfunction doPaste(view, text, html, e) {\n  let slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from)\n  if (view.someProp(\"handlePaste\", f => f(view, e, slice || Slice.empty))) return true\n  if (!slice) return false\n\n  let singleNode = sliceSingleNode(slice)\n  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice)\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"))\n  return true\n}\n\neditHandlers.paste = (view, e) => {\n  let data = brokenClipboardAPI ? null : e.clipboardData\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), e)) e.preventDefault()\n  else capturePaste(view, e)\n}\n\nclass Dragging {\n  constructor(slice, move) {\n    this.slice = slice\n    this.move = move\n  }\n}\n\nconst dragCopyModifier = browser.mac ? \"altKey\" : \"ctrlKey\"\n\nhandlers.dragstart = (view, e) => {\n  let mouseDown = view.mouseDown\n  if (mouseDown) mouseDown.done()\n  if (!e.dataTransfer) return\n\n  let sel = view.state.selection\n  let pos = sel.empty ? null : view.posAtCoords(eventCoords(e))\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) {\n    // In selection\n  } else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)))\n  } else if (e.target && e.target.nodeType == 1) {\n    let desc = view.docView.nearestDesc(e.target, true)\n    if (!desc || !desc.node.type.spec.draggable || desc == view.docView) return\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)))\n  }\n  let slice = view.state.selection.content(), {dom, text} = serializeForClipboard(view, slice)\n  e.dataTransfer.clearData()\n  e.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML)\n  if (!brokenClipboardAPI) e.dataTransfer.setData(\"text/plain\", text)\n  view.dragging = new Dragging(slice, !e[dragCopyModifier])\n}\n\nhandlers.dragend = view => {\n  let dragging = view.dragging\n  window.setTimeout(() => {\n    if (view.dragging == dragging)  view.dragging = null\n  }, 50)\n}\n\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault()\n\neditHandlers.drop = (view, e) => {\n  let dragging = view.dragging\n  view.dragging = null\n\n  if (!e.dataTransfer) return\n\n  let eventPos = view.posAtCoords(eventCoords(e))\n  if (!eventPos) return\n  let $mouse = view.state.doc.resolve(eventPos.pos)\n  if (!$mouse) return\n  let slice = dragging && dragging.slice ||\n      parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"),\n                         brokenClipboardAPI ? null : e.dataTransfer.getData(\"text/html\"), false, $mouse)\n  let move = dragging && !e[dragCopyModifier]\n  if (view.someProp(\"handleDrop\", f => f(view, e, slice || Slice.empty, move))) {\n    e.preventDefault()\n    return\n  }\n  if (!slice) return\n\n  e.preventDefault()\n  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos\n  if (insertPos == null) insertPos = $mouse.pos\n\n  let tr = view.state.tr\n  if (move) tr.deleteSelection()\n\n  let pos = tr.mapping.map(insertPos)\n  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1\n  let beforeInsert = tr.doc\n  if (isNode)\n    tr.replaceRangeWith(pos, pos, slice.content.firstChild)\n  else\n    tr.replaceRange(pos, pos, slice)\n  if (tr.doc.eq(beforeInsert)) return\n\n  let $pos = tr.doc.resolve(pos)\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new NodeSelection($pos))\n  } else {\n    let end = tr.mapping.map(insertPos)\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo)\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)))\n  }\n  view.focus()\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"))\n}\n\nhandlers.focus = view => {\n  if (!view.focused) {\n    view.domObserver.stop()\n    view.dom.classList.add(\"ProseMirror-focused\")\n    view.domObserver.start()\n    view.focused = true\n    setTimeout(() => {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))\n        selectionToDOM(view)\n    }, 20)\n  }\n}\n\nhandlers.blur = view => {\n  if (view.focused) {\n    view.domObserver.stop()\n    view.dom.classList.remove(\"ProseMirror-focused\")\n    view.domObserver.start()\n    view.domObserver.currentSelection.set({})\n    view.focused = false\n  }\n}\n\nhandlers.beforeinput = (view, event) => {\n  // We should probably do more with beforeinput events, but support\n  // is so spotty that I'm still waiting to see where they are going.\n\n  // Very specific hack to deal with backspace sometimes failing on\n  // Chrome Android when after an uneditable node.\n  if (browser.chrome && browser.android && event.inputType == \"deleteContentBackward\") {\n    let {domChangeCount} = view\n    setTimeout(() => {\n      if (view.domChangeCount != domChangeCount) return // Event already had some effect\n      // This bug tends to close the virtual keyboard, so we refocus\n      view.dom.blur()\n      view.focus()\n      if (view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) return\n      let {$cursor} = view.state.selection\n      // Crude approximation of backspace behavior when no command handled it\n      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView())\n    }, 50)\n  }\n}\n\n// Make sure all handlers get registered\nfor (let prop in editHandlers) handlers[prop] = editHandlers[prop]\n","function compareObjs(a, b) {\n  if (a == b) return true\n  for (let p in a) if (a[p] !== b[p]) return false\n  for (let p in b) if (!(p in a)) return false\n  return true\n}\n\nclass WidgetType {\n  constructor(toDOM, spec) {\n    this.spec = spec || noSpec\n    this.side = this.spec.side || 0\n    this.toDOM = toDOM\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let {pos, deleted} = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1)\n    return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n  }\n\n  valid() { return true }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof WidgetType &&\n       (this.spec.key && this.spec.key == other.spec.key ||\n        this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))\n  }\n}\n\nclass InlineType {\n  constructor(attrs, spec) {\n    this.spec = spec || noSpec\n    this.attrs = attrs\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset\n    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset\n    return from >= to ? null : new Decoration(from, to, this)\n  }\n\n  valid(_, span) { return span.from < span.to }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n       compareObjs(this.spec, other.spec))\n  }\n\n  static is(span) { return span.type instanceof InlineType }\n}\n\nclass NodeType {\n  constructor(attrs, spec) {\n    this.spec = spec || noSpec\n    this.attrs = attrs\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.mapResult(span.from + oldOffset, 1)\n    if (from.deleted) return null\n    let to = mapping.mapResult(span.to + oldOffset, -1)\n    if (to.deleted || to.pos <= from.pos) return null\n    return new Decoration(from.pos - offset, to.pos - offset, this)\n  }\n\n  valid(node, span) {\n    let {index, offset} = node.content.findIndex(span.from)\n    return offset == span.from && offset + node.child(index).nodeSize == span.to\n  }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n       compareObjs(this.spec, other.spec))\n  }\n}\n\n// ::- Decoration objects can be provided to the view through the\n// [`decorations` prop](#view.EditorProps.decorations). They come in\n// several variants—see the static members of this class for details.\nexport class Decoration {\n  constructor(from, to, type) {\n    // :: number\n    // The start position of the decoration.\n    this.from = from\n    // :: number\n    // The end position. Will be the same as `from` for [widget\n    // decorations](#view.Decoration^widget).\n    this.to = to\n    this.type = type\n  }\n\n  copy(from, to) {\n    return new Decoration(from, to, this.type)\n  }\n\n  eq(other, offset = 0) {\n    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to\n  }\n\n  map(mapping, offset, oldOffset) {\n    return this.type.map(mapping, this, offset, oldOffset)\n  }\n\n  // :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration\n  // Creates a widget decoration, which is a DOM node that's shown in\n  // the document at the given position. It is recommended that you\n  // delay rendering the widget by passing a function that will be\n  // called when the widget is actually drawn in a view, but you can\n  // also directly pass a DOM node. `getPos` can be used to find the\n  // widget's current document position.\n  //\n  //   spec::- These options are supported:\n  //\n  //     side:: ?number\n  //     Controls which side of the document position this widget is\n  //     associated with. When negative, it is drawn before a cursor\n  //     at its position, and content inserted at that position ends\n  //     up after the widget. When zero (the default) or positive, the\n  //     widget is drawn after the cursor and content inserted there\n  //     ends up before the widget.\n  //\n  //     When there are multiple widgets at a given position, their\n  //     `side` values determine the order in which they appear. Those\n  //     with lower values appear first. The ordering of widgets with\n  //     the same `side` value is unspecified.\n  //\n  //     When `marks` is null, `side` also determines the marks that\n  //     the widget is wrapped in—those of the node before when\n  //     negative, those of the node after when positive.\n  //\n  //     marks:: ?[Mark]\n  //     The precise set of marks to draw around the widget.\n  //\n  //     stopEvent:: ?(event: dom.Event) → bool\n  //     Can be used to control which DOM events, when they bubble out\n  //     of this widget, the editor view should ignore.\n  //\n  //     ignoreSelection:: ?bool\n  //     When set (defaults to false), selection changes inside the\n  //     widget are ignored, and don't cause ProseMirror to try and\n  //     re-sync the selection with its selection state.\n  //\n  //     key:: ?string\n  //     When comparing decorations of this type (in order to decide\n  //     whether it needs to be redrawn), ProseMirror will by default\n  //     compare the widget DOM node by identity. If you pass a key,\n  //     that key will be compared instead, which can be useful when\n  //     you generate decorations on the fly and don't want to store\n  //     and reuse DOM nodes. Make sure that any widgets with the same\n  //     key are interchangeable—if widgets differ in, for example,\n  //     the behavior of some event handler, they should get\n  //     different keys.\n  static widget(pos, toDOM, spec) {\n    return new Decoration(pos, pos, new WidgetType(toDOM, spec))\n  }\n\n  // :: (number, number, DecorationAttrs, ?Object) → Decoration\n  // Creates an inline decoration, which adds the given attributes to\n  // each inline node between `from` and `to`.\n  //\n  //   spec::- These options are recognized:\n  //\n  //     inclusiveStart:: ?bool\n  //     Determines how the left side of the decoration is\n  //     [mapped](#transform.Position_Mapping) when content is\n  //     inserted directly at that position. By default, the decoration\n  //     won't include the new content, but you can set this to `true`\n  //     to make it inclusive.\n  //\n  //     inclusiveEnd:: ?bool\n  //     Determines how the right side of the decoration is mapped.\n  //     See\n  //     [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).\n  static inline(from, to, attrs, spec) {\n    return new Decoration(from, to, new InlineType(attrs, spec))\n  }\n\n  // :: (number, number, DecorationAttrs, ?Object) → Decoration\n  // Creates a node decoration. `from` and `to` should point precisely\n  // before and after a node in the document. That node, and only that\n  // node, will receive the given attributes.\n  //\n  //   spec::-\n  //\n  //   Optional information to store with the decoration. It\n  //   is also used when comparing decorators for equality.\n  static node(from, to, attrs, spec) {\n    return new Decoration(from, to, new NodeType(attrs, spec))\n  }\n\n  // :: Object\n  // The spec provided when creating this decoration. Can be useful\n  // if you've stored extra information in that object.\n  get spec() { return this.type.spec }\n\n  get inline() { return this.type instanceof InlineType }\n}\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nconst none = [], noSpec = {}\n\n// :: class extends DecorationSource\n// A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nexport class DecorationSet {\n  constructor(local, children) {\n    this.local = local && local.length ? local : none\n    this.children = children && children.length ? children : none\n  }\n\n  // :: (Node, [Decoration]) → DecorationSet\n  // Create a set of decorations, using the structure of the given\n  // document.\n  static create(doc, decorations) {\n    return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty\n  }\n\n  // :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]\n  // Find all decorations in this set which touch the given range\n  // (including decorations that start or end directly at the\n  // boundaries) and match the given predicate on their spec. When\n  // `start` and `end` are omitted, all decorations in the set are\n  // considered. When `predicate` isn't given, all decorations are\n  // assumed to match.\n  find(start, end, predicate) {\n    let result = []\n    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate)\n    return result\n  }\n\n  findInner(start, end, result, offset, predicate) {\n    for (let i = 0; i < this.local.length; i++) {\n      let span = this.local[i]\n      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n        result.push(span.copy(span.from + offset, span.to + offset))\n    }\n    for (let i = 0; i < this.children.length; i += 3) {\n      if (this.children[i] < end && this.children[i + 1] > start) {\n        let childOff = this.children[i] + 1\n        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate)\n      }\n    }\n  }\n\n  // :: (Mapping, Node, ?Object) → DecorationSet\n  // Map the set of decorations in response to a change in the\n  // document.\n  //\n  //   options::- An optional set of options.\n  //\n  //     onRemove:: ?(decorationSpec: Object)\n  //     When given, this function will be called for each decoration\n  //     that gets dropped as a result of the mapping, passing the\n  //     spec of that decoration.\n  map(mapping, doc, options) {\n    if (this == empty || mapping.maps.length == 0) return this\n    return this.mapInner(mapping, doc, 0, 0, options || noSpec)\n  }\n\n  mapInner(mapping, node, offset, oldOffset, options) {\n    let newLocal\n    for (let i = 0; i < this.local.length; i++) {\n      let mapped = this.local[i].map(mapping, offset, oldOffset)\n      if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped)\n      else if (options.onRemove) options.onRemove(this.local[i].spec)\n    }\n\n    if (this.children.length)\n      return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options)\n    else\n      return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty\n  }\n\n  // :: (Node, [Decoration]) → DecorationSet\n  // Add the given array of decorations to the ones in the set,\n  // producing a new set. Needs access to the current document to\n  // create the appropriate tree structure.\n  add(doc, decorations) {\n    if (!decorations.length) return this\n    if (this == empty) return DecorationSet.create(doc, decorations)\n    return this.addInner(doc, decorations, 0)\n  }\n\n  addInner(doc, decorations, offset) {\n    let children, childIndex = 0\n    doc.forEach((childNode, childOffset) => {\n      let baseOffset = childOffset + offset, found\n      if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return\n\n      if (!children) children = this.children.slice()\n      while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3\n      if (children[childIndex] == childOffset)\n        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1)\n      else\n        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec))\n      childIndex += 3\n    })\n\n    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset)\n    for (let i = 0; i < local.length; i++) if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1)\n\n    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                             children || this.children)\n  }\n\n  // :: ([Decoration]) → DecorationSet\n  // Create a new set that contains the decorations in this set, minus\n  // the ones in the given array.\n  remove(decorations) {\n    if (decorations.length == 0 || this == empty) return this\n    return this.removeInner(decorations, 0)\n  }\n\n  removeInner(decorations, offset) {\n    let children = this.children, local = this.local\n    for (let i = 0; i < children.length; i += 3) {\n      let found, from = children[i] + offset, to = children[i + 1] + offset\n      for (let j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {\n        if (span.from > from && span.to < to) {\n          decorations[j] = null\n          ;(found || (found = [])).push(span)\n        }\n      }\n      if (!found) continue\n      if (children == this.children) children = this.children.slice()\n      let removed = children[i + 2].removeInner(found, from + 1)\n      if (removed != empty) {\n        children[i + 2] = removed\n      } else {\n        children.splice(i, 3)\n        i -= 3\n      }\n    }\n    if (local.length) for (let i = 0, span; i < decorations.length; i++) if (span = decorations[i]) {\n      for (let j = 0; j < local.length; j++) if (local[j].eq(span, offset)) {\n        if (local == this.local) local = this.local.slice()\n        local.splice(j--, 1)\n      }\n    }\n    if (children == this.children && local == this.local) return this\n    return local.length || children.length ? new DecorationSet(local, children) : empty\n  }\n\n  forChild(offset, node) {\n    if (this == empty) return this\n    if (node.isLeaf) return DecorationSet.empty\n\n    let child, local\n    for (let i = 0; i < this.children.length; i += 3) if (this.children[i] >= offset) {\n      if (this.children[i] == offset) child = this.children[i + 2]\n      break\n    }\n    let start = offset + 1, end = start + node.content.size\n    for (let i = 0; i < this.local.length; i++) {\n      let dec = this.local[i]\n      if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start\n        if (from < to) (local || (local = [])).push(dec.copy(from, to))\n      }\n    }\n    if (local) {\n      let localSet = new DecorationSet(local.sort(byPos))\n      return child ? new DecorationGroup([localSet, child]) : localSet\n    }\n    return child || empty\n  }\n\n  eq(other) {\n    if (this == other) return true\n    if (!(other instanceof DecorationSet) ||\n        this.local.length != other.local.length ||\n        this.children.length != other.children.length) return false\n    for (let i = 0; i < this.local.length; i++)\n      if (!this.local[i].eq(other.local[i])) return false\n    for (let i = 0; i < this.children.length; i += 3)\n      if (this.children[i] != other.children[i] ||\n          this.children[i + 1] != other.children[i + 1] ||\n          !this.children[i + 2].eq(other.children[i + 2])) return false\n    return true\n  }\n\n  locals(node) {\n    return removeOverlap(this.localsInner(node))\n  }\n\n  localsInner(node) {\n    if (this == empty) return none\n    if (node.inlineContent || !this.local.some(InlineType.is)) return this.local\n    let result = []\n    for (let i = 0; i < this.local.length; i++) {\n      if (!(this.local[i].type instanceof InlineType))\n        result.push(this.local[i])\n    }\n    return result\n  }\n}\n\n// DecorationSource:: interface\n// An object that can [provide](#view.EditorProps.decorations)\n// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),\n// and passed to [node views](#view.EditorProps.nodeViews).\n\nconst empty = new DecorationSet()\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty\n\nDecorationSet.removeOverlap = removeOverlap\n\n// :- An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n  constructor(members) {\n    this.members = members\n  }\n\n  forChild(offset, child) {\n    if (child.isLeaf) return DecorationSet.empty\n    let found = []\n    for (let i = 0; i < this.members.length; i++) {\n      let result = this.members[i].forChild(offset, child)\n      if (result == empty) continue\n      if (result instanceof DecorationGroup) found = found.concat(result.members)\n      else found.push(result)\n    }\n    return DecorationGroup.from(found)\n  }\n\n  eq(other) {\n    if (!(other instanceof DecorationGroup) ||\n        other.members.length != this.members.length) return false\n    for (let i = 0; i < this.members.length; i++)\n      if (!this.members[i].eq(other.members[i])) return false\n    return true\n  }\n\n  locals(node) {\n    let result, sorted = true\n    for (let i = 0; i < this.members.length; i++) {\n      let locals = this.members[i].localsInner(node)\n      if (!locals.length) continue\n      if (!result) {\n        result = locals\n      } else {\n        if (sorted) {\n          result = result.slice()\n          sorted = false\n        }\n        for (let j = 0; j < locals.length; j++) result.push(locals[j])\n      }\n    }\n    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n  }\n\n  // : ([DecorationSet]) → union<DecorationSet, DecorationGroup>\n  // Create a group for the given array of decoration sets, or return\n  // a single set when possible.\n  static from(members) {\n    switch (members.length) {\n      case 0: return empty\n      case 1: return members[0]\n      default: return new DecorationGroup(members)\n    }\n  }\n}\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  let children = oldChildren.slice()\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  let shift = (oldStart, oldEnd, newStart, newEnd) => {\n    for (let i = 0; i < children.length; i += 3) {\n      let end = children[i + 1], dSize\n      if (end == -1 || oldStart > end + oldOffset) continue\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1\n      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {\n        children[i] += dSize\n        children[i + 1] += dSize\n      }\n    }\n  }\n  for (let i = 0; i < mapping.maps.length; i++) mapping.maps[i].forEach(shift)\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  let mustRebuild = false\n  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1) { // Touched nodes\n    let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset\n    let {index, offset: childOffset} = node.content.findIndex(fromLocal)\n    let childNode = node.maybeChild(index)\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options)\n      if (mapped != empty) {\n        children[i] = fromLocal\n        children[i + 1] = toLocal\n        children[i + 2] = mapped\n      } else {\n        children[i + 1] = -2\n        mustRebuild = true\n      }\n    } else {\n      mustRebuild = true\n    }\n  }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,\n                                                       offset, oldOffset, options)\n    let built = buildTree(decorations, node, 0, options)\n    newLocal = built.local\n    for (let i = 0; i < children.length; i += 3) if (children[i + 1] < 0) {\n      children.splice(i, 3)\n      i -= 3\n    }\n    for (let i = 0, j = 0; i < built.children.length; i += 3) {\n      let from = built.children[i]\n      while (j < children.length && children[j] < from) j += 3\n      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2])\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) return spans\n  let result = []\n  for (let i = 0; i < spans.length; i++) {\n    let span = spans[i]\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type))\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (let i = 0; i < set.local.length; i++) {\n      let mapped = set.local[i].map(mapping, offset, oldOffset)\n      if (mapped) decorations.push(mapped)\n      else if (options.onRemove) options.onRemove(set.local[i].spec)\n    }\n    for (let i = 0; i < set.children.length; i += 3)\n      gather(set.children[i + 2], set.children[i] + oldOffset + 1)\n  }\n  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1)\n    gather(children[i + 2], oldChildren[i] + oldOffset + 1)\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) return null\n  let end = offset + node.nodeSize, found = null\n  for (let i = 0, span; i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      ;(found || (found = [])).push(span)\n      spans[i] = null\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  let result = []\n  for (let i = 0; i < array.length; i++)\n    if (array[i] != null) result.push(array[i])\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtractet from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  let children = [], hasNulls = false\n  node.forEach((childNode, localStart) => {\n    let found = takeSpansForNode(spans, childNode, localStart + offset)\n    if (found) {\n      hasNulls = true\n      let subtree = buildTree(found, childNode, offset + localStart + 1, options)\n      if (subtree != empty)\n        children.push(localStart, localStart + childNode.nodeSize, subtree)\n    }\n  })\n  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos)\n  for (let i = 0; i < locals.length; i++) if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) options.onRemove(locals[i].spec)\n    locals.splice(i--, 1)\n  }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decoration]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  let working = spans\n  for (let i = 0; i < working.length - 1; i++) {\n    let span = working[i]\n    if (span.from != span.to) for (let j = i + 1; j < working.length; j++) {\n      let next = working[j]\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) working = spans.slice()\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to)\n          insertAhead(working, j + 1, next.copy(span.to, next.to))\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) working = spans.slice()\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from)\n          insertAhead(working, j, span.copy(next.from, span.to))\n        }\n        break\n      }\n    }\n  }\n  return working\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) i++\n  array.splice(i, 0, deco)\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nexport function viewDecorations(view) {\n  let found = []\n  view.someProp(\"decorations\", f => {\n    let result = f(view.state)\n    if (result && result != empty) found.push(result)\n  })\n  if (view.cursorWrapper)\n    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]))\n  return DecorationGroup.from(found)\n}\n","import {NodeSelection} from \"prosemirror-state\"\n\nimport {scrollRectIntoView, posAtCoords, coordsAtPos, endOfTextblock, storeScrollPos,\n        resetScrollPos, focusPreventScroll} from \"./domcoords\"\nimport {docViewDesc} from \"./viewdesc\"\nimport {initInput, destroyInput, dispatchEvent, ensureListeners, clearComposition} from \"./input\"\nimport {selectionToDOM, anchorInRightPlace, syncNodeSelection} from \"./selection\"\nimport {Decoration, viewDecorations} from \"./decoration\"\nimport browser from \"./browser\"\n\nexport {Decoration, DecorationSet} from \"./decoration\"\n\n// Exported for testing\nexport {serializeForClipboard as __serializeForClipboard, parseFromClipboard as __parseFromClipboard} from \"./clipboard\"\nexport {endComposition as __endComposition} from \"./input\"\n\n// ::- An editor view manages the DOM structure that represents an\n// editable document. Its state and behavior are determined by its\n// [props](#view.DirectEditorProps).\nexport class EditorView {\n  // :: (?union<dom.Node, (dom.Node), {mount: dom.Node}>, DirectEditorProps)\n  // Create a view. `place` may be a DOM node that the editor should\n  // be appended to, a function that will place it into the document,\n  // or an object whose `mount` property holds the node to use as the\n  // document container. If it is `null`, the editor will not be added\n  // to the document.\n  constructor(place, props) {\n    this._props = props\n    // :: EditorState\n    // The view's current [state](#state.EditorState).\n    this.state = props.state\n\n    this.dispatch = this.dispatch.bind(this)\n\n    this._root = null\n    this.focused = false\n    // Kludge used to work around a Chrome bug\n    this.trackWrites = null\n\n    // :: dom.Element\n    // An editable DOM node containing the document. (You probably\n    // should not directly interfere with its content.)\n    this.dom = (place && place.mount) || document.createElement(\"div\")\n    if (place) {\n      if (place.appendChild) place.appendChild(this.dom)\n      else if (place.apply) place(this.dom)\n      else if (place.mount) this.mounted = true\n    }\n\n    // :: bool\n    // Indicates whether the editor is currently [editable](#view.EditorProps.editable).\n    this.editable = getEditable(this)\n    this.markCursor = null\n    this.cursorWrapper = null\n    updateCursorWrapper(this)\n    this.nodeViews = buildNodeViews(this)\n    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this)\n\n    this.lastSelectedViewDesc = null\n    // :: ?{slice: Slice, move: bool}\n    // When editor content is being dragged, this object contains\n    // information about the dragged slice and whether it is being\n    // copied or moved. At any other time, it is null.\n    this.dragging = null\n\n    initInput(this)\n\n    this.pluginViews = []\n    this.updatePluginViews()\n  }\n\n  // composing:: boolean\n  // Holds `true` when a\n  // [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)\n  // is active.\n\n  // :: DirectEditorProps\n  // The view's current [props](#view.EditorProps).\n  get props() {\n    if (this._props.state != this.state) {\n      let prev = this._props\n      this._props = {}\n      for (let name in prev) this._props[name] = prev[name]\n      this._props.state = this.state\n    }\n    return this._props\n  }\n\n  // :: (DirectEditorProps)\n  // Update the view's props. Will immediately cause an update to\n  // the DOM.\n  update(props) {\n    if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this)\n    this._props = props\n    this.updateStateInner(props.state, true)\n  }\n\n  // :: (DirectEditorProps)\n  // Update the view by updating existing props object with the object\n  // given as argument. Equivalent to `view.update(Object.assign({},\n  // view.props, props))`.\n  setProps(props) {\n    let updated = {}\n    for (let name in this._props) updated[name] = this._props[name]\n    updated.state = this.state\n    for (let name in props) updated[name] = props[name]\n    this.update(updated)\n  }\n\n  // :: (EditorState)\n  // Update the editor's `state` prop, without touching any of the\n  // other props.\n  updateState(state) {\n    this.updateStateInner(state, this.state.plugins != state.plugins)\n  }\n\n  updateStateInner(state, reconfigured) {\n    let prev = this.state, redraw = false, updateSel = false\n    // When stored marks are added, stop composition, so that they can\n    // be displayed.\n    if (state.storedMarks && this.composing) {\n      clearComposition(this)\n      updateSel = true\n    }\n    this.state = state\n    if (reconfigured) {\n      let nodeViews = buildNodeViews(this)\n      if (changedNodeViews(nodeViews, this.nodeViews)) {\n        this.nodeViews = nodeViews\n        redraw = true\n      }\n      ensureListeners(this)\n    }\n\n    this.editable = getEditable(this)\n    updateCursorWrapper(this)\n    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this)\n\n    let scroll = reconfigured ? \"reset\"\n        : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\"\n    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco)\n    if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true\n    let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this)\n\n    if (updateSel) {\n      this.domObserver.stop()\n      // Work around an issue in Chrome, IE, and Edge where changing\n      // the DOM around an active selection puts it into a broken\n      // state where the thing the user sees differs from the\n      // selection reported by the Selection object (#710, #973,\n      // #1011, #1013, #1035).\n      let forceSelUpdate = updateDoc && (browser.ie || browser.chrome) && !this.composing &&\n          !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection)\n      if (updateDoc) {\n        // If the node that the selection points into is written to,\n        // Chrome sometimes starts misreporting the selection, so this\n        // tracks that and forces a selection reset when our update\n        // did write to the node.\n        let chromeKludge = browser.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null\n        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n          this.docView.updateOuterDeco([])\n          this.docView.destroy()\n          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this)\n        }\n        if (chromeKludge && !this.trackWrites) forceSelUpdate = true\n      }\n      // Work around for an issue where an update arriving right between\n      // a DOM selection change and the \"selectionchange\" event for it\n      // can cause a spurious DOM selection update, disrupting mouse\n      // drag selection.\n      if (forceSelUpdate ||\n          !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {\n        selectionToDOM(this, forceSelUpdate)\n      } else {\n        syncNodeSelection(this, state.selection)\n        this.domObserver.setCurSelection()\n      }\n      this.domObserver.start()\n    }\n\n    this.updatePluginViews(prev)\n\n    if (scroll == \"reset\") {\n      this.dom.scrollTop = 0\n    } else if (scroll == \"to selection\") {\n      let startDOM = this.root.getSelection().focusNode\n      if (this.someProp(\"handleScrollToSelection\", f => f(this)))\n        {} // Handled\n      else if (state.selection instanceof NodeSelection)\n        scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM)\n      else\n        scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM)\n    } else if (oldScrollPos) {\n      resetScrollPos(oldScrollPos)\n    }\n  }\n\n  destroyPluginViews() {\n    let view\n    while (view = this.pluginViews.pop()) if (view.destroy) view.destroy()\n  }\n\n  updatePluginViews(prevState) {\n    if (!prevState || prevState.plugins != this.state.plugins) {\n      this.destroyPluginViews()\n      for (let i = 0; i < this.state.plugins.length; i++) {\n        let plugin = this.state.plugins[i]\n        if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this))\n      }\n    } else {\n      for (let i = 0; i < this.pluginViews.length; i++) {\n        let pluginView = this.pluginViews[i]\n        if (pluginView.update) pluginView.update(this, prevState)\n      }\n    }\n  }\n\n  // :: (string, ?(prop: *) → *) → *\n  // Goes over the values of a prop, first those provided directly,\n  // then those from plugins (in order), and calls `f` every time a\n  // non-undefined value is found. When `f` returns a truthy value,\n  // that is immediately returned. When `f` isn't provided, it is\n  // treated as the identity function (the prop value is returned\n  // directly).\n  someProp(propName, f) {\n    let prop = this._props && this._props[propName], value\n    if (prop != null && (value = f ? f(prop) : prop)) return value\n    let plugins = this.state.plugins\n    if (plugins) for (let i = 0; i < plugins.length; i++) {\n      let prop = plugins[i].props[propName]\n      if (prop != null && (value = f ? f(prop) : prop)) return value\n    }\n  }\n\n  // :: () → bool\n  // Query whether the view has focus.\n  hasFocus() {\n    return this.root.activeElement == this.dom\n  }\n\n  // :: ()\n  // Focus the editor.\n  focus() {\n    this.domObserver.stop()\n    if (this.editable) focusPreventScroll(this.dom)\n    selectionToDOM(this)\n    this.domObserver.start()\n  }\n\n  // :: union<dom.Document, dom.DocumentFragment>\n  // Get the document root in which the editor exists. This will\n  // usually be the top-level `document`, but might be a [shadow\n  // DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n  // root if the editor is inside one.\n  get root() {\n    let cached = this._root\n    if (cached == null) for (let search = this.dom.parentNode; search; search = search.parentNode) {\n      if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n        if (!search.getSelection) Object.getPrototypeOf(search).getSelection = () => document.getSelection()\n        return this._root = search\n      }\n    }\n    return cached || document\n  }\n\n  // :: ({left: number, top: number}) → ?{pos: number, inside: number}\n  // Given a pair of viewport coordinates, return the document\n  // position that corresponds to them. May return null if the given\n  // coordinates aren't inside of the editor. When an object is\n  // returned, its `pos` property is the position nearest to the\n  // coordinates, and its `inside` property holds the position of the\n  // inner node that the position falls inside of, or -1 if it is at\n  // the top level, not in any node.\n  posAtCoords(coords) {\n    return posAtCoords(this, coords)\n  }\n\n  // :: (number, number) → {left: number, right: number, top: number, bottom: number}\n  // Returns the viewport rectangle at a given document position.\n  // `left` and `right` will be the same number, as this returns a\n  // flat cursor-ish rectangle. If the position is between two things\n  // that aren't directly adjacent, `side` determines which element is\n  // used. When < 0, the element before the position is used,\n  // otherwise the element after.\n  coordsAtPos(pos, side = 1) {\n    return coordsAtPos(this, pos, side)\n  }\n\n  // :: (number, number) → {node: dom.Node, offset: number}\n  // Find the DOM position that corresponds to the given document\n  // position. When `side` is negative, find the position as close as\n  // possible to the content before the position. When positive,\n  // prefer positions close to the content after the position. When\n  // zero, prefer as shallow a position as possible.\n  //\n  // Note that you should **not** mutate the editor's internal DOM,\n  // only inspect it (and even that is usually not necessary).\n  domAtPos(pos, side = 0) {\n    return this.docView.domFromPos(pos, side)\n  }\n\n  // :: (number) → ?dom.Node\n  // Find the DOM node that represents the document node after the\n  // given position. May return `null` when the position doesn't point\n  // in front of a node or if the node is inside an opaque node view.\n  //\n  // This is intended to be able to call things like\n  // `getBoundingClientRect` on that DOM node. Do **not** mutate the\n  // editor DOM directly, or add styling this way, since that will be\n  // immediately overriden by the editor as it redraws the node.\n  nodeDOM(pos) {\n    let desc = this.docView.descAt(pos)\n    return desc ? desc.nodeDOM : null\n  }\n\n  // :: (dom.Node, number, ?number) → number\n  // Find the document position that corresponds to a given DOM\n  // position. (Whenever possible, it is preferable to inspect the\n  // document structure directly, rather than poking around in the\n  // DOM, but sometimes—for example when interpreting an event\n  // target—you don't have a choice.)\n  //\n  // The `bias` parameter can be used to influence which side of a DOM\n  // node to use when the position is inside a leaf node.\n  posAtDOM(node, offset, bias = -1) {\n    let pos = this.docView.posFromDOM(node, offset, bias)\n    if (pos == null) throw new RangeError(\"DOM position not inside the editor\")\n    return pos\n  }\n\n  // :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n  // Find out whether the selection is at the end of a textblock when\n  // moving in a given direction. When, for example, given `\"left\"`,\n  // it will return true if moving left from the current cursor\n  // position would leave that position's parent textblock. Will apply\n  // to the view's current state by default, but it is possible to\n  // pass a different state.\n  endOfTextblock(dir, state) {\n    return endOfTextblock(this, state || this.state, dir)\n  }\n\n  // :: ()\n  // Removes the editor from the DOM and destroys all [node\n  // views](#view.NodeView).\n  destroy() {\n    if (!this.docView) return\n    destroyInput(this)\n    this.destroyPluginViews()\n    if (this.mounted) {\n      this.docView.update(this.state.doc, [], viewDecorations(this), this)\n      this.dom.textContent = \"\"\n    } else if (this.dom.parentNode) {\n      this.dom.parentNode.removeChild(this.dom)\n    }\n    this.docView.destroy()\n    this.docView = null\n  }\n\n  // Used for testing.\n  dispatchEvent(event) {\n    return dispatchEvent(this, event)\n  }\n\n  // :: (Transaction)\n  // Dispatch a transaction. Will call\n  // [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)\n  // when given, and otherwise defaults to applying the transaction to\n  // the current state and calling\n  // [`updateState`](#view.EditorView.updateState) with the result.\n  // This method is bound to the view instance, so that it can be\n  // easily passed around.\n  dispatch(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction\n    if (dispatchTransaction) dispatchTransaction.call(this, tr)\n    else this.updateState(this.state.apply(tr))\n  }\n}\n\nfunction computeDocDeco(view) {\n  let attrs = Object.create(null)\n  attrs.class = \"ProseMirror\"\n  attrs.contenteditable = String(view.editable)\n\n  view.someProp(\"attributes\", value => {\n    if (typeof value == \"function\") value = value(view.state)\n    if (value) for (let attr in value) {\n      if (attr == \"class\")\n        attrs.class += \" \" + value[attr]\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        attrs[attr] = String(value[attr])\n    }\n  })\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    let dom = document.createElement(\"img\")\n    dom.setAttribute(\"mark-placeholder\", \"true\")\n    view.cursorWrapper = {dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})}\n  } else {\n    view.cursorWrapper = null\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", value => value(view.state) === false)\n}\n\nfunction selectionContextChanged(sel1, sel2) {\n  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head))\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)\n}\n\nfunction buildNodeViews(view) {\n  let result = {}\n  view.someProp(\"nodeViews\", obj => {\n    for (let prop in obj) if (!Object.prototype.hasOwnProperty.call(result, prop))\n      result[prop] = obj[prop]\n  })\n  return result\n}\n\nfunction changedNodeViews(a, b) {\n  let nA = 0, nB = 0\n  for (let prop in a) {\n    if (a[prop] != b[prop]) return true\n    nA++\n  }\n  for (let _ in b) nB++\n  return nA != nB\n}\n\n// EditorProps:: interface\n//\n// Props are configuration values that can be passed to an editor view\n// or included in a plugin. This interface lists the supported props.\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// How a prop is resolved depends on the prop. Handler functions are\n// called one at a time, starting with the base props and then\n// searching through the plugins (in order of appearance) until one of\n// them returns true. For some props, the first plugin that yields a\n// value gets precedence.\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   behavior of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool\n//   Can be used to override the behavior of pasting. `slice` is the\n//   pasted content parsed by the editor, but you can directly access\n//   the event to get at the raw content.\n//\n//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool\n//   Called when something is dropped on the editor. `moved` will be\n//   true if this drop moves from the current selection (which should\n//   thus be deleted).\n//\n//   handleScrollToSelection:: ?(view: EditorView) → bool\n//   Called when the view, after updating its state, tries to scroll\n//   the selection into view. A handler function may return false to\n//   indicate that it did not handle the scrolling and further\n//   handlers or the default behavior should be tried.\n//\n//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection\n//   Can be used to override the way a selection is created when\n//   reading a DOM selection between the given anchor and head.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   transformPastedHTML:: ?(html: string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPastedText:: ?(text: string, plain: bool) → string\n//   Transform pasted plain text. The `plain` flag will be true when\n//   the text is pasted as plain text.\n//\n//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice\n//   A function to parse text from the clipboard into a document\n//   slice. Called after\n//   [`transformPastedText`](#view.EditorProps.transformPastedText).\n//   The default behavior is to split the text into lines, wrap them\n//   in `<p>` tags, and call\n//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.\n//   The `plain` flag will be true when the text is pasted as plain text.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor\n//   functions that produce a [`NodeView`](#view.NodeView) object\n//   implementing the node's display behavior. For nodes, the third\n//   argument `getPos` is a function that can be called to get the\n//   node's current position, which can be useful when creating\n//   transactions to update it. For marks, the third argument is a\n//   boolean that indicates whether the mark's content is inline.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   `innerDecorations` holds the decorations for the node's content.\n//   You can safely ignore this if your view has no content or a\n//   `contentDOM` property, since the editor will draw the decorations\n//   on the content. But if you, for example, want to create a nested\n//   editor with the content, it may make sense to provide it with the\n//   inner decorations.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used.\n//\n//   clipboardTextSerializer:: ?(Slice) → string\n//   A function that will be called to get the text for the current\n//   selection when copying text to the clipboard. By default, the\n//   editor will use [`textBetween`](#model.Node.textBetween) on the\n//   selected range.\n//\n//   decorations:: ?(state: EditorState) → ?DecorationSource\n//   A set of [document decorations](#view.Decoration) to show in the\n//   view.\n//\n//   editable:: ?(state: EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n// DirectEditorProps:: interface extends EditorProps\n//\n// The props object given directly to the editor view supports two\n// fields that can't be used in plugins:\n//\n//   state:: EditorState\n//   The current state of the editor.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. If you specify this, you probably want to\n//   make sure this ends up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply). The callback will be bound to have\n//   the view instance as its `this` binding.\n","import { NodeType, Schema } from 'prosemirror-model'\n\nexport default function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType, Schema } from 'prosemirror-model'\n\nexport default function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { EditorState } from 'prosemirror-state'\nimport { Mark, MarkType } from 'prosemirror-model'\nimport getMarkType from './getMarkType'\n\nexport default function getMarkAttributes(state: EditorState, typeOrName: string | MarkType): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  let marks: Mark[] = []\n\n  if (empty) {\n    marks = state.selection.$head.marks()\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks = [...marks, ...node.marks]\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (mark) {\n    return { ...mark.attrs }\n  }\n\n  return {}\n}\n","/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport default function objectIncludes(object1: Record<string, any>, object2: Record<string, any>): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return !!keys\n    .filter(key => object2[key] === object1[key])\n    .length\n}\n","import { EditorState } from 'prosemirror-state'\nimport { NodeType } from 'prosemirror-model'\nimport objectIncludes from '../utilities/objectIncludes'\nimport getNodeType from './getNodeType'\nimport { NodeRange } from '../types'\n\nexport default function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName\n    ? getNodeType(typeOrName, state.schema)\n    : null\n\n  let nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isText) {\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n\n      nodeRanges = [...nodeRanges, {\n        node,\n        from: relativeFrom,\n        to: relativeTo,\n      }]\n    }\n  })\n\n  if (empty) {\n    return !!nodeRanges\n      .filter(nodeRange => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === nodeRange.node.type.name\n      })\n      .find(nodeRange => objectIncludes(nodeRange.node.attrs, attributes))\n  }\n\n  const selectionRange = to - from\n\n  const range = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes))\n    .reduce((sum, nodeRange) => {\n      const size = nodeRange.to - nodeRange.from\n      return sum + size\n    }, 0)\n\n  return range >= selectionRange\n}\n","import { EditorState } from 'prosemirror-state'\nimport { MarkType } from 'prosemirror-model'\nimport objectIncludes from '../utilities/objectIncludes'\nimport getMarkType from './getMarkType'\nimport { MarkRange } from '../types'\n\nexport default function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName\n    ? getMarkType(typeOrName, state.schema)\n    : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes))\n  }\n\n  let selectionRange = 0\n  let markRanges: MarkRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges = [...markRanges, ...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo,\n      }))]\n    }\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  const range = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes))\n    .reduce((sum, markRange) => {\n      const size = markRange.to - markRange.from\n      return sum + size\n    }, 0)\n\n  return range >= selectionRange\n}\n","import { Schema } from 'prosemirror-model'\n\nexport default function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","import { EditorState } from 'prosemirror-state'\nimport isNodeActive from './isNodeActive'\nimport isMarkActive from './isMarkActive'\nimport getSchemaTypeNameByName from './getSchemaTypeNameByName'\n\nexport default function isActive(state: EditorState, name: string | null, attributes: Record<string, any> = {}): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","export default function elementFromString(value: string): HTMLElement {\n  return new window.DOMParser().parseFromString(value, 'text/html').body\n}\n","import {\n  Schema,\n  DOMParser,\n  Node as ProseMirrorNode,\n  Fragment,\n} from 'prosemirror-model'\nimport elementFromString from '../utilities/elementFromString'\nimport { Content } from '../types'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean,\n  parseOptions?: Record<string, any>,\n}\n\nexport default function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): string | ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (content && typeof content === 'object') {\n    try {\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn(\n        '[tiptap warn]: Invalid content.',\n        'Passed value:',\n        content,\n        'Error:',\n        error,\n      )\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const isHTML = content.trim().startsWith('<') && content.trim().endsWith('>')\n\n    if (isHTML || !options.slice) {\n      const parser = DOMParser.fromSchema(schema)\n\n      return options.slice\n        ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n        : parser.parse(elementFromString(content), options.parseOptions)\n    }\n\n    return content\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Schema, Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Content } from '../types'\nimport createNodeFromContent from './createNodeFromContent'\n\nexport default function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: Record<string, any> = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { Node, DOMSerializer, Schema } from 'prosemirror-model'\n\nexport default function getHTMLFromFragment(doc: Node, schema: Schema): string {\n  const fragment = DOMSerializer\n    .fromSchema(schema)\n    .serializeFragment(doc.content)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n  container.appendChild(fragment)\n\n  return container.innerHTML\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nexport default function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","import { EditorState, Transaction } from 'prosemirror-state'\nimport { Editor } from './Editor'\nimport {\n  SingleCommands,\n  ChainedCommands,\n  CanCommands,\n  RawCommands,\n  CommandProps,\n} from './types'\n\nexport default class CommandManager {\n\n  editor: Editor\n\n  commands: RawCommands\n\n  constructor(editor: Editor, commands: RawCommands) {\n    this.editor = editor\n    this.commands = commands\n  }\n\n  public createCommands(): SingleCommands {\n    const { commands, editor } = this\n    const { state, view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(Object\n      .entries(commands)\n      .map(([name, command]) => {\n        const method = (...args: any) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch')) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      })) as SingleCommands\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { commands, editor } = this\n    const { state, view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch')) {\n        view.dispatch(tr)\n      }\n\n      return () => callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(Object.entries(commands).map(([name, command]) => {\n        const chainedCommand = (...args: any[]) => {\n          const props = this.buildProps(tr, shouldDispatch)\n          const callback = command(...args)(props)\n\n          callbacks.push(callback)\n\n          return chain\n        }\n\n        return [name, chainedCommand]\n      })),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { commands, editor } = this\n    const { state } = editor\n    const dispatch = undefined\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(Object\n      .entries(commands)\n      .map(([name, command]) => {\n        return [name, (...args: any[]) => command(...args)({ ...props, dispatch })]\n      })) as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { editor, commands } = this\n    const { state, view } = editor\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks)\n    }\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: this.chainableState(tr, state),\n      dispatch: shouldDispatch\n        ? () => undefined\n        : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object\n          .entries(commands)\n          .map(([name, command]) => {\n            return [name, (...args: any[]) => command(...args)(props)]\n          })) as SingleCommands\n      },\n    }\n\n    return props\n  }\n\n  public chainableState(tr: Transaction, state: EditorState): EditorState {\n    let { selection } = tr\n    let { doc } = tr\n    let { storedMarks } = tr\n\n    return {\n      ...state,\n      schema: state.schema,\n      plugins: state.plugins,\n      apply: state.apply.bind(state),\n      applyTransaction: state.applyTransaction.bind(state),\n      reconfigure: state.reconfigure.bind(state),\n      toJSON: state.toJSON.bind(state),\n      get storedMarks() {\n        return storedMarks\n      },\n      get selection() {\n        return selection\n      },\n      get doc() {\n        return doc\n      },\n      get tr() {\n        selection = tr.selection\n        doc = tr.doc\n        storedMarks = tr.storedMarks\n\n        return tr\n      },\n    }\n  }\n\n}\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","import {base, keyName} from \"w3c-keyname\"\nimport {Plugin} from \"prosemirror-state\"\n\n// declare global: navigator\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") result = \" \"\n  let alt, ctrl, shift, meta\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true\n    else if (/^a(lt)?$/i.test(mod)) alt = true\n    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n    else if (/^s(hift)?$/i.test(mod)) shift = true\n    else if (/^mod$/i.test(mod)) { if (mac) meta = true; else ctrl = true }\n    else throw new Error(\"Unrecognized modifier name: \" + mod)\n  }\n  if (alt) result = \"Alt-\" + result\n  if (ctrl) result = \"Ctrl-\" + result\n  if (meta) result = \"Meta-\" + result\n  if (shift) result = \"Shift-\" + result\n  return result\n}\n\nfunction normalize(map) {\n  let copy = Object.create(null)\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop]\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name\n  if (event.ctrlKey) name = \"Ctrl-\" + name\n  if (event.metaKey) name = \"Meta-\" + name\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nexport function keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nexport function keydownHandler(bindings) {\n  let map = normalize(bindings)\n  return function(view, event) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n    let direct = map[modifiers(name, event, !isChar)]\n    if (direct && direct(view.state, view.dispatch, view)) return true\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      let fromCode = map[modifiers(baseName, event, true)]\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      let withShift = map[modifiers(name, event, true)]\n      if (withShift && withShift(view.state, view.dispatch, view)) return true\n    }\n    return false\n  }\n}\n","import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n","import { AnyExtension, RemoveThis } from '../types'\n\nexport default function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context: Record<string, any> = {},\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extensions } from '../types'\nimport { Extension } from '../Extension'\nimport { Node } from '../Node'\nimport { Mark } from '../Mark'\n\nexport default function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import splitExtensions from './splitExtensions'\nimport getExtensionField from './getExtensionField'\nimport {\n  Extensions,\n  GlobalAttributes,\n  Attributes,\n  Attribute,\n  ExtensionAttribute,\n  AnyConfig,\n} from '../types'\nimport { NodeConfig, MarkConfig } from '..'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport default function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: {\n            ...defaultAttribute,\n            ...attribute,\n          },\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","export default function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n          return\n        }\n\n        if (key === 'class') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Node, Mark } from 'prosemirror-model'\nimport { ExtensionAttribute } from '../types'\nimport mergeAttributes from '../utilities/mergeAttributes'\n\nexport default function getRenderedAttributes(nodeOrMark: Node | Mark, extensionAttributes: ExtensionAttribute[]): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => {\n      return mergeAttributes(attributes, attribute)\n    }, {})\n}\n","import { ParseRule } from 'prosemirror-model'\nimport { ExtensionAttribute } from '../types'\nimport fromString from '../utilities/fromString'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport default function injectExtensionAttributesToParseRule(parseRule: ParseRule, extensionAttributes: ExtensionAttribute[]): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs\n        ? parseRule.getAttrs(node)\n        : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes\n        .filter(item => item.attribute.rendered)\n        .reduce((items, item) => {\n          const attributes = item.attribute.parseHTML\n            ? item.attribute.parseHTML(node as HTMLElement) || {}\n            : {\n              [item.name]: fromString((node as HTMLElement).getAttribute(item.name)),\n            }\n\n          const filteredAttributes = Object.fromEntries(Object.entries(attributes)\n            .filter(([, value]) => value !== undefined && value !== null))\n\n          return {\n            ...items,\n            ...filteredAttributes,\n          }\n        }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","export default function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^\\d*(\\.\\d+)?$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { MaybeReturnType } from '../types'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport default function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (typeof value === 'function') {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","import { NodeSpec, MarkSpec, Schema } from 'prosemirror-model'\nimport { AnyConfig, Extensions } from '../types'\nimport { NodeConfig, MarkConfig } from '..'\nimport splitExtensions from './splitExtensions'\nimport getAttributesFromExtensions from './getAttributesFromExtensions'\nimport getRenderedAttributes from './getRenderedAttributes'\nimport isEmptyObject from '../utilities/isEmptyObject'\nimport injectExtensionAttributesToParseRule from './injectExtensionAttributesToParseRule'\nimport callOrReturn from '../utilities/callOrReturn'\nimport getExtensionField from './getExtensionField'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false\n    }\n\n    return value !== null && value !== undefined\n  })) as T\n}\n\nexport default function getSchema(extensions: Extensions): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n        e,\n        'extendNodeSchema',\n        context,\n      )\n\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n      }\n    }, {})\n\n    const schema: NodeSpec = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField<NodeConfig['content']>(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField<NodeConfig['defining']>(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n      })),\n    })\n\n    const parseHTML = callOrReturn(getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context))\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML\n        .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n    }\n\n    const renderHTML = getExtensionField<NodeConfig['renderHTML']>(extension, 'renderHTML', context)\n\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n      })\n    }\n\n    return [extension.name, schema]\n  }))\n\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n        e,\n        'extendMarkSchema',\n        context,\n      )\n\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n      }\n    }, {})\n\n    const schema: MarkSpec = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField<NodeConfig['inclusive']>(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField<NodeConfig['excludes']>(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField<NodeConfig['spanning']>(extension, 'spanning', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n      })),\n    })\n\n    const parseHTML = callOrReturn(getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context))\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML\n        .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n    }\n\n    const renderHTML = getExtensionField<MarkConfig['renderHTML']>(extension, 'renderHTML', context)\n\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n      })\n    }\n\n    return [extension.name, schema]\n  }))\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","export default function isEmptyObject(object = {}): boolean {\n  return Object.keys(object).length === 0 && object.constructor === Object\n}\n","import { MarkType, NodeType, Schema } from 'prosemirror-model'\n\nexport default function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  if (schema.nodes[name]) {\n    return schema.nodes[name]\n  }\n\n  if (schema.marks[name]) {\n    return schema.marks[name]\n  }\n\n  return null\n}\n","import { keymap } from 'prosemirror-keymap'\nimport { Schema, Node as ProsemirrorNode } from 'prosemirror-model'\nimport { inputRules as inputRulesPlugin } from 'prosemirror-inputrules'\nimport { EditorView, Decoration } from 'prosemirror-view'\nimport { Plugin } from 'prosemirror-state'\nimport { Editor } from './Editor'\nimport { Extensions, RawCommands, AnyConfig } from './types'\nimport getExtensionField from './helpers/getExtensionField'\nimport getSchema from './helpers/getSchema'\nimport getSchemaTypeByName from './helpers/getSchemaTypeByName'\nimport getNodeType from './helpers/getNodeType'\nimport splitExtensions from './helpers/splitExtensions'\nimport getAttributesFromExtensions from './helpers/getAttributesFromExtensions'\nimport getRenderedAttributes from './helpers/getRenderedAttributes'\nimport callOrReturn from './utilities/callOrReturn'\nimport { NodeConfig } from '.'\n\nexport default class ExtensionManager {\n\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = this.sort(extensions)\n    this.schema = getSchema(this.extensions)\n\n    this.extensions.forEach(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(\n        extension,\n        'onCreate',\n        context,\n      )\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(\n        extension,\n        'onUpdate',\n        context,\n      )\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(\n        extension,\n        'onFocus',\n        context,\n      )\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(\n        extension,\n        'onBlur',\n        context,\n      )\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(\n        extension,\n        'onDestroy',\n        context,\n      )\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  private sort(extensions: Extensions) {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    return [...this.extensions]\n      .reverse()\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          editor: this.editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object\n              .entries(addKeyboardShortcuts())\n              .map(([shortcut, method]) => {\n                return [shortcut, () => method({ editor: this.editor })]\n              }),\n          )\n\n          const keyMapPlugin = keymap(bindings)\n\n          plugins.push(keyMapPlugin)\n        }\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (this.editor.options.enableInputRules && addInputRules) {\n          const inputRules = addInputRules()\n          const inputRulePlugins = inputRules.length\n            ? [inputRulesPlugin({ rules: inputRules })]\n            : []\n\n          plugins.push(...inputRulePlugins)\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (this.editor.options.enablePasteRules && addPasteRules) {\n          const pasteRulePlugins = addPasteRules()\n\n          plugins.push(...pasteRulePlugins)\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(nodeExtensions\n      .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n      .map(extension => {\n        const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name)\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          editor,\n          type: getNodeType(extension.name, this.schema),\n        }\n        const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n          extension,\n          'addNodeView',\n          context,\n        )\n\n        if (!addNodeView) {\n          return []\n        }\n\n        const nodeview = (\n          node: ProsemirrorNode,\n          view: EditorView,\n          getPos: (() => number) | boolean,\n          decorations: Decoration[],\n        ) => {\n          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n          return addNodeView()({\n            editor,\n            node,\n            getPos,\n            decorations,\n            HTMLAttributes,\n            extension,\n          })\n        }\n\n        return [extension.name, nodeview]\n      }))\n  }\n\n  get textSerializers() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(nodeExtensions\n      .filter(extension => !!getExtensionField(extension, 'renderText'))\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          editor,\n          type: getNodeType(extension.name, this.schema),\n        }\n\n        const renderText = getExtensionField<NodeConfig['renderText']>(extension, 'renderText', context)\n\n        if (!renderText) {\n          return []\n        }\n\n        const textSerializer = (props: { node: ProsemirrorNode }) => renderText(props)\n\n        return [extension.name, textSerializer]\n      }))\n  }\n\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(payload: any): string {\n  return Object.prototype.toString.call(payload).slice(8, -1)\n}\n\nexport default function isPlainObject(payload: any): payload is Record<string, any> {\n  if (getType(payload) !== 'Object') return false\n  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype\n}\n","import isPlainObject from './isPlainObject'\n\nexport default function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from 'prosemirror-state'\nimport { InputRule } from 'prosemirror-inputrules'\nimport { Editor } from './Editor'\nimport { Node } from './Node'\nimport { Mark } from './Mark'\nimport mergeDeep from './utilities/mergeDeep'\nimport {\n  GlobalAttributes,\n  RawCommands,\n  ParentConfig,\n  KeyboardShortcutCommand,\n} from './types'\nimport { ExtensionConfig } from '.'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<ExtensionConfig<Options>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addPasteRules'],\n    }) => Plugin[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<ExtensionConfig<Options>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<ExtensionConfig<Options>>['extendMarkSchema'],\n      },\n      extension: Mark,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onDestroy'],\n    }) => void) | null,\n  }\n}\n\nexport class Extension<Options = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  config: ExtensionConfig = {\n    name: this.name,\n    priority: 100,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n    this.options = this.config.defaultOptions\n  }\n\n  static create<O>(config: Partial<ExtensionConfig<O>> = {}) {\n    return new Extension<O>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    this.options = mergeDeep(this.options, options) as Options\n\n    return this\n  }\n\n  extend<ExtendedOptions = Options>(extendedConfig: Partial<ExtensionConfig<ExtendedOptions>> = {}) {\n    const extension = new Extension<ExtendedOptions>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    extension.options = extendedConfig.defaultOptions\n      ? extendedConfig.defaultOptions\n      : extension.parent.options\n\n    return extension\n  }\n}\n","import { Editor } from '@tiptap/core'\nimport { Plugin, PluginKey } from 'prosemirror-state'\nimport { Extension } from '../Extension'\n\nconst textBetween = (\n  editor: Editor,\n  from: number,\n  to: number,\n  blockSeparator?: string,\n  leafText?: string,\n): string => {\n  let text = ''\n  let separated = true\n\n  editor.state.doc.nodesBetween(from, to, (node, pos) => {\n    const textSerializer = editor.extensionManager.textSerializers[node.type.name]\n\n    if (textSerializer) {\n      text += textSerializer({ node })\n      separated = !blockSeparator\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos)\n      separated = !blockSeparator\n    } else if (node.isLeaf && leafText) {\n      text += leafText\n      separated = !blockSeparator\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator\n      separated = true\n    }\n  }, 0)\n\n  return text\n}\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { from, to } = editor.state.selection\n\n            return textBetween(editor, from, to, '\\n')\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => Command,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ view }) => {\n  const element = view.dom as HTMLElement\n\n  element.blur()\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: Boolean) => Command,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from 'prosemirror-transform'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => Command,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  ranges.forEach(range => {\n    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n      if (!node.type.isText) {\n        const fromPos = tr.doc.resolve(tr.mapping.map(pos + 1))\n        const toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize - 1))\n        const nodeRange = fromPos.blockRange(toPos)\n\n        if (nodeRange) {\n          const targetLiftDepth = liftTarget(nodeRange)\n\n          if (node.type.isTextblock && dispatch) {\n            tr.setNodeMarkup(nodeRange.start, state.doc.type.contentMatch.defaultType)\n          }\n\n          if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {\n            tr.lift(nodeRange, targetLiftDepth)\n          }\n        }\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => Command,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                      : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild))\n    if (node.isTextblock) return true\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                      : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from([deflt.create(), $from.parent])))\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && after.isTextblock && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    if (at.canReplace(at.childCount, at.childCount, after.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + 1, $cut.pos + after.nodeSize - 1,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable))\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n","import { createParagraphNear as originalCreateParagraphNear } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => Command,\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { Command, RawCommands, Range } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => Command,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => Command,\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => Command,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => Command,\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { MarkType, ResolvedPos } from 'prosemirror-model'\nimport { Range } from '../types'\n\nexport default function getMarkRange($pos: ResolvedPos, type: MarkType): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  const start = $pos.parent.childAfter($pos.parentOffset)\n\n  if (!start.node) {\n    return\n  }\n\n  const link = start.node.marks.find(mark => mark.type === type)\n\n  if (!link) {\n    return\n  }\n\n  let startIndex = $pos.index()\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  while (startIndex > 0 && link.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (endIndex < $pos.parent.childCount && link.isInSet($pos.parent.child(endIndex).marks)) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { TextSelection } from 'prosemirror-state'\nimport { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport getMarkRange from '../helpers/getMarkRange'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (typeOrName: string | MarkType) => Command,\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, empty } = selection\n\n  if (empty && dispatch) {\n    const range = getMarkRange($from, type)\n\n    if (range) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: Parameters<Command>[0]) => Command[])) => Command,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","export default function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import isClass from './isClass'\n\nexport default function isObject(item: any): boolean {\n  return (\n    item\n    && typeof item === 'object'\n    && !Array.isArray(item)\n    && !isClass(item)\n  )\n}\n","export default function isClass(item: any): boolean {\n  if (item.constructor?.toString().substring(0, 5) !== 'class') {\n    return false\n  }\n\n  return true\n}\n","import { TextSelection } from 'prosemirror-state'\nimport isObject from '../utilities/isObject'\n\nexport default function isTextSelection(value: unknown): value is TextSelection {\n  return isObject(value) && value instanceof TextSelection\n}\n","import { EditorState, TextSelection } from 'prosemirror-state'\nimport { Command, RawCommands, FocusPosition } from '../types'\nimport minMax from '../utilities/minMax'\nimport isTextSelection from '../helpers/isTextSelection'\n\nfunction resolveSelection(state: EditorState, position: FocusPosition = null) {\n  if (!position) {\n    return null\n  }\n\n  if (position === 'start' || position === true) {\n    return {\n      from: 0,\n      to: 0,\n    }\n  }\n\n  if (position === 'end') {\n    const { size } = state.doc.content\n\n    return {\n      from: size,\n      to: size,\n    }\n  }\n\n  return {\n    from: position,\n    to: position,\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (position?: FocusPosition) => Command,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    view.focus()\n    return true\n  }\n\n  const { from, to } = resolveSelection(editor.state, position) || editor.state.selection\n  const { doc, storedMarks } = tr\n  const resolvedFrom = minMax(from, 0, doc.content.size)\n  const resolvedEnd = minMax(to, 0, doc.content.size)\n  const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    tr.setSelection(selection)\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && storedMarks) {\n      tr.setStoredMarks(storedMarks)\n    }\n\n    view.focus()\n  }\n\n  return true\n}\n","import { Selection, Transaction } from 'prosemirror-state'\nimport { ReplaceStep, ReplaceAroundStep } from 'prosemirror-transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport default function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import createNodeFromContent from '../helpers/createNodeFromContent'\nimport selectionToInsertionEnd from '../helpers/selectionToInsertionEnd'\nimport { Command, RawCommands, Content } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (value: Content) => Command,\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = value => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    const content = createNodeFromContent(value, editor.schema)\n\n    if (typeof content === 'string') {\n      tr.insertText(content)\n      tr.scrollIntoView()\n\n      return true\n    }\n\n    if (!tr.selection.empty) {\n      tr.deleteSelection()\n    }\n\n    tr.insert(tr.selection.anchor, content)\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { DOMParser } from 'prosemirror-model'\nimport elementFromString from '../utilities/elementFromString'\nimport selectionToInsertionEnd from '../helpers/selectionToInsertionEnd'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    insertHTML: {\n      /**\n       * Insert a string of HTML at the current position.\n       */\n      insertHTML: (value: string) => Command,\n    }\n  }\n}\n\nexport const insertHTML: RawCommands['insertHTML'] = value => ({ tr, state, dispatch }) => {\n  console.warn('[tiptap warn]: insertHTML() is deprecated. please use insertContent() instead.')\n\n  const { selection } = tr\n  const element = elementFromString(value)\n  const slice = DOMParser.fromSchema(state.schema).parseSlice(element)\n\n  if (dispatch) {\n    tr.insert(selection.anchor, slice.content)\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n  }\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    insertNode: {\n      /**\n       * Insert a node at the current position.\n       */\n      insertNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const insertNode: RawCommands['insertNode'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  console.warn('[tiptap warn]: insertNode() is deprecated. please use insertContent() instead.')\n\n  const { selection } = tr\n  const type = getNodeType(typeOrName, state.schema)\n\n  if (!type) {\n    return false\n  }\n\n  const node = type.create(attributes)\n\n  if (dispatch) {\n    tr.insert(selection.anchor, node)\n  }\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    insertText: {\n      /**\n       * Insert a string of text at the current position.\n       */\n      insertText: (value: string) => Command,\n    }\n  }\n}\n\nexport const insertText: RawCommands['insertText'] = value => ({ tr, dispatch }) => {\n  console.warn('[tiptap warn]: insertText() is deprecated. please use insertContent() instead.')\n\n  if (dispatch) {\n    tr.insertText(value)\n  }\n\n  return true\n}\n","import { joinBackward as originalJoinBackward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    joinBackward: {\n      /**\n       * Join two nodes backward.\n       */\n      joinBackward: () => Command,\n    }\n  }\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n","import { joinForward as originalJoinForward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    joinForward: {\n      /**\n       * Join two nodes forward.\n       */\n      joinForward: () => Command,\n    }\n  }\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","import { Command, RawCommands } from '../types'\n\nconst mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => Command,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { lift as originalLift } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => Command,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import {findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment, NodeRange} from \"prosemirror-model\"\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0]\n\n// :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\nexport const orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {start: node.attrs.order}, 0]\n  }\n}\n\n// :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\nexport const bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM() { return ulDOM }\n}\n\n// :: NodeSpec\n// A list item (`<li>`) spec.\nexport const listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM() { return liDOM },\n  defining: true\n}\n\nfunction add(obj, props) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  for (let prop in props) copy[prop] = props[prop]\n  return copy\n}\n\n// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\nexport function addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nexport function wrapInList(listType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), doJoin = false, outerRange = range\n    if (!range) return false\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) return false\n      let $insert = state.doc.resolve(range.start - 2)\n      outerRange = new NodeRange($insert, $insert, range.depth)\n      if (range.endIndex < range.parent.childCount)\n        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth)\n      doJoin = true\n    }\n    let wrap = findWrapping(outerRange, listType, attrs, range)\n    if (!wrap) return false\n    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView())\n    return true\n  }\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new Slice(content, 0, 0), wrappers.length, true))\n\n  let found = 0\n  for (let i = 0; i < wrappers.length; i++) if (wrappers[i].type == listType) found = i + 1\n  let splitDepth = wrappers.length - found\n\n  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent\n  for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth)\n      splitPos += 2 * splitDepth\n    }\n    splitPos += parent.child(i).nodeSize\n  }\n  return tr\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nexport function splitListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to, node} = state.selection\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) return false\n    let grandParent = $from.node(-1)\n    if (grandParent.type != itemType) return false\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType ||\n          $from.index(-2) != $from.node(-2).childCount - 1) return false\n      if (dispatch) {\n        let wrap = Fragment.empty, keepItem = $from.index(-1) > 0\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--)\n          wrap = Fragment.from($from.node(d).copy(wrap))\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()))\n        let tr = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2))\n        tr.setSelection(state.selection.constructor.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n    let tr = state.tr.delete($from.pos, $to.pos)\n    let types = nextType && [null, {type: nextType}]\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nexport function liftListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type == itemType)\n    if (!range) return false\n    if (!dispatch) return true\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      return liftToOuterList(state, dispatch, itemType, range)\n    else // Outer list node\n      return liftOutOfList(state, dispatch, range)\n  }\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth)\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                  new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true))\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth)\n  }\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView())\n  return true\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  let tr = state.tr, list = range.parent\n  // Merge the list items into a single big item\n  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize\n    tr.delete(pos - 1, pos + 1)\n  }\n  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter\n  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount\n  let parent = $start.node(-1), indexBefore = $start.index(-1)\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,\n                         item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n    return false\n  let start = $start.pos, end = start + item.nodeSize\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,\n                                new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n                                          .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))),\n                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1))\n  dispatch(tr.scrollIntoView())\n  return true\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nexport function sinkListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type == itemType)\n    if (!range) return false\n    let startIndex = range.startIndex\n    if (startIndex == 0) return false\n    let parent = range.parent, nodeBefore = parent.child(startIndex - 1)\n    if (nodeBefore.type != itemType) return false\n\n    if (dispatch) {\n      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type\n      let inner = Fragment.from(nestedBefore ? itemType.create() : null)\n      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))),\n                            nestedBefore ? 3 : 1, 0)\n      let before = range.start, after = range.end\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView())\n    }\n    return true\n  }\n}\n","import { liftListItem as originalLiftListItem } from 'prosemirror-schema-list'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => Command,\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    replace: {\n      /**\n       * Replaces text with a node.\n       */\n      replace: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const replace: RawCommands['replace'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const { from, to } = state.selection\n  const range = { from, to }\n\n  return commands.replaceRange(range, typeOrName, attributes)\n}\n","import { NodeType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport { Command, RawCommands, Range } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    replaceRange: {\n      /**\n       * Replaces text with a node within a range.\n       */\n      replaceRange: (range: Range, typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const replaceRange: RawCommands['replaceRange'] = (range, typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = range\n  const $from = tr.doc.resolve(from)\n  const index = $from.index()\n\n  if (!$from.parent.canReplaceWith(index, index, type)) {\n    return false\n  }\n\n  if (dispatch) {\n    tr.replaceWith(from, to, type.create(attributes))\n  }\n\n  return true\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport default function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { NodeType, MarkType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport getMarkType from '../helpers/getMarkType'\nimport getSchemaTypeNameByName from '../helpers/getSchemaTypeNameByName'\nimport deleteProps from '../utilities/deleteProps'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (typeOrName: string | NodeType | MarkType, attributes: string | string[]) => Command,\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)))\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport deleteProps from '../utilities/deleteProps'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    resetNodeAttributes: {\n      /**\n       * Resets node attributes to the default value.\n       */\n      resetNodeAttributes: (typeOrName: string | NodeType, attributes: string | string[]) => Command,\n    }\n  }\n}\n\nexport const resetNodeAttributes: RawCommands['resetNodeAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  console.warn('[tiptap warn]: resetNodeAttributes() is deprecated. please use resetAttributes() instead.')\n\n  const type = getNodeType(typeOrName, state.schema)\n  const { selection } = tr\n  const { ranges } = selection\n\n  ranges.forEach(range => {\n    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n      if (node.type === type && dispatch) {\n        tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => Command,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { selectAll as originalSelectAll } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => Command,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ state, dispatch }) => {\n  return originalSelectAll(state, dispatch)\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => Command,\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => Command,\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => Command,\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","import { TextSelection } from 'prosemirror-state'\nimport createDocument from '../helpers/createDocument'\nimport { Command, RawCommands, Content } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: Boolean,\n        parseOptions?: Record<string, any>,\n      ) => Command,\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n  const selection = TextSelection.create(doc, 0, doc.content.size)\n\n  if (dispatch) {\n    tr.setSelection(selection)\n      .replaceSelectionWith(document, false)\n      .setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport getMarkAttributes from '../helpers/getMarkAttributes'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(type.create({\n        ...oldAttributes,\n        ...attributes,\n      }))\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }))\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport { setBlockType } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return setBlockType(type, attributes)(state, dispatch)\n}\n","import { sinkListItem as originalSinkListItem } from 'prosemirror-schema-list'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { ExtensionAttribute } from '../types'\n\nexport default function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { canSplit } from 'prosemirror-transform'\nimport { ContentMatch, Fragment } from 'prosemirror-model'\nimport { EditorState, NodeSelection, TextSelection } from 'prosemirror-state'\nimport { Command, RawCommands } from '../types'\nimport getSplittedAttributes from '../helpers/getSplittedAttributes'\n\nfunction defaultBlockAt(match: ContentMatch) {\n  for (let i = 0; i < match.edgeCount; i + 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n  return null\n}\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks\n    || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => Command,\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr,\n  state,\n  dispatch,\n  editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [{\n        type: deflt,\n        attrs: newAttributes,\n      }]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n      && !can\n      && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [{\n          type: deflt,\n          attrs: newAttributes,\n        }]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (\n        !atEnd\n        && !$from.parentOffset\n        && $from.parent.type !== deflt\n        && $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from(deflt?.create()))\n      ) {\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt || undefined)\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  NodeType,\n  Node as ProseMirrorNode,\n  Fragment,\n  Slice,\n} from 'prosemirror-model'\nimport { canSplit } from 'prosemirror-transform'\nimport { TextSelection } from 'prosemirror-state'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\nimport getSplittedAttributes from '../helpers/getSplittedAttributes'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n      || $from.node(-3).type !== type\n      || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      const keepItem = $from.index(-1) > 0\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      tr\n        .replace(\n          $from.before(keepItem ? undefined : -1),\n          $from.after(-3),\n          new Slice(wrap, keepItem ? 3 : 2, 2),\n        )\n        .setSelection(TextSelection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))))\n        .scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end()\n    ? grandParent.contentMatchAt(0).defaultType\n    : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    tr.split($from.pos, 2, types).scrollIntoView()\n  }\n\n  return true\n}\n","import { ResolvedPos, Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Predicate } from '../types'\n\nexport default function findParentNodeClosestToPos($pos: ResolvedPos, predicate: Predicate): ({\n  pos: number,\n  start: number,\n  depth: number,\n  node: ProseMirrorNode,\n} | undefined) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from 'prosemirror-state'\nimport findParentNodeClosestToPos from './findParentNodeClosestToPos'\nimport { Predicate } from '../types'\n\nexport default function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { Extensions } from '../types'\nimport { NodeConfig } from '..'\nimport splitExtensions from './splitExtensions'\nimport callOrReturn from '../utilities/callOrReturn'\nimport getExtensionField from '../helpers/getExtensionField'\n\nexport default function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\nimport findParentNode from '../helpers/findParentNode'\nimport isList from '../helpers/isList'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions } = editor.options\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n      && listType.validContent(parentList.node.content)\n      && dispatch\n    ) {\n      tr.setNodeMarkup(parentList.pos, listType)\n\n      return true\n    }\n  }\n\n  const canWrapInList = can().wrapInList(listType)\n\n  // try to convert node to paragraph if needed\n  if (!canWrapInList) {\n    return chain()\n      .clearNodes()\n      .wrapInList(listType)\n      .run()\n  }\n\n  return commands.wrapInList(listType)\n}\n","import { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport isMarkActive from '../helpers/isMarkActive'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type)\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (typeOrName: string | NodeType, toggleTypeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { wrapIn, lift } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return lift(state, dispatch)\n  }\n\n  return wrapIn(type, attributes)(state, dispatch)\n}\n","import { undoInputRule as originalUndoInputRule } from 'prosemirror-inputrules'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => Command,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  return originalUndoInputRule(state, dispatch)\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => Command,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    Object\n      .entries(state.schema.marks)\n      .forEach(([, mark]) => {\n        ranges.forEach(range => {\n          tr.removeMark(range.$from.pos, range.$to.pos, mark as any)\n        })\n      })\n  }\n\n  return true\n}\n","import { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport getMarkRange from '../helpers/getMarkRange'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (typeOrName: string | MarkType) => Command,\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = typeOrName => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (dispatch) {\n    if (empty) {\n      let { from, to } = selection\n      const range = getMarkRange($from, type)\n\n      if (range) {\n        from = range.from\n        to = range.to\n      }\n\n      tr.removeMark(from, to, type)\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type)\n      })\n    }\n\n    tr.removeStoredMark(type)\n  }\n\n  return true\n}\n","import { NodeType, MarkType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport getMarkType from '../helpers/getMarkType'\nimport getSchemaTypeNameByName from '../helpers/getSchemaTypeNameByName'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (typeOrName: string | NodeType | MarkType, attributes: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                ...mark.attrs,\n                ...attributes,\n              }))\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    updateNodeAttributes: {\n      /**\n       * Update attributes of a node.\n       */\n      updateNodeAttributes: (typeOrName: string | NodeType, attributes: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const updateNodeAttributes: RawCommands['updateNodeAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  console.warn('[tiptap warn]: updateNodeAttributes() is deprecated. please use updateAttributes() instead.')\n\n  const type = getNodeType(typeOrName, state.schema)\n  const { selection } = tr\n  const { ranges } = selection\n\n  ranges.forEach(range => {\n    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n      if (node.type === type && dispatch) {\n        tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          ...attributes,\n        })\n      }\n    })\n  })\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return false\n  }\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { wrapInList as originalWrapInList } from 'prosemirror-schema-list'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import { Extension } from '../Extension'\nimport * as blur from '../commands/blur'\nimport * as clearContent from '../commands/clearContent'\nimport * as clearNodes from '../commands/clearNodes'\nimport * as command from '../commands/command'\nimport * as createParagraphNear from '../commands/createParagraphNear'\nimport * as deleteRange from '../commands/deleteRange'\nimport * as deleteSelection from '../commands/deleteSelection'\nimport * as enter from '../commands/enter'\nimport * as exitCode from '../commands/exitCode'\nimport * as extendMarkRange from '../commands/extendMarkRange'\nimport * as first from '../commands/first'\nimport * as focus from '../commands/focus'\nimport * as insertContent from '../commands/insertContent'\nimport * as insertHTML from '../commands/insertHTML'\nimport * as insertNode from '../commands/insertNode'\nimport * as insertText from '../commands/insertText'\nimport * as joinBackward from '../commands/joinBackward'\nimport * as joinForward from '../commands/joinForward'\nimport * as keyboardShortcut from '../commands/keyboardShortcut'\nimport * as lift from '../commands/lift'\nimport * as liftEmptyBlock from '../commands/liftEmptyBlock'\nimport * as liftListItem from '../commands/liftListItem'\nimport * as newlineInCode from '../commands/newlineInCode'\nimport * as replace from '../commands/replace'\nimport * as replaceRange from '../commands/replaceRange'\nimport * as resetAttributes from '../commands/resetAttributes'\nimport * as resetNodeAttributes from '../commands/resetNodeAttributes'\nimport * as scrollIntoView from '../commands/scrollIntoView'\nimport * as selectAll from '../commands/selectAll'\nimport * as selectNodeBackward from '../commands/selectNodeBackward'\nimport * as selectNodeForward from '../commands/selectNodeForward'\nimport * as selectParentNode from '../commands/selectParentNode'\nimport * as setContent from '../commands/setContent'\nimport * as setMark from '../commands/setMark'\nimport * as setNode from '../commands/setNode'\nimport * as sinkListItem from '../commands/sinkListItem'\nimport * as splitBlock from '../commands/splitBlock'\nimport * as splitListItem from '../commands/splitListItem'\nimport * as toggleList from '../commands/toggleList'\nimport * as toggleMark from '../commands/toggleMark'\nimport * as toggleNode from '../commands/toggleNode'\nimport * as toggleWrap from '../commands/toggleWrap'\nimport * as undoInputRule from '../commands/undoInputRule'\nimport * as unsetAllMarks from '../commands/unsetAllMarks'\nimport * as unsetMark from '../commands/unsetMark'\nimport * as updateAttributes from '../commands/updateAttributes'\nimport * as updateNodeAttributes from '../commands/updateNodeAttributes'\nimport * as wrapIn from '../commands/wrapIn'\nimport * as wrapInList from '../commands/wrapInList'\n\nexport { blur }\nexport { clearContent }\nexport { clearNodes }\nexport { command }\nexport { createParagraphNear }\nexport { deleteRange }\nexport { deleteSelection }\nexport { enter }\nexport { exitCode }\nexport { extendMarkRange }\nexport { first }\nexport { focus }\nexport { insertContent }\nexport { insertHTML }\nexport { insertNode }\nexport { insertText }\nexport { joinBackward }\nexport { joinForward }\nexport { keyboardShortcut }\nexport { lift }\nexport { liftEmptyBlock }\nexport { liftListItem }\nexport { newlineInCode }\nexport { replace }\nexport { replaceRange }\nexport { resetAttributes }\nexport { resetNodeAttributes }\nexport { scrollIntoView }\nexport { selectAll }\nexport { selectNodeBackward }\nexport { selectNodeForward }\nexport { selectParentNode }\nexport { setContent }\nexport { setMark }\nexport { setNode }\nexport { sinkListItem }\nexport { splitBlock }\nexport { splitListItem }\nexport { toggleList }\nexport { toggleMark }\nexport { toggleNode }\nexport { toggleWrap }\nexport { undoInputRule }\nexport { unsetAllMarks }\nexport { unsetMark }\nexport { updateAttributes }\nexport { updateNodeAttributes }\nexport { wrapIn }\nexport { wrapInList }\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...blur,\n      ...clearContent,\n      ...clearNodes,\n      ...command,\n      ...createParagraphNear,\n      ...deleteRange,\n      ...deleteSelection,\n      ...enter,\n      ...exitCode,\n      ...extendMarkRange,\n      ...first,\n      ...focus,\n      ...insertContent,\n      ...insertHTML,\n      ...insertNode,\n      ...insertText,\n      ...joinBackward,\n      ...joinForward,\n      ...keyboardShortcut,\n      ...lift,\n      ...liftEmptyBlock,\n      ...liftListItem,\n      ...newlineInCode,\n      ...replace,\n      ...replaceRange,\n      ...resetAttributes,\n      ...resetNodeAttributes,\n      ...scrollIntoView,\n      ...selectAll,\n      ...selectNodeBackward,\n      ...selectNodeForward,\n      ...selectParentNode,\n      ...setContent,\n      ...setMark,\n      ...setNode,\n      ...sinkListItem,\n      ...splitBlock,\n      ...splitListItem,\n      ...toggleList,\n      ...toggleMark,\n      ...toggleNode,\n      ...toggleWrap,\n      ...undoInputRule,\n      ...unsetAllMarks,\n      ...unsetMark,\n      ...updateAttributes,\n      ...updateNodeAttributes,\n      ...wrapIn,\n      ...wrapInList,\n    }\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { Extension } from '../Extension'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { Extension } from '../Extension'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          attributes: {\n            tabindex: '0',\n          },\n          handleDOMEvents: {\n            focus: (view, event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Extension } from '../Extension'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    return {\n      Enter: () => this.editor.commands.first(({ commands }) => [\n        () => commands.newlineInCode(),\n        () => commands.createParagraphNear(),\n        () => commands.liftEmptyBlock(),\n        () => commands.splitBlock(),\n      ]),\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: () => handleBackspace(),\n      'Mod-Backspace': () => handleBackspace(),\n      Delete: () => handleDelete(),\n      'Mod-Delete': () => handleDelete(),\n      // we don’t need a custom `selectAll` for now\n      // 'Mod-a': () => this.editor.commands.selectAll(),\n    }\n  },\n})\n","import {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  NodeType,\n} from 'prosemirror-model'\nimport { Plugin, Transaction } from 'prosemirror-state'\nimport { InputRule } from 'prosemirror-inputrules'\nimport mergeDeep from './utilities/mergeDeep'\nimport {\n  Attributes,\n  NodeViewRenderer,\n  GlobalAttributes,\n  RawCommands,\n  ParentConfig,\n  KeyboardShortcutCommand,\n} from './types'\nimport { NodeConfig } from '.'\nimport { Editor } from './Editor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addPasteRules'],\n    }) => Plugin[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['extendMarkSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onDestroy'],\n    }) => void) | null,\n\n    /**\n     * Node View\n     */\n    addNodeView?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addNodeView'],\n    }) => NodeViewRenderer) | null,\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean,\n\n    /**\n     * Content\n     */\n    content?: NodeSpec['content'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['content'],\n    }) => NodeSpec['content']),\n\n    /**\n     * Marks\n     */\n    marks?: NodeSpec['marks'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['marks'],\n    }) => NodeSpec['marks']),\n\n    /**\n     * Group\n     */\n    group?: NodeSpec['group'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['group'],\n    }) => NodeSpec['group']),\n\n    /**\n     * Inline\n     */\n    inline?: NodeSpec['inline'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['inline'],\n    }) => NodeSpec['inline']),\n\n    /**\n     * Atom\n     */\n    atom?: NodeSpec['atom'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['atom'],\n    }) => NodeSpec['atom']),\n\n    /**\n     * Selectable\n     */\n    selectable?: NodeSpec['selectable'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['selectable'],\n    }) => NodeSpec['selectable']),\n\n    /**\n     * Draggable\n     */\n    draggable?: NodeSpec['draggable'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['draggable'],\n    }) => NodeSpec['draggable']),\n\n    /**\n     * Code\n     */\n    code?: NodeSpec['code'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['code'],\n    }) => NodeSpec['code']),\n\n    /**\n     * Defining\n     */\n    defining?: NodeSpec['defining'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['defining'],\n    }) => NodeSpec['defining']),\n\n    /**\n     * Isolating\n     */\n    isolating?: NodeSpec['isolating'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['isolating'],\n    }) => NodeSpec['isolating']),\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['parseHTML'],\n      },\n    ) => NodeSpec['parseDOM'],\n\n    /**\n     * Render HTML\n     */\n    renderHTML?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['renderHTML'],\n      },\n      props: {\n        node: ProseMirrorNode,\n        HTMLAttributes: Record<string, any>,\n      }\n    ) => DOMOutputSpec) | null,\n\n    /**\n     * Render Text\n     */\n    renderText?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['renderText'],\n      },\n      props: {\n        node: ProseMirrorNode,\n      }\n    ) => string) | null,\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['addAttributes'],\n      },\n    ) => Attributes | {},\n  }\n}\n\nexport class Node<Options = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  config: NodeConfig = {\n    name: this.name,\n    priority: 100,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n    this.options = this.config.defaultOptions\n  }\n\n  static create<O>(config: Partial<NodeConfig<O>> = {}) {\n    return new Node<O>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    this.options = mergeDeep(this.options, options) as Options\n\n    return this\n  }\n\n  extend<ExtendedOptions = Options>(extendedConfig: Partial<NodeConfig<ExtendedOptions>> = {}) {\n    const extension = new Node<ExtendedOptions>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    extension.options = extendedConfig.defaultOptions\n      ? extendedConfig.defaultOptions\n      : extension.parent.options\n\n    return extension\n  }\n}\n","import {\n  DOMOutputSpec,\n  MarkSpec,\n  Mark as ProseMirrorMark,\n  MarkType,\n} from 'prosemirror-model'\nimport { Plugin, Transaction } from 'prosemirror-state'\nimport { InputRule } from 'prosemirror-inputrules'\nimport mergeDeep from './utilities/mergeDeep'\nimport {\n  Attributes,\n  RawCommands,\n  GlobalAttributes,\n  ParentConfig,\n  KeyboardShortcutCommand,\n} from './types'\nimport { Node } from './Node'\nimport { MarkConfig } from '.'\nimport { Editor } from './Editor'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addPasteRules'],\n    }) => Plugin[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['extendMarkSchema'],\n      },\n      extension: Mark,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onDestroy'],\n    }) => void) | null,\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean),\n\n    /**\n     * Inclusive\n     */\n    inclusive?: MarkSpec['inclusive'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['inclusive'],\n    }) => MarkSpec['inclusive']),\n\n    /**\n     * Excludes\n     */\n    excludes?: MarkSpec['excludes'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['excludes'],\n    }) => MarkSpec['excludes']),\n\n    /**\n     * Group\n     */\n    group?: MarkSpec['group'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['group'],\n    }) => MarkSpec['group']),\n\n    /**\n     * Spanning\n     */\n    spanning?: MarkSpec['spanning'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['spanning'],\n    }) => MarkSpec['spanning']),\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['parseHTML'],\n      },\n    ) => MarkSpec['parseDOM'],\n\n    /**\n     * Render HTML\n     */\n    renderHTML?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['renderHTML'],\n      },\n      props: {\n        mark: ProseMirrorMark,\n        HTMLAttributes: Record<string, any>,\n      },\n    ) => DOMOutputSpec) | null,\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['addAttributes'],\n      },\n    ) => Attributes | {},\n  }\n}\n\nexport class Mark<Options = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  config: MarkConfig = {\n    name: this.name,\n    priority: 100,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n    this.options = this.config.defaultOptions\n  }\n\n  static create<O>(config: Partial<MarkConfig<O>> = {}) {\n    return new Mark<O>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    this.options = mergeDeep(this.options, options) as Options\n\n    return this\n  }\n\n  extend<ExtendedOptions = Options>(extendedConfig: Partial<MarkConfig<ExtendedOptions>> = {}) {\n    const extension = new Mark<ExtendedOptions>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    extension.options = extendedConfig.defaultOptions\n      ? extendedConfig.defaultOptions\n      : extension.parent.options\n\n    return extension\n  }\n}\n","import { EditorView } from 'prosemirror-view'\n\ntype DOMRectSide = 'bottom' | 'left' | 'right' | 'top';\n\nfunction textRange(node: Node, from?: number, to?: number) {\n  const range = document.createRange()\n  range.setEnd(node, typeof to === 'number' ? to : (node.nodeValue || '').length)\n  range.setStart(node, Math.max(from || 0, 0))\n\n  return range\n}\n\nfunction singleRect(object: Range | Element, bias: number) {\n  const rects = object.getClientRects()\n  return !rects.length\n    ? object.getBoundingClientRect()\n    : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\nexport default function coordsAtPos(view: EditorView, pos: number, end = false) {\n  const { node, offset } = view.domAtPos(pos) // view.docView.domFromPos(pos);\n  let side: DOMRectSide | null = null\n  let rect: DOMRect | null = null\n  if (node.nodeType === 3) {\n    const nodeValue = node.nodeValue || ''\n    if (end && offset < nodeValue.length) {\n      rect = singleRect(textRange(node, offset - 1, offset), -1)\n      side = 'right'\n    } else if (offset < nodeValue.length) {\n      rect = singleRect(textRange(node, offset, offset + 1), -1)\n      side = 'left'\n    }\n  } else if (node.firstChild) {\n    if (offset < node.childNodes.length) {\n      const child = node.childNodes[offset]\n      rect = singleRect(\n        child.nodeType === 3 ? textRange(child) : (child as Element),\n        -1,\n      )\n      side = 'left'\n    }\n    if ((!rect || rect.top === rect.bottom) && offset) {\n      const child = node.childNodes[offset - 1]\n      rect = singleRect(\n        child.nodeType === 3 ? textRange(child) : (child as Element),\n        1,\n      )\n      side = 'right'\n    }\n  } else {\n    const element = node as Element\n    rect = element.getBoundingClientRect()\n    side = 'left'\n  }\n\n  if (rect && side) {\n    const x = rect[side]\n\n    return {\n      top: rect.top,\n      bottom: rect.bottom,\n      left: x,\n      right: x,\n    }\n  }\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  }\n}\n","export default class EventEmitter {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on(event: string, fn: Function): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit(event: string, ...args: any): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off(event: string, fn?: Function): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import {\n  EditorState, Plugin, PluginKey, Transaction,\n} from 'prosemirror-state'\nimport { EditorView } from 'prosemirror-view'\nimport { Schema } from 'prosemirror-model'\nimport getNodeAttributes from './helpers/getNodeAttributes'\nimport getMarkAttributes from './helpers/getMarkAttributes'\nimport isActive from './helpers/isActive'\nimport removeElement from './utilities/removeElement'\nimport createDocument from './helpers/createDocument'\nimport getHTMLFromFragment from './helpers/getHTMLFromFragment'\nimport isNodeEmpty from './helpers/isNodeEmpty'\nimport createStyleTag from './utilities/createStyleTag'\nimport CommandManager from './CommandManager'\nimport ExtensionManager from './ExtensionManager'\nimport EventEmitter from './EventEmitter'\nimport {\n  EditorOptions,\n  CanCommands,\n  ChainedCommands,\n  SingleCommands,\n} from './types'\nimport * as extensions from './extensions'\nimport style from './style'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter {\n\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.createCommands()\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.createChain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.createCan()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = { ...this.options, ...options }\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean): void {\n    this.setOptions({ editable })\n\n    if (this.view && this.state && !this.isDestroyed) {\n      this.view.updateState(this.state)\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    return this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(plugin: Plugin, handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[]): void {\n    const plugins = typeof handlePlugins === 'function'\n      ? handlePlugins(plugin, this.state.plugins)\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param name The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const name = typeof nameOrPluginKey === 'string'\n      ? `${nameOrPluginKey}$`\n      // @ts-ignore\n      : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = Object.entries(extensions).map(([, extension]) => extension)\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager(this, this.extensionManager.commands)\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc: createDocument(this.options.content, this.schema, this.options.parseOptions),\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    if (transaction.docChanged && !this.isEditable) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node.\n   *\n   * @param name Name of the node\n   */\n  public getNodeAttributes(name: string): Record<string, any> {\n    return getNodeAttributes(this.state, name)\n  }\n\n  /**\n   * Get attributes of the currently selected mark.\n   *\n   * @param name Name of the mark\n   */\n  public getMarkAttributes(name: string): Record<string, any> {\n    return getMarkAttributes(this.state, name)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean;\n  public isActive(attributes: {}): boolean;\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string'\n      ? nameOrAttributes\n      : null\n\n    const attributes = typeof nameOrAttributes === 'string'\n      ? attributesOrUndefined\n      : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): Record<string, any> {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc, this.schema)\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   */\n  public getCharacterCount(): number {\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n    removeElement(this.css)\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n\n}\n","export default function createStyleTag(style: string): HTMLStyleElement {\n  const styleNode = document.createElement('style')\n\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n\nexport default style\n","import { EditorState } from 'prosemirror-state'\nimport { Node, NodeType } from 'prosemirror-model'\nimport getNodeType from './getNodeType'\n\nexport default function getNodeAttributes(state: EditorState, typeOrName: string | NodeType): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  let nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes = [...nodes, node]\n  })\n\n  const node = nodes\n    .reverse()\n    .find(nodeItem => nodeItem.type.name === type.name)\n\n  if (node) {\n    return { ...node.attrs }\n  }\n\n  return {}\n}\n","export default function removeElement(element: HTMLElement): void {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element)\n  }\n}\n","import { Decoration, NodeView as ProseMirrorNodeView } from 'prosemirror-view'\nimport { NodeSelection } from 'prosemirror-state'\nimport { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Editor as CoreEditor } from './Editor'\nimport { Node } from './Node'\nimport { NodeViewRendererProps } from './types'\n\ninterface NodeViewRendererOptions {\n  stopEvent: ((event: Event) => boolean) | null,\n  update: ((node: ProseMirrorNode, decorations: Decoration[]) => boolean) | null,\n}\n\nexport class NodeView<Component, Editor extends CoreEditor = CoreEditor> implements ProseMirrorNodeView {\n\n  component: Component\n\n  editor: Editor\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: Decoration[]\n\n  getPos: any\n\n  isDragging = false\n\n  options: NodeViewRendererOptions = {\n    stopEvent: null,\n    update: null,\n  }\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<NodeViewRendererOptions>) {\n    this.component = component\n    this.options = { ...this.options, ...options }\n    this.editor = props.editor as Editor\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): Element | null {\n    return null\n  }\n\n  get contentDOM(): Element | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = (event.target as HTMLElement)\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (\n      !this.dom\n      || this.contentDOM?.contains(target)\n      || !dragHandle\n    ) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      x = handleBox.x - domBox.x + event.offsetX\n      y = handleBox.y - domBox.y + event.offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent(event)\n    }\n\n    const target = (event.target as HTMLElement)\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName)\n      || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n    const isDragEvent = event.type.startsWith('drag') || event.type === 'drop'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle\n        && (this.dom === dragHandle || (this.dom.contains(dragHandle)))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener('dragend', () => {\n          this.isDragging = false\n        }, { once: true })\n\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false\n        }, { once: true })\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection', target: Element }) {\n    if (mutation.type === 'selection') {\n      if (this.node.isLeaf) {\n        return true\n      }\n\n      return false\n    }\n\n    if (!this.contentDOM) {\n      return true\n    }\n\n    const contentDOMHasChanged = !this.contentDOM.contains(mutation.target)\n      || (this.contentDOM === mutation.target && mutation.type === 'attributes')\n\n    return contentDOMHasChanged\n  }\n\n  updateAttributes(attributes: {}) {\n    if (!this.editor.view.editable) {\n      return\n    }\n\n    const { state } = this.editor.view\n    const pos = this.getPos()\n    const transaction = state.tr.setNodeMarkup(pos, undefined, {\n      ...this.node.attrs,\n      ...attributes,\n    })\n\n    this.editor.view.dispatch(transaction)\n  }\n\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Predicate } from '../types'\n\ntype NodeWithPos = {\n  node: ProseMirrorNode,\n  pos: number,\n}\n\nexport default function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node } from 'prosemirror-model'\nimport getSchema from './getSchema'\nimport getHTMLFromFragment from './getHTMLFromFragment'\nimport { Extensions } from '../types'\n\nexport default function generateHTML(doc: object, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import { NodeSelection } from 'prosemirror-state'\nimport isObject from '../utilities/isObject'\n\nexport default function isNodeSelection(value: unknown): value is NodeSelection {\n  return isObject(value) && value instanceof NodeSelection\n}\n","import { InputRule } from 'prosemirror-inputrules'\nimport { MarkType } from 'prosemirror-model'\nimport getMarksBetween from '../helpers/getMarksBetween'\n\nexport default function (regexp: RegExp, markType: MarkType, getAttributes?: Function): InputRule {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attributes = getAttributes instanceof Function\n      ? getAttributes(match)\n      : getAttributes\n    const { tr } = state\n    const captureGroup = match[match.length - 1]\n    const fullMatch = match[0]\n    let markEnd = end\n\n    if (captureGroup) {\n      const startSpaces = fullMatch.search(/\\S/)\n      const textStart = start + fullMatch.indexOf(captureGroup)\n      const textEnd = textStart + captureGroup.length\n\n      const excludedMarks = getMarksBetween(start, end, state)\n        .filter(item => {\n          // TODO: PR to add excluded to MarkType\n          // @ts-ignore\n          const { excluded } = item.mark.type\n          return excluded.find((type: MarkType) => type.name === markType.name)\n        })\n        .filter(item => item.to > textStart)\n\n      if (excludedMarks.length) {\n        return null\n      }\n\n      if (textEnd < end) {\n        tr.delete(textEnd, end)\n      }\n\n      if (textStart > start) {\n        tr.delete(start + startSpaces, textStart)\n      }\n\n      markEnd = start + startSpaces + captureGroup.length\n\n      tr.addMark(start + startSpaces, markEnd, markType.create(attributes))\n\n      tr.removeStoredMark(markType)\n    }\n\n    return tr\n  })\n}\n","import { EditorState } from 'prosemirror-state'\nimport { MarkRange } from '../types'\n\nexport default function getMarksBetween(from: number, to: number, state: EditorState): MarkRange[] {\n  let marks: MarkRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      from: pos,\n      to: pos + node.nodeSize,\n      mark,\n    }))]\n  })\n\n  return marks\n}\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { Slice, Fragment, MarkType } from 'prosemirror-model'\n\nexport default function (regexp: RegExp, type: MarkType, getAttrs?: (match: any) => any): Plugin {\n  const handler = (fragment: Fragment, parent?: any) => {\n    const nodes: any[] = []\n\n    fragment.forEach(child => {\n      if (child.isText && child.text) {\n        const { text } = child\n        let pos = 0\n        let match\n\n        // eslint-disable-next-line\n        while ((match = regexp.exec(text)) !== null) {\n          const outerMatch = Math.max(match.length - 2, 0)\n          const innerMatch = Math.max(match.length - 1, 0)\n\n          if (parent?.type.allowsMarkType(type)) {\n            const start = match.index\n            const matchStart = start + match[0].indexOf(match[outerMatch])\n            const matchEnd = matchStart + match[outerMatch].length\n            const textStart = matchStart + match[outerMatch].lastIndexOf(match[innerMatch])\n            const textEnd = textStart + match[innerMatch].length\n            const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n\n            // adding text before markdown to nodes\n            if (matchStart > 0) {\n              nodes.push(child.cut(pos, matchStart))\n            }\n\n            // adding the markdown part to nodes\n            nodes.push(child\n              .cut(textStart, textEnd)\n              .mark(type.create(attrs).addToSet(child.marks)))\n\n            pos = matchEnd\n          }\n        }\n\n        // adding rest of text to nodes\n        if (pos < text.length) {\n          nodes.push(child.cut(pos))\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)))\n      }\n    })\n\n    return Fragment.fromArray(nodes)\n  }\n\n  return new Plugin({\n    key: new PluginKey('markPasteRule'),\n    props: {\n      transformPasted: slice => {\n        return new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n      },\n    },\n  })\n}\n","import { InputRule } from 'prosemirror-inputrules'\nimport { NodeType } from 'prosemirror-model'\n\nexport default function (regexp: RegExp, type: NodeType, getAttributes?: (match: any) => any): InputRule {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attributes = getAttributes instanceof Function\n      ? getAttributes(match)\n      : getAttributes\n    const { tr } = state\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attributes))\n    }\n\n    return tr\n  })\n}\n","import { EditorView } from 'prosemirror-view'\nimport coordsAtPos from './coordsAtPos'\n\nexport default function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const start = coordsAtPos(view, from)\n  const end = coordsAtPos(view, to, true)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n"],"names":["OrderedMap","content","this","prototype","constructor","find","key","i","length","get","found","undefined","update","value","newKey","self","remove","slice","push","splice","addToStart","concat","addToEnd","addBefore","place","without","forEach","f","prepend","map","from","size","subtract","append","result","prop","orderedmap","findDiffStart","a","b","pos","let","childCount","childA","child","childB","sameMarkup","isText","text","j","inner","nodeSize","findDiffEnd","posA","posB","iA","iB","same","minSize","Math","min","Fragment","nodesBetween","to","nodeStart","parent","end","start","max","descendants","textBetween","blockSeparator","leafText","separated","node","isLeaf","isBlock","other","last","lastChild","first","firstChild","withText","cut","cutByIndex","empty","replaceChild","index","current","copy","eq","RangeError","maybeChild","p","otherPos","findIndex","round","retIndex","curPos","toString","toStringInner","join","toJSON","n","fromJSON","schema","Array","isArray","nodeFromJSON","fromArray","array","joined","nodes","attrs","const","offset","compareDeep","Mark","type","ReplaceError","message","err","Error","call","__proto__","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","obj","name","_","json","marks","create","sameSet","setFrom","none","sort","Object","Slice","openStart","openEnd","removeRange","offsetTo","indexTo","insertInto","dist","insert","canReplace","replace","$from","$to","depth","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","close","replaceThreeWay","parentOffset","replaceTwoWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","insertAt","fragment","removeBetween","maxOpen","openIsolating","spec","isolating","ResolvedPos","path","resolveDepth","val","doc","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","next","sharedDepth","blockRange","pred","d","inlineContent","NodeRange","sameParent","str","resolve","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","emptyAttrs","Node","startPos","textContent","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","isTextblock","isAtom","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","m","markFromJSON","nodeType","TextNode","super","JSON","stringify","prototypeAccessors$1","base","ContentMatch","wrapCache","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","indexOf","state","cmp","dfa","connect","compile","edge","edges","exprs","reduce","loop","cur","work","dead","hasRequiredAttrs","checkForDeadEnds","frag","defaultType","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","active","via","shift","reverse","edgeCount","scan","inline","tokens","split","pop","parseExprSeq","eat","parseExprSubscript","test","typeName","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","atom","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","hasOwnProperty","MarkType","excluded","instance","Schema","contentExprCache","contentExpr","markExpr","gatherMarks","excl","bind","topNodeType","wrappings","ok","DOMParser","rules","tags","styles","rule","tag","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","charCodeAt","schemaRules","priority","parseDOM","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","parser","open","isOpen","topContext","topOptions","topMatch","findPositions","needsBlock","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","prototypeAccessors","top","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","nodeName","insertNode","findInText","findInside","matchAfter","ruleID","toLowerCase","prevItem","nextSibling","appendChild","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","toDOM","document","window","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNode","renderSpec","onContent","serializeNodeAndMarks","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","factor16","pow","recoverIndex","MapResult","deleted","recover","StepMap","ranges","inverted","diff","recoverOffset","mapResult","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","Mapping","maps","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","mapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","Transform","steps","docs","mustOverride","step","maybeStep","failed","apply","addStep","docChanged","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","jsonID","id","stepClass","StepResult","fail","fromReplace","e","ReplaceStep","contentBetween","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","canCut","liftTarget","range","innerRange","around","outer","findWrappingOutside","inside","innerMatch","findWrappingInside","withAttrs","canSplit","typesAfter","$pos","innerType","rest","baseType","canJoin","mapFragment","mapped","lift","gapStart","gapEnd","splitting","wrappers","setBlockType","mapFrom","canChangeType","clearIncompatible","startM","endM","setNodeMarkup","newNode","replaceWith","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","fitsTrivially","addMark","removed","added","removing","adding","newSet","s","removeMark","matched","toRemove","parentType","delSteps","allowed","Fitter","fit","replaceStep","delete","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","pass","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","move","replaceRange","deleteRange","targetDepths","preferredTarget","unshift","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","replaceRangeWith","point","insertPoint","covered","classesById","Selection","$anchor","$head","SelectionRange","anchor","tr","lastNode","lastParent","selectionToInsertionEnd","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","bias","AllSelection","atStart","atEnd","cls","selectionClass","getBookmark","between","visible","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","NodeBookmark","isSelectable","selectable","sel","selection","setSelection","AllBookmark","startLen","_from","_to","_newFrom","newTo","Transaction","time","Date","now","curSelection","curSelectionFor","storedMarks","updated","meta","selectionSet","setStoredMarks","addStoredMark","removeStoredMark","storedMarksSet","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","setMeta","getMeta","isGeneric","scrollIntoView","scrolledIntoView","FieldDesc","desc","init","baseFields","config","_marks","_old","prev","Configuration","plugins","fields","pluginsByKey","plugin","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","Plugin","props","createKey","getState","keys","PluginKey","navigator","ie_edge","userAgent","ie_upto10","ie_11up","mac","platform","ie","ie_version","documentMode","gecko","gecko_version","chrome","chrome_version","safari","vendor","ios","maxTouchPoints","android","webkit","documentElement","webkit_version","domIndex","parentNode","host","reusedRange","textRange","createRange","setEnd","setStart","isEquivalentPosition","off","targetNode","targetOff","scanFor","atomElements","hasBlockDesc","contentEditable","pmViewDesc","selectionCollapsed","domSel","collapsed","isCollapsed","browser","rangeCount","getRangeAt","keyEvent","keyCode","event","createEvent","initEvent","code","windowRect","left","right","clientWidth","bottom","clientHeight","getSide","side","clientRect","rect","getBoundingClientRect","scaleX","width","offsetWidth","scaleY","height","offsetHeight","scrollRectIntoView","view","startDOM","scrollThreshold","someProp","scrollMargin","atTop","body","bounding","moveX","moveY","defaultView","scrollBy","startX","scrollLeft","startY","scrollTop","dX","dY","scrollStack","stack","restoreScrollStack","dTop","preventScrollSupported","findOffsetInNode","coords","closest","coordsClosest","dxClosest","rowBot","rowTop","childIndex","rects","getClientRects","dx","len","singleRect","inRect","findOffsetInText","elementFromPoint","element","box","startI","floor","posAtCoords","root","caretPositionFromPoint","caretRangeFromPoint","elt","draggable","targetKludge","outside","docView","nearestDesc","posBefore","posAfter","posFromDOM","posFromCaret","posFromElement","posAtStart","border","BIDI","coordsAtPos","domFromPos","supportEmptyRange","takeSide","flattenV","rectBefore","rectAfter","flattenH","x","y","withFlushedState","viewState","activeElement","updateState","focus","maybeRTL","cachedState","cachedDir","cachedResult","endOfTextblock","nearest","boxes","endOfTextblockVertical","getSelection","modify","oldRange","oldNode","focusNode","oldOff","focusOffset","oldBidiLevel","caretBidiLevel","domAfterPos","removeAllRanges","endOfTextblockHorizontal","ViewDesc","children","dirty","matchesWidget","matchesMark","matchesNode","matchesHack","beforePosition","parseRule","stopEvent","destroy","posBeforeChild","posAtEnd","localPosFromDOM","domBefore","domAfter","onlyNodes","getDesc","nodeDOM","descAt","domAtom","parseRange","fromOffset","toOffset","childBase","emptyChildAt","force","anchorDOM","headDOM","brKludge","anchorNode","anchorOffset","domSelExtended","extend","collapse","DOMException","ignoreMutation","mutation","contentLost","markDirty","startInside","endInside","markParentsDirty","nothing","WidgetViewDesc","widget","raw","classList","stop","ignoreSelection","CompositionViewDesc","textDOM","prototypeAccessors$2","mut","oldValue","MarkViewDesc","custom","nodeViews","replaceNodes","NodeViewDesc","outerDeco","innerDeco","updateChildren","descObj","hasAttribute","applyOuterDeco","CustomNodeViewDesc","TextViewDesc","reparseInView","sameOuterDeco","prototypeAccessors$3","composition","composing","localCompositionNode","updater","ViewTreeUpdater","deco","onWidget","onNode","locals","forChild","decoIndex","restNode","parentIndex","widgets","compareSide","cutAt","filter","iterDeco","insideNode","syncToMarks","placeWidget","findNodeMatch","updateNextNode","addTextblockHacks","destroyRest","changed","protectLocalComposition","renderDescs","oldCSS","cssText","getComputedStyle","listStyle","iosHacks","nearbyTextNode","textPos","childStart","findTextInFragment","removeChild","compositionNodes","updateInner","updateOuterDeco","needsWrap","oldDOM","patchOuterDeco","computeOuterDeco","selectNode","deselectNode","removeAttribute","docViewDesc","pmIsDeco","inParent","trackWrites","parentDOM","prototypeAccessors$4","BRHackViewDesc","prototypeAccessors$5","descs","written","childDOM","rm","insertBefore","OuterDecoLevel","noDeco","class","outerDOM","prevComputed","curComputed","curDOM","patchAttributes","prevList","Boolean","curList","removeProperty","lockedNode","lock","preMatch","fI","dI","Map","selectionFromDOM","origin","inWidget","isOnEdge","selectionBetween","editorOwnsSelection","editable","hasFocus","hasSelection","selectionToDOM","syncNodeSelection","domObserver","disconnectSelection","cursorWrapper","img","disabled","selectCursorWrapper","resetEditableFrom","resetEditableTo","brokenSelectBetweenUneditable","temporarilyEditableNear","resetEditable","removeEventListener","hideSelectionGuard","addEventListener","setTimeout","removeClassOnSelectionChange","setCurSelection","connectSelection","destroyBetween","maxKeep","markDesc","has","nextDOM","setEditable","wasDraggable","lastSelectedViewDesc","clearNodeSelection","moveSelectionBlock","$side","dispatch","selectHorizontally","mods","nodePos","nodeLen","isIgnorable","skipIgnoredNodesLeft","moveNode","moveOffset","isBlockNode","setSelFocus","skipIgnoredNodesRight","selectVertically","beyond","stopNativeHorizontalDelete","nextNode","switchEditable","captureKeyDown","ctrlKey","metaKey","altKey","shiftKey","getMods","safariDownArrowBug","readDOMChange","typeOver","addedNodes","lastSelectionTime","lastSelectionOrigin","newSel","shared","from_","to_","lastKeyCode","startDoc","editableContent","parseBetween","preferredPos","preferredSide","compare","lastKeyCodeTime","change","endA","endB","findDiff","lastIOSEnter","resolveSelection","domChangeCount","nextSel","inlineChange","old","$newStart","$newEnd","skipClosingAndOpening","$next","looksLikeJoin","suppressSelectionUpdates","toB","lastAndroidDelete","markChange","$from1","chFrom","chTo","curMarks","prevMarks","isMarkChange","parsedSel","fromEnd","mayOpen","serializeForClipboard","serializer","detachedDoc","wrapMap","wrapper","parseFromClipboard","html","plainText","inCode","asText","parsed","metas","firstTag","innerHTML","readHTML","contextNode","sliceData","addContext","closeRange","closeSlice","lastWrap","inLast","addToSibling","closeRight","wrapped","withWrappers","normalizeSiblings","sibling","thead","tbody","caption","colgroup","col","td","th","_detachedDoc","implementation","createHTMLDocument","observeOptions","childList","characterData","characterDataOldValue","attributes","attributeOldValue","subtree","useCharData","SelectionState","DOMObserver","handleDOMChange","queue","flushingSoon","observer","MutationObserver","mutations","removedNodes","flushSoon","flush","currentSelection","onCharData","prevValue","onSelectionChange","suppressingSelectionUpdates","forceFlush","clearTimeout","observe","take","takeRecords","disconnect","ignoreSelectionChange","container","commonAncestorContainer","registerMutation","brs","cssChecked","whiteSpace","console","checkCSS","attributeName","handlers","editHandlers","setSelectionOrigin","ensureListeners","currentHandlers","eventHandlers","runCustomHandler","handler","defaultPrevented","eventCoords","clientX","clientY","runHandlerOnContext","propName","updateSelection","focused","handleSingleClick","selectedNode","selectAt","selectClickedNode","selectClickedLeaf","handleDoubleClick","handleTripleClick","defaultTripleClick","forceDOMFlush","endComposition","keydown","inOrNearComposition","preventDefault","lastIOSEnterFallbackTimeout","keyup","keypress","charCode","String","fromCharCode","selectNodeModifier","mousedown","flushed","lastClick","click","dy","isNear","mouseDown","MouseDown","targetPos","allowDefault","mightDrag","targetDesc","addAttr","setUneditable","up","abs","timeStamp","compositionEndedAt","done","touchdown","contextmenu","timeoutComposition","scheduleComposeEnd","delay","composingTimeout","clearComposition","forceUpdate","compositionstart","compositionupdate","markCursor","compositionend","brokenClipboardAPI","doPaste","singleNode","sliceSingleNode","data","clipboardData","clearData","setData","selectNodeContents","blur","captureCopy","paste","getData","capturePaste","Dragging","dragCopyModifier","dragstart","dataTransfer","dragging","dragend","dragover","dragenter","drop","eventPos","$mouse","insertPos","fits","wrapping","dropPoint","isNode","beforeInsert","beforeinput","inputType","compareObjs","WidgetType","noSpec","span","oldOffset","Decoration","valid","InlineType","inclusiveStart","inclusiveEnd","is","DecorationSet","local","decorations","buildTree","predicate","findInner","childOff","mapInner","newLocal","onRemove","oldChildren","oldEnd","newEnd","dSize","mustRebuild","fromLocal","toLocal","childNode","childOffset","gather","mapAndGatherRemainingDecorations","byPos","mapChildren","addInner","baseOffset","takeSpansForNode","moveSpans","withoutNulls","removeInner","dec","localSet","DecorationGroup","removeOverlap","localsInner","members","spans","hasNulls","localStart","working","insertAhead","viewDecorations","sorted","EditorView","_props","_root","mount","mounted","getEditable","updateCursorWrapper","buildNodeViews","computeDocDeco","bubbles","eventBelongsToView","initInput","pluginViews","updatePluginViews","contenteditable","getNodeType","nameOrType","getMarkType","getMarkAttributes","typeOrName","markItem","objectIncludes","object1","object2","isNodeActive","nodeRanges","relativeFrom","relativeTo","nodeRange","selectionRange","sum","isMarkActive","markRanges","markRange","getSchemaTypeNameByName","isActive","schemaType","elementFromString","parseFromString","createNodeFromContent","parseOptions","error","warn","startsWith","endsWith","createDocument","getHTMLFromFragment","isNodeEmpty","defaultContent","handleDOMEvents","updateStateInner","setProps","reconfigured","redraw","updateSel","nA","nB","changedNodeViews","scroll","scrollToSelection","updateDoc","sel1","sel2","newRefTop","oldScrollPos","overflowAnchor","refDOM","refTop","innerHeight","localRect","storeScrollPos","forceSelUpdate","chromeKludge","destroyPluginViews","prevState","pluginView","setActive","stored","preventScroll","focusPreventScroll","getPrototypeOf","domAtPos","posAtDOM","destroyInput","dispatchEvent","dispatchTransaction","CommandManager","[object Object]","editor","commands","buildProps","fromEntries","entries","command","args","callback","startTr","shouldDispatch","callbacks","hasStartTransaction","chain","run","every","createChain","chainableState","can","createCan","8","9","10","12","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","106","107","108","109","110","111","144","145","160","161","162","163","164","165","173","186","187","188","189","190","191","192","219","220","221","222","229","48","49","50","51","52","53","54","55","56","57","brokenModifierNames","normalizeKeyName","alt","ctrl","mod","modifiers","keydownHandler","bindings","normalize","baseName","keyName","isChar","direct","fromCode","withShift","InputRule","cutOff","textBefore","transform","getExtensionField","extension","splitExtensions","extensions","baseExtensions","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","renderHTML","parseHTML","keepOnSplit","addGlobalAttributes","globalAttribute","attribute","addAttributes","mergeAttributes","objects","item","items","mergedAttributes","getRenderedAttributes","nodeOrMark","injectExtensionAttributesToParseRule","oldAttributes","newAttributes","callOrReturn","cleanUpSchemaItem","isEmptyObject","getSchema","allAttributes","extendNodeSchema","extensionAttribute","HTMLAttributes","extendMarkSchema","getSchemaTypeByName","ExtensionManager","splittableMarks","onBeforeCreate","on","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","priorityA","priorityB","addCommands","addKeyboardShortcuts","keyMapPlugin","handleKeyDown","keymap","shortcut","method","addInputRules","enableInputRules","inputRules","inputRulePlugins","handleTextInput","isInputRules","addPasteRules","enablePasteRules","pasteRulePlugins","addProseMirrorPlugins","proseMirrorPlugins","flat","addNodeView","getPos","textSerializers","renderText","isPlainObject","payload","getType","mergeDeep","source","assign","Extension","defaultOptions","extendedConfig","ClipboardTextSerializer","clipboardTextSerializer","textSerializer","extensionManager","emitUpdate","setContent","fromPos","toPos","targetLiftDepth","fn","joinBackward","$cut","findCutBefore","deleteBarrier","textblockAt","selectNodeBackward","joinForward","findCutAfter","selectNodeForward","newlineInCode","defaultBlockAt","exitCode","above","createParagraphNear","liftEmptyBlock","selectAll","conn","joinMaybeClear","canDelAfter","joinAt","selAfter","at","wrapIn","chainCommands","os","originalCreateParagraphNear","originalDeleteSelection","keyboardShortcut","originalExitCode","getMarkRange","link","endPos","newSelection","minMax","isObject","substring","isClass","isTextSelection","position","resolvedFrom","resolvedEnd","isSameSelection","originalJoinBackward","originalJoinForward","includes","KeyboardEvent","cancelable","capturedTransaction","captureTransaction","newStep","originalLift","originalLiftEmptyBlock","wrapInList","listType","doJoin","outerRange","$insert","joinBefore","splitDepth","splitPos","doWrapInList","liftListItem","itemType","endOfList","liftToOuterList","list","indexBefore","liftOutOfList","originalLiftListItem","originalNewlineInCode","deleteProps","propOrProps","newObj","originalSelectAll","originalSelectNodeBackward","originalSelectNodeForward","originalSelectParentNode","trimmedFrom","trimmedTo","applicable","nestedBefore","getSplittedAttributes","filteredMarks","keepMarks","grandParent","keepItem","newNextTypeAttributes","newTypeAttributes","findParentNodeClosestToPos","findParentNode","isList","listTypeOrName","itemTypeOrName","parentList","clearNodes","unsetMark","setMark","toggleTypeOrName","toggleType","setNode","undoable","toUndo","originalUndoInputRule","originalWrapIn","originalWrapInList","Commands","clearContent","extendMarkRange","insertContent","insertHTML","resetAttributes","resetNodeAttributes","selectParentNode","sinkListItem","splitBlock","splitListItem","toggleList","toggleMark","toggleNode","toggleWrap","undoInputRule","unsetAllMarks","updateAttributes","updateNodeAttributes","Editable","FocusEvents","tabindex","isFocused","transaction","Keymap","handleBackspace","handleDelete","Enter","Mod-Enter","Backspace","Mod-Backspace","Delete","Mod-Delete","injectCSS","autofocus","editorProps","setOptions","createExtensionManager","createCommandManager","createSchema","emit","createView","commandManager","createCommands","css","styleNode","getElementsByTagName","createStyleTag","isDestroyed","isEditable","handlePlugins","nameOrPluginKey","allExtensions","createNodeViews","isCapturingTransaction","selectionHasChanged","nodeItem","getNodeAttributes","nameOrAttributes","attributesOrUndefined","isEmpty","removeAllListeners","component","dragHandle","parentElement","domBox","handleBox","offsetX","offsetY","setDragImage","isContentEditable","isDragging","isDraggable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","isDragEvent","once","nodesWithPos","regexp","getAttributes","captureGroup","fullMatch","markEnd","startSpaces","textStart","textEnd","getMarksBetween","outerMatch","matchStart","matchEnd","transformPasted"],"mappings":"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"}