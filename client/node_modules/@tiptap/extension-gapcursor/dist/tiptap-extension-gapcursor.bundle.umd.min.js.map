{"version":3,"file":"tiptap-extension-gapcursor.bundle.umd.min.js","sources":["../../../node_modules/w3c-keyname/index.es.js","../../../node_modules/prosemirror-model/src/diff.js","../../../node_modules/prosemirror-model/src/fragment.js","../../../node_modules/prosemirror-model/src/comparedeep.js","../../../node_modules/prosemirror-model/src/mark.js","../../../node_modules/prosemirror-model/src/replace.js","../../../node_modules/prosemirror-model/src/resolvedpos.js","../../../node_modules/prosemirror-model/src/node.js","../../../node_modules/prosemirror-model/src/content.js","../../../node_modules/prosemirror-model/src/schema.js","../../../node_modules/prosemirror-model/src/from_dom.js","../../../node_modules/prosemirror-model/src/to_dom.js","../../../node_modules/prosemirror-transform/src/map.js","../../../node_modules/prosemirror-transform/src/transform.js","../../../node_modules/prosemirror-transform/src/step.js","../../../node_modules/prosemirror-transform/src/replace_step.js","../../../node_modules/prosemirror-transform/src/mark_step.js","../../../node_modules/prosemirror-transform/src/structure.js","../../../node_modules/prosemirror-transform/src/replace.js","../../../node_modules/prosemirror-transform/src/mark.js","../../../node_modules/prosemirror-state/src/selection.js","../../../node_modules/prosemirror-state/src/transaction.js","../../../node_modules/prosemirror-state/src/state.js","../../../node_modules/prosemirror-state/src/plugin.js","../../../node_modules/prosemirror-keymap/src/keymap.js","../../../node_modules/prosemirror-view/src/browser.js","../../../node_modules/prosemirror-view/src/dom.js","../../../node_modules/prosemirror-view/src/domcoords.js","../../../node_modules/prosemirror-view/src/viewdesc.js","../../../node_modules/prosemirror-view/src/selection.js","../../../node_modules/prosemirror-view/src/capturekeys.js","../../../node_modules/prosemirror-view/src/domchange.js","../../../node_modules/prosemirror-view/src/clipboard.js","../../../node_modules/prosemirror-view/src/domobserver.js","../../../node_modules/prosemirror-view/src/input.js","../../../node_modules/prosemirror-view/src/decoration.js","../../../node_modules/prosemirror-view/src/index.js","../../../node_modules/prosemirror-gapcursor/src/gapcursor.js","../../../node_modules/prosemirror-gapcursor/src/index.js","../src/gapcursor.ts"],"sourcesContent":["export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?string) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?string) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted whenever a new\n  // block node is started. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNode(node, options))\n    })\n\n    return target\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  serializeNodeAndMarks(node, options = {}) {\n    let dom = this.serializeNode(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d)) result.push(d)\n  }\n  return result\n}\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\nimport {ReplaceStep, ReplaceAroundStep} from \"prosemirror-transform\"\n\nconst classesById = Object.create(null)\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nexport class Selection {\n  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])\n  // Initialize a selection with the head and anchor and ranges. If no\n  // ranges are given, constructs a single range across `$anchor` and\n  // `$head`.\n  constructor($anchor, $head, ranges) {\n    // :: [SelectionRange]\n    // The ranges covered by the selection.\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))]\n    // :: ResolvedPos\n    // The resolved anchor of the selection (the side that stays in\n    // place when the selection is modified).\n    this.$anchor = $anchor\n    // :: ResolvedPos\n    // The resolved head of the selection (the side that moves when\n    // the selection is modified).\n    this.$head = $head\n  }\n\n  // :: number\n  // The selection's anchor, as an unresolved position.\n  get anchor() { return this.$anchor.pos }\n\n  // :: number\n  // The selection's head.\n  get head() { return this.$head.pos }\n\n  // :: number\n  // The lower bound of the selection's main range.\n  get from() { return this.$from.pos }\n\n  // :: number\n  // The upper bound of the selection's main range.\n  get to() { return this.$to.pos }\n\n  // :: ResolvedPos\n  // The resolved lower  bound of the selection's main range.\n  get $from() {\n    return this.ranges[0].$from\n  }\n\n  // :: ResolvedPos\n  // The resolved upper bound of the selection's main range.\n  get $to() {\n    return this.ranges[0].$to\n  }\n\n  // :: bool\n  // Indicates whether the selection contains any content.\n  get empty() {\n    let ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos) return false\n    return true\n  }\n\n  // eq:: (Selection) → bool\n  // Test whether the selection is the same as another selection.\n\n  // map:: (doc: Node, mapping: Mappable) → Selection\n  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n  // should be the new document to which we are mapping.\n\n  // :: () → Slice\n  // Get the content of this selection as a slice.\n  content() {\n    return this.$from.node(0).slice(this.from, this.to, true)\n  }\n\n  // :: (Transaction, ?Slice)\n  // Replace the selection with a slice or, if no slice is given,\n  // delete the selection. Will append to the given transaction.\n  replace(tr, content = Slice.empty) {\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild, lastParent = null\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    }\n  }\n\n  // :: (Transaction, Node)\n  // Replace the selection with the given node, appending the changes\n  // to the given transaction.\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      let from = mapping.map($from.pos), to = mapping.map($to.pos)\n      if (i) {\n        tr.deleteRange(from, to)\n      } else {\n        tr.replaceRangeWith(from, to, node)\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)\n      }\n    }\n  }\n\n  // toJSON:: () → Object\n  // Convert the selection to a JSON representation. When implementing\n  // this for a custom selection class, make sure to give the object a\n  // `type` property whose value matches the ID under which you\n  // [registered](#state.Selection^jsonID) your class.\n\n  // :: (ResolvedPos, number, ?bool) → ?Selection\n  // Find a valid cursor or leaf node selection starting at the given\n  // position and searching back if `dir` is negative, and forward if\n  // positive. When `textOnly` is true, only consider cursor\n  // selections. Will return null when no valid selection position is\n  // found.\n  static findFrom($pos, dir, textOnly) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n    if (inner) return inner\n\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0\n          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n      if (found) return found\n    }\n  }\n\n  // :: (ResolvedPos, ?number) → Selection\n  // Find a valid cursor or leaf node selection near the given\n  // position. Searches forward first by default, but if `bias` is\n  // negative, it will search backwards first.\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the start of\n  // the given document. Will return an\n  // [`AllSelection`](#state.AllSelection) if no valid position\n  // exists.\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the end of the\n  // given document.\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n  }\n\n  // :: (Node, Object) → Selection\n  // Deserialize the JSON representation of a selection. Must be\n  // implemented for custom classes (as a static class method).\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\")\n    let cls = classesById[json.type]\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)\n    return cls.fromJSON(doc, json)\n  }\n\n  // :: (string, constructor<Selection>)\n  // To be able to deserialize selections from JSON, custom selection\n  // classes must register themselves with an ID string, so that they\n  // can be disambiguated. Try to pick something that's unlikely to\n  // clash with classes from other modules.\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id)\n    classesById[id] = selectionClass\n    selectionClass.prototype.jsonID = id\n    return selectionClass\n  }\n\n  // :: () → SelectionBookmark\n  // Get a [bookmark](#state.SelectionBookmark) for this selection,\n  // which is a value that can be mapped without having access to a\n  // current document, and later resolved to a real selection for a\n  // given document again. (This is used mostly by the history to\n  // track and restore old selections.) The default implementation of\n  // this method just converts the selection to a text selection and\n  // returns the bookmark for that.\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark()\n  }\n}\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nexport class SelectionRange {\n  // :: (ResolvedPos, ResolvedPos)\n  constructor($from, $to) {\n    // :: ResolvedPos\n    // The lower bound of the range.\n    this.$from = $from\n    // :: ResolvedPos\n    // The upper bound of the range.\n    this.$to = $to\n  }\n}\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nexport class TextSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // Construct a text selection between the given points.\n  constructor($anchor, $head = $anchor) {\n    super($anchor, $head)\n  }\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }\n\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.inlineContent) return Selection.near($head)\n    let $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  }\n\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content)\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to)\n      if (marks) tr.ensureMarks(marks)\n    }\n  }\n\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  }\n\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head)\n  }\n\n  toJSON() {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\")\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  }\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true)\n      if (found) $head = found.$head\n      else return Selection.near($head, bias)\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor\n        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head\n      }\n    }\n    return new TextSelection($anchor, $head)\n  }\n}\n\nSelection.jsonID(\"text\", TextSelection)\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n  }\n}\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nexport class NodeSelection extends Selection {\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument.\n  constructor($pos) {\n    let node = $pos.nodeAfter\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize)\n    super($pos, $end)\n    // :: Node The selected node.\n    this.node = node\n  }\n\n  map(doc, mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    let $pos = doc.resolve(pos)\n    if (deleted) return Selection.near($pos)\n    return new NodeSelection($pos)\n  }\n\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  }\n\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  }\n\n  toJSON() {\n    return {type: \"node\", anchor: this.anchor}\n  }\n\n  getBookmark() { return new NodeBookmark(this.anchor) }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\")\n    return new NodeSelection(doc.resolve(json.anchor))\n  }\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  static create(doc, from) {\n    return new this(doc.resolve(from))\n  }\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false\n  }\n}\n\nNodeSelection.prototype.visible = false\n\nSelection.jsonID(\"node\", NodeSelection)\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor\n  }\n  map(mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)\n    return Selection.near($pos)\n  }\n}\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nexport class AllSelection extends Selection {\n  // :: (Node)\n  // Create an all-selection over the given document.\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size))\n  }\n\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size)\n      let sel = Selection.atStart(tr.doc)\n      if (!sel.eq(tr.selection)) tr.setSelection(sel)\n    } else {\n      super.replace(tr, content)\n    }\n  }\n\n  toJSON() { return {type: \"all\"} }\n\n  static fromJSON(doc) { return new AllSelection(doc) }\n\n  map(doc) { return new AllSelection(doc) }\n\n  eq(other) { return other instanceof AllSelection }\n\n  getBookmark() { return AllBookmark }\n}\n\nSelection.jsonID(\"all\", AllSelection)\n\nconst AllBookmark = {\n  map() { return this },\n  resolve(doc) { return new AllSelection(doc) }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) return TextSelection.create(doc, pos)\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i)\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) return inner\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1\n  if (last < startLen) return\n  let step = tr.steps[last]\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return\n  let map = tr.mapping.maps[last], end\n  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo })\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {Transform} from \"prosemirror-transform\"\nimport {Mark} from \"prosemirror-model\"\nimport {Selection} from \"./selection\"\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nexport class Transaction extends Transform {\n  constructor(state) {\n    super(state.doc)\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  }\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\")\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  }\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0\n  }\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  setStoredMarks(marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  }\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks)\n    return this\n  }\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0\n  }\n\n  addStep(step, doc) {\n    super.addStep(step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  }\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  setTime(time) {\n    this.time = time\n    return this\n  }\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  replaceSelection(slice) {\n    this.selection.replace(this, slice)\n    return this\n  }\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  replaceSelectionWith(node, inheritMarks) {\n    let selection = this.selection\n    if (inheritMarks !== false)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))\n    selection.replaceWith(this, node)\n    return this\n  }\n\n  // :: () → Transaction\n  // Delete the selection.\n  deleteSelection() {\n    this.selection.replace(this)\n    return this\n  }\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  insertText(text, from, to = from) {\n    let schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) return this.deleteSelection()\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) return this.deleteRange(from, to)\n      let marks = this.storedMarks\n      if (!marks) {\n        let $from = this.doc.resolve(from)\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks))\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))\n      return this\n    }\n  }\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  }\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  }\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  get isGeneric() {\n    for (let _ in this.meta) return false\n    return true\n  }\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL\n    return this\n  }\n\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0\n  }\n}\n","import {Node} from \"prosemirror-model\"\n\nimport {Selection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name\n    this.init = bind(desc.init, self)\n    this.apply = bind(desc.apply, self)\n  }\n}\n\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init(config) { return config.storedMarks || null },\n    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init() { return 0 },\n    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema\n    this.fields = baseFields.concat()\n    this.plugins = []\n    this.pluginsByKey = Object.create(null)\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key])\n        throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\")\n      this.plugins.push(plugin)\n      this.pluginsByKey[plugin.key] = plugin\n      if (plugin.spec.state)\n        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin))\n    })\n  }\n}\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nexport class EditorState {\n  constructor(config) {\n    this.config = config\n  }\n\n  // doc:: Node\n  // The current document.\n\n  // selection:: Selection\n  // The selection.\n\n  // storedMarks:: ?[Mark]\n  // A set of marks to apply to the next input. Will be null when\n  // no explicit marks have been set.\n\n  // :: Schema\n  // The schema of the state's document.\n  get schema() {\n    return this.config.schema\n  }\n\n  // :: [Plugin]\n  // The plugins that are active in this state.\n  get plugins() {\n    return this.config.plugins\n  }\n\n  // :: (Transaction) → EditorState\n  // Apply the given transaction to produce a new state.\n  apply(tr) {\n    return this.applyTransaction(tr).state\n  }\n\n  // : (Transaction) → bool\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i]\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n        return false\n    }\n    return true\n  }\n\n  // :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n  // Verbose variant of [`apply`](#state.EditorState.apply) that\n  // returns the precise transactions that were applied (which might\n  // be influenced by the [transaction\n  // hooks](#state.PluginSpec.filterTransaction) of\n  // plugins) along with the new state.\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}\n\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    outer: for (;;) {\n      let haveNew = false\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i]\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this\n          let tr = n < trs.length &&\n              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr)\n            if (!seen) {\n              seen = []\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0})\n            }\n            trs.push(tr)\n            newState = newState.applyInner(tr)\n            haveNew = true\n          }\n          if (seen) seen[i] = {state: newState, n: trs.length}\n        }\n      }\n      if (!haveNew) return {state: newState, transactions: trs}\n    }\n  }\n\n  // : (Transaction) → EditorState\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\")\n    let newInstance = new EditorState(this.config), fields = this.config.fields\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i]\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance)\n    }\n    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance)\n    return newInstance\n  }\n\n  // :: Transaction\n  // Start a [transaction](#state.Transaction) from this state.\n  get tr() { return new Transaction(this) }\n\n  // :: (Object) → EditorState\n  // Create a new state.\n  //\n  //   config::- Configuration options. Must contain `schema` or `doc` (or both).\n  //\n  //      schema:: ?Schema\n  //      The schema to use (only relevant if no `doc` is specified).\n  //\n  //      doc:: ?Node\n  //      The starting document.\n  //\n  //      selection:: ?Selection\n  //      A valid selection in the document.\n  //\n  //      storedMarks:: ?[Mark]\n  //      The initial set of [stored marks](#state.EditorState.storedMarks).\n  //\n  //      plugins:: ?[Plugin]\n  //      The plugins that should be active in this state.\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins)\n    let instance = new EditorState($config)\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance)\n    return instance\n  }\n\n  // :: (Object) → EditorState\n  // Create a new state based on this one, but with an adjusted set of\n  // active plugins. State fields that exist in both sets of plugins\n  // are kept unchanged. Those that no longer exist are dropped, and\n  // those that are new are initialized using their\n  // [`init`](#state.StateField.init) method, passing in the new\n  // configuration object..\n  //\n  //   config::- configuration options\n  //\n  //     plugins:: [Plugin]\n  //     New set of active plugins.\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins)\n    let fields = $config.fields, instance = new EditorState($config)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance)\n    }\n    return instance\n  }\n\n  // :: (?union<Object<Plugin>, string, number>) → Object\n  // Serialize this state to JSON. If you want to serialize the state\n  // of plugins, pass an object mapping property names to use in the\n  // resulting JSON object to plugin objects. The argument may also be\n  // a string or number, in which case it is ignored, to support the\n  // way `JSON.stringify` calls `toString` methods.\n  toJSON(pluginFields) {\n    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON())\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\")\n        throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\")\n      let plugin = pluginFields[prop], state = plugin.spec.state\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key])\n    }\n    return result\n  }\n\n  // :: (Object, Object, ?Object<Plugin>) → EditorState\n  // Deserialize a JSON representation of a state. `config` should\n  // have at least a `schema` field, and should contain array of\n  // plugins to initialize the state with. `pluginFields` can be used\n  // to deserialize the state of plugins, by associating plugin\n  // instances with the property names they use in the JSON object.\n  //\n  //   config::- configuration options\n  //\n  //     schema:: Schema\n  //     The schema to use.\n  //\n  //     plugins:: ?[Plugin]\n  //     The set of active plugins.\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\")\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\")\n    let $config = new Configuration(config.schema, config.plugins)\n    let instance = new EditorState($config)\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc)\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection)\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON)\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop], state = plugin.spec.state\n          if (plugin.key == field.name && state && state.fromJSON &&\n              Object.prototype.hasOwnProperty.call(json, prop)) {\n            // This field belongs to a plugin mapped to a JSON field, read it from there.\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n            return\n          }\n        }\n        instance[field.name] = field.init(config, instance)\n      }\n    })\n    return instance\n  }\n\n  // Kludge to allow the view to track mappings between different\n  // instances of a state.\n  //\n  // FIXME this is no longer needed as of prosemirror-view 1.9.0,\n  // though due to backwards-compat we should probably keep it around\n  // for a while (if only as a no-op)\n  static addApplyListener(f) {\n    applyListeners.push(f)\n  }\n  static removeApplyListener(f) {\n    let found = applyListeners.indexOf(f)\n    if (found > -1) applyListeners.splice(found, 1)\n  }\n}\n\nconst applyListeners = []\n","// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop]\n    if (val instanceof Function) val = val.bind(self)\n    else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {})\n    target[prop] = val\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nexport class Plugin {\n  // :: (PluginSpec)\n  // Create a plugin.\n  constructor(spec) {\n    // :: EditorProps\n    // The [props](#view.EditorProps) exported by this plugin.\n    this.props = {}\n    if (spec.props) bindProps(spec.props, this, this.props)\n    // :: Object\n    // The plugin's [spec object](#state.PluginSpec).\n    this.spec = spec\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\")\n  }\n\n  // :: (EditorState) → any\n  // Extract the plugin's state field from an editor state.\n  getState(state) { return state[this.key] }\n}\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nconst keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name]\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nexport class PluginKey {\n  // :: (?string)\n  // Create a plugin key.\n  constructor(name = \"key\") { this.key = createKey(name) }\n\n  // :: (EditorState) → ?Plugin\n  // Get the active plugin with this key, if any, from an editor\n  // state.\n  get(state) { return state.config.pluginsByKey[this.key] }\n\n  // :: (EditorState) → ?any\n  // Get the plugin's state from an editor state.\n  getState(state) { return state[this.key] }\n}\n","import {base, keyName} from \"w3c-keyname\"\nimport {Plugin} from \"prosemirror-state\"\n\n// declare global: navigator\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") result = \" \"\n  let alt, ctrl, shift, meta\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true\n    else if (/^a(lt)?$/i.test(mod)) alt = true\n    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n    else if (/^s(hift)?$/i.test(mod)) shift = true\n    else if (/^mod$/i.test(mod)) { if (mac) meta = true; else ctrl = true }\n    else throw new Error(\"Unrecognized modifier name: \" + mod)\n  }\n  if (alt) result = \"Alt-\" + result\n  if (ctrl) result = \"Ctrl-\" + result\n  if (meta) result = \"Meta-\" + result\n  if (shift) result = \"Shift-\" + result\n  return result\n}\n\nfunction normalize(map) {\n  let copy = Object.create(null)\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop]\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name\n  if (event.ctrlKey) name = \"Ctrl-\" + name\n  if (event.metaKey) name = \"Meta-\" + name\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nexport function keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nexport function keydownHandler(bindings) {\n  let map = normalize(bindings)\n  return function(view, event) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n    let direct = map[modifiers(name, event, !isChar)]\n    if (direct && direct(view.state, view.dispatch, view)) return true\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      let fromCode = map[modifiers(baseName, event, true)]\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      let withShift = map[modifiers(name, event, true)]\n      if (withShift && withShift(view.state, view.dispatch, view)) return true\n    }\n    return false\n  }\n}\n","const result = {}\nexport default result\n\nif (typeof navigator != \"undefined\" && typeof document != \"undefined\") {\n  const ie_edge = /Edge\\/(\\d+)/.exec(navigator.userAgent)\n  const ie_upto10 = /MSIE \\d/.test(navigator.userAgent)\n  const ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n  result.mac = /Mac/.test(navigator.platform)\n  let ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge)\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null\n  result.gecko = !ie && /gecko\\/(\\d+)/i.test(navigator.userAgent)\n  result.gecko_version = result.gecko && +(/Firefox\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1]\n  let chrome = !ie && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\n  result.chrome = !!chrome\n  result.chrome_version = chrome && +chrome[1]\n  // Is true for both iOS and iPadOS for convenience\n  result.safari = !ie && /Apple Computer/.test(navigator.vendor)\n  result.ios = result.safari && (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2)\n  result.android = /Android \\d/.test(navigator.userAgent)\n  result.webkit = \"webkitFontSmoothing\" in document.documentElement.style\n  result.webkit_version = result.webkit && +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1]\n}\n","import browser from \"./browser\"\n\nexport const domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling\n    if (!node) return index\n  }\n}\n\nexport const parentNode = function(node) {\n  let parent = node.parentNode\n  return parent && parent.nodeType == 11 ? parent.host : parent\n}\n\nlet reusedRange = null\n\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nexport const textRange = function(node, from, to) {\n  let range = reusedRange || (reusedRange = document.createRange())\n  range.setEnd(node, to == null ? node.nodeValue.length : to)\n  range.setStart(node, from || 0)\n  return range\n}\n\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nexport const isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n                        scanFor(node, off, targetNode, targetOff, 1))\n}\n\nconst atomElements = /^(img|br|input|textarea|hr)$/i\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      let parent = node.parentNode\n      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        return false\n      off = domIndex(node) + (dir < 0 ? 0 : 1)\n      node = parent\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)]\n      if (node.contentEditable == \"false\") return false\n      off = dir < 0 ? nodeSize(node) : 0\n    } else {\n      return false\n    }\n  }\n}\n\nexport function nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nexport function isOnEdge(node, offset, parent) {\n  for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n    if (node == parent) return true\n    let index = domIndex(node)\n    node = node.parentNode\n    if (!node) return false\n    atStart = atStart && index == 0\n    atEnd = atEnd && index == nodeSize(node)\n  }\n}\n\nfunction hasBlockDesc(dom) {\n  let desc\n  for (let cur = dom; cur; cur = cur.parentNode) if (desc = cur.pmViewDesc) break\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)\n}\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nexport const selectionCollapsed = function(domSel) {\n  let collapsed = domSel.isCollapsed\n  if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n    collapsed = false\n  return collapsed\n}\n\nexport function keyEvent(keyCode, key) {\n  let event = document.createEvent(\"Event\")\n  event.initEvent(\"keydown\", true, true)\n  event.keyCode = keyCode\n  event.key = event.code = key\n  return event\n}\n","import {nodeSize, textRange, parentNode} from \"./dom\"\nimport browser from \"./browser\"\n\nfunction windowRect(doc) {\n  return {left: 0, right: doc.documentElement.clientWidth,\n          top: 0, bottom: doc.documentElement.clientHeight}\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side]\n}\n\nfunction clientRect(node) {\n  let rect = node.getBoundingClientRect()\n  // Adjust for elements with style \"transform: scale()\"\n  let scaleX = (rect.width / node.offsetWidth) || 1\n  let scaleY = (rect.height / node.offsetHeight) || 1\n  // Make sure scrollbar width isn't included in the rectangle\n  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,\n          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}\n}\n\nexport function scrollRectIntoView(view, rect, startDOM) {\n  let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5\n  let doc = view.dom.ownerDocument\n  for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) break\n    if (parent.nodeType != 1) continue\n    let atTop = parent == doc.body || parent.nodeType != 1\n    let bounding = atTop ? windowRect(doc) : clientRect(parent)\n    let moveX = 0, moveY = 0\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"))\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\")\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"))\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\")\n    if (moveX || moveY) {\n      if (atTop) {\n        doc.defaultView.scrollBy(moveX, moveY)\n      } else {\n        let startX = parent.scrollLeft, startY = parent.scrollTop\n        if (moveY) parent.scrollTop += moveY\n        if (moveX) parent.scrollLeft += moveX\n        let dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY\n        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY}\n      }\n    }\n    if (atTop) break\n  }\n}\n\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nexport function storeScrollPos(view) {\n  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top)\n  let refDOM, refTop\n  for (let x = (rect.left + rect.right) / 2, y = startY + 1;\n       y < Math.min(innerHeight, rect.bottom); y += 5) {\n    let dom = view.root.elementFromPoint(x, y)\n    if (dom == view.dom || !view.dom.contains(dom)) continue\n    let localRect = dom.getBoundingClientRect()\n    if (localRect.top >= startY - 20) {\n      refDOM = dom\n      refTop = localRect.top\n      break\n    }\n  }\n  return {refDOM, refTop, stack: scrollStack(view.dom)}\n}\n\nfunction scrollStack(dom) {\n  let stack = [], doc = dom.ownerDocument\n  for (; dom; dom = parentNode(dom)) {\n    stack.push({dom, top: dom.scrollTop, left: dom.scrollLeft})\n    if (dom == doc) break\n  }\n  return stack\n}\n\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nexport function resetScrollPos({refDOM, refTop, stack}) {\n  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop)\n}\n\nfunction restoreScrollStack(stack, dTop) {\n  for (let i = 0; i < stack.length; i++) {\n    let {dom, top, left} = stack[i]\n    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop\n    if (dom.scrollLeft != left) dom.scrollLeft = left\n  }\n}\n\nlet preventScrollSupported = null\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nexport function focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive() // in IE\n  if (preventScrollSupported) return dom.focus(preventScrollSupported)\n\n  let stored = scrollStack(dom)\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {preventScroll: true}\n      return true\n    }\n  } : undefined)\n  if (!preventScrollSupported) {\n    preventScrollSupported = false\n    restoreScrollStack(stored, 0)\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  let closest, dxClosest = 2e8, coordsClosest, offset = 0\n  let rowBot = coords.top, rowTop = coords.top\n  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    let rects\n    if (child.nodeType == 1) rects = child.getClientRects()\n    else if (child.nodeType == 3) rects = textRange(child).getClientRects()\n    else continue\n\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i]\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot)\n        rowTop = Math.min(rect.top, rowTop)\n        let dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0\n        if (dx < dxClosest) {\n          closest = child\n          dxClosest = dx\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords\n          if (child.nodeType == 1 && dx)\n            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        offset = childIndex + 1\n    }\n  }\n  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest)\n  if (!closest || (dxClosest && closest.nodeType == 1)) return {node, offset}\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  let len = node.nodeValue.length\n  let range = document.createRange()\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1)\n    range.setStart(node, i)\n    let rect = singleRect(range, 1)\n    if (rect.top == rect.bottom) continue\n    if (inRect(coords, rect))\n      return {node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)}\n  }\n  return {node, offset: 0}\n}\n\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&\n    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1\n}\n\nfunction targetKludge(dom, coords) {\n  let parent = dom.parentNode\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    return parent\n  return dom\n}\n\nfunction posFromElement(view, elt, coords) {\n  let {node, offset} = findOffsetInNode(elt, coords), bias = -1\n  if (node.nodeType == 1 && !node.firstChild) {\n    let rect = node.getBoundingClientRect()\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1\n  }\n  return view.docView.posFromDOM(node, offset, bias)\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  // Browser (in caretPosition/RangeFromPoint) will agressively\n  // normalize towards nearby inline nodes. Since we are interested in\n  // positions between block nodes too, we first walk up the hierarchy\n  // of nodes to see if there are block nodes that the coordinates\n  // fall outside of. If so, we take the position before/after that\n  // block. If not, we call `posFromDOM` on the raw node/offset.\n  let outside = -1\n  for (let cur = node;;) {\n    if (cur == view.dom) break\n    let desc = view.docView.nearestDesc(cur, true)\n    if (!desc) return null\n    if (desc.node.isBlock && desc.parent) {\n      let rect = desc.dom.getBoundingClientRect()\n      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore\n      else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter\n      else break\n    }\n    cur = desc.dom.parentNode\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)\n}\n\nfunction elementFromPoint(element, coords, box) {\n  let len = element.childNodes.length\n  if (len && box.top < box.bottom) {\n    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n      let child = element.childNodes[i]\n      if (child.nodeType == 1) {\n        let rects = child.getClientRects()\n        for (let j = 0; j < rects.length; j++) {\n          let rect = rects[j]\n          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect)\n        }\n      }\n      if ((i = (i + 1) % len) == startI) break\n    }\n  }\n  return element\n}\n\n// Given an x,y position on the editor, get the position in the document.\nexport function posAtCoords(view, coords) {\n  let root = view.root, node, offset\n  if (root.caretPositionFromPoint) {\n    try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n      let pos = root.caretPositionFromPoint(coords.left, coords.top)\n      if (pos) ({offsetNode: node, offset} = pos)\n    } catch (_) {}\n  }\n  if (!node && root.caretRangeFromPoint) {\n    let range = root.caretRangeFromPoint(coords.left, coords.top)\n    if (range) ({startContainer: node, startOffset: offset} = range)\n  }\n\n  let elt = root.elementFromPoint(coords.left, coords.top + 1), pos\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    let box = view.dom.getBoundingClientRect()\n    if (!inRect(coords, box)) return null\n    elt = elementFromPoint(view.dom, coords, box)\n    if (!elt) return null\n  }\n  // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n  if (browser.safari && elt.draggable) node = offset = null\n  elt = targetKludge(elt, coords)\n  if (node) {\n    if (browser.gecko && node.nodeType == 1) {\n      // Firefox will sometimes return offsets into <input> nodes, which\n      // have no actual children, from caretPositionFromPoint (#953)\n      offset = Math.min(offset, node.childNodes.length)\n      // It'll also move the returned position before image nodes,\n      // even if those are behind it.\n      if (offset < node.childNodes.length) {\n        let next = node.childNodes[offset], box\n        if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left &&\n            box.bottom > coords.top)\n          offset++\n      }\n    }\n    // Suspiciously specific kludge to work around caret*FromPoint\n    // never returning a position at the end of the document\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n        coords.top > node.lastChild.getBoundingClientRect().bottom)\n      pos = view.state.doc.content.size\n    // Ignore positions directly after a BR, since caret*FromPoint\n    // 'round up' positions that would be more accurately placed\n    // before the BR node.\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      pos = posFromCaret(view, node, offset, coords)\n  }\n  if (pos == null) pos = posFromElement(view, elt, coords)\n\n  let desc = view.docView.nearestDesc(elt, true)\n  return {pos, inside: desc ? desc.posAtStart - desc.border : -1}\n}\n\nfunction singleRect(object, bias) {\n  let rects = object.getClientRects()\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/\n\n// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nexport function coordsAtPos(view, pos, side) {\n  let {node, offset} = view.docView.domFromPos(pos, side < 0 ? -1 : 1)\n\n  let supportEmptyRange = browser.webkit || browser.gecko\n  if (node.nodeType == 3) {\n    // These browsers support querying empty text ranges. Prefer that in\n    // bidi context or when at the end of a node.\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      let rect = singleRect(textRange(node, offset, offset), side)\n      // Firefox returns bad results (the position before the space)\n      // when querying a position directly after line-broken\n      // whitespace. Detect this situation and and kludge around it\n      if (browser.gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1)\n        if (rectBefore.top == rect.top) {\n          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1)\n          if (rectAfter.top != rect.top)\n            return flattenV(rectAfter, rectAfter.left < rectBefore.left)\n        }\n      }\n      return rect\n    } else {\n      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1\n      if (side < 0 && !offset) { to++; takeSide = -1 }\n      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1 }\n      else if (side < 0) { from-- }\n      else { to ++ }\n      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)\n    }\n  }\n\n  // Return a horizontal line in block context\n  if (!view.state.doc.resolve(pos).parent.inlineContent) {\n    if (offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1]\n      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false)\n    }\n    if (offset < nodeSize(node)) {\n      let after = node.childNodes[offset]\n      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true)\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0)\n  }\n\n  // Inline, not in text node (this is not Bidi-safe)\n  if (offset && (side < 0 || offset == nodeSize(node))) {\n    let before = node.childNodes[offset - 1]\n    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n        // BR nodes tend to only return the rectangle before them.\n        // Only use them if they are the last element in their parent\n        : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null\n    if (target) return flattenV(singleRect(target, 1), false)\n  }\n  if (offset < nodeSize(node)) {\n    let after = node.childNodes[offset]\n    let target = after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n        : after.nodeType == 1 ? after : null\n    if (target) return flattenV(singleRect(target, -1), true)\n  }\n  // All else failed, just try to get a rectangle for the target node\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)\n}\n\nfunction flattenV(rect, left) {\n  if (rect.width == 0) return rect\n  let x = left ? rect.left : rect.right\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\n\nfunction flattenH(rect, top) {\n  if (rect.height == 0) return rect\n  let y = top ? rect.top : rect.bottom\n  return {top: y, bottom: y, left: rect.left, right: rect.right}\n}\n\nfunction withFlushedState(view, state, f) {\n  let viewState = view.state, active = view.root.activeElement\n  if (viewState != state) view.updateState(state)\n  if (active != view.dom) view.focus()\n  try {\n    return f()\n  } finally {\n    if (viewState != state) view.updateState(viewState)\n    if (active != view.dom && active) active.focus()\n  }\n}\n\n// : (EditorView, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  let sel = state.selection\n  let $pos = dir == \"up\" ? sel.$from : sel.$to\n  return withFlushedState(view, state, () => {\n    let {node: dom} = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1)\n    for (;;) {\n      let nearest = view.docView.nearestDesc(dom, true)\n      if (!nearest) break\n      if (nearest.node.isBlock) { dom = nearest.dom; break }\n      dom = nearest.dom.parentNode\n    }\n    let coords = coordsAtPos(view, $pos.pos, 1)\n    for (let child = dom.firstChild; child; child = child.nextSibling) {\n      let boxes\n      if (child.nodeType == 1) boxes = child.getClientRects()\n      else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects()\n      else continue\n      for (let i = 0; i < boxes.length; i++) {\n        let box = boxes[i]\n        if (box.bottom > box.top && (dir == \"up\" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))\n          return false\n      }\n    }\n    return true\n  })\n}\n\nconst maybeRTL = /[\\u0590-\\u08ac]/\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  let {$head} = state.selection\n  if (!$head.parent.isTextblock) return false\n  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size\n  let sel = getSelection()\n  // If the textblock is all LTR, or the browser doesn't support\n  // Selection.modify (Edge), fall back to a primitive approach\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    return dir == \"left\" || dir == \"backward\" ? atStart : atEnd\n\n  return withFlushedState(view, state, () => {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset\n    let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n    sel.modify(\"move\", dir, \"character\")\n    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom\n    let result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        (oldNode == sel.focusNode && oldOff == sel.focusOffset)\n    // Restore the previous selection\n    sel.removeAllRanges()\n    sel.addRange(oldRange)\n    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel\n    return result\n  })\n}\n\nlet cachedState = null, cachedDir = null, cachedResult = false\nexport function endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) return cachedResult\n  cachedState = state; cachedDir = dir\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\n","import {DOMSerializer, Fragment, Mark} from \"prosemirror-model\"\nimport {TextSelection} from \"prosemirror-state\"\n\nimport {domIndex, isEquivalentPosition, nodeSize} from \"./dom\"\nimport browser from \"./browser\"\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, you want more control over\n// the behavior of a node's in-editor representation, and need to\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n// Mark views only support `dom` and `contentDOM`, and don't support\n// any of the node view methods.\n//\n// Objects returned as node views must conform to this interface.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), an array\n//   of active decorations around the node (which are automatically\n//   drawn, and the node view may ignore if it isn't interested in\n//   them), and a [decoration source](#view.DecorationSource) that\n//   represents any decorations that apply to the content of the node\n//   (which again may be ignored). It should return true if it was\n//   able to update to that node, and false otherwise. If the node\n//   view has a `contentDOM` property (or no `dom` property), updating\n//   its child nodes will be handled by ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to remove the effect again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. The `anchor` and `head` positions are relative to the start\n//   of the node. By default, a DOM selection will be created between\n//   the DOM positions corresponding to those positions, but if you\n//   override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view. Events for\n//   which this returns true are not handled by the editor.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   or a selection change happens within the view. When the change is\n//   a selection change, the record will have a `type` property of\n//   `\"selection\"` (which doesn't occur for native mutation records).\n//   Return false if the editor should re-read the selection or\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is destroyed. (Not available for marks.)\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n  // : (?ViewDesc, [ViewDesc], dom.Node, ?dom.Node)\n  constructor(parent, children, dom, contentDOM) {\n    this.parent = parent\n    this.children = children\n    this.dom = dom\n    // An expando property on the DOM node provides a link back to its\n    // description.\n    dom.pmViewDesc = this\n    // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    this.contentDOM = contentDOM\n    this.dirty = NOT_DIRTY\n  }\n\n  // Used to check whether a given description corresponds to a\n  // widget/mark/node.\n  matchesWidget() { return false }\n  matchesMark() { return false }\n  matchesNode() { return false }\n  matchesHack() { return false }\n\n  get beforePosition() { return false }\n\n  // : () → ?ParseRule\n  // When parsing in-editor content (in domchange.js), we allow\n  // descriptions to determine the parse rules that should be used to\n  // parse them.\n  parseRule() { return null }\n\n  // : (dom.Event) → bool\n  // Used by the editor's event handler to ignore events that come\n  // from certain descs.\n  stopEvent() { return false }\n\n  // The size of the content represented by this desc.\n  get size() {\n    let size = 0\n    for (let i = 0; i < this.children.length; i++) size += this.children[i].size\n    return size\n  }\n\n  // For block nodes, this represents the space taken up by their\n  // start/end tokens.\n  get border() { return 0 }\n\n  destroy() {\n    this.parent = null\n    if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = null\n    for (let i = 0; i < this.children.length; i++)\n      this.children[i].destroy()\n  }\n\n  posBeforeChild(child) {\n    for (let i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n      let cur = this.children[i]\n      if (cur == child) return pos\n      pos += cur.size\n    }\n  }\n\n  get posBefore() {\n    return this.parent.posBeforeChild(this)\n  }\n\n  get posAtStart() {\n    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n  }\n\n  get posAfter() {\n    return this.posBefore + this.size\n  }\n\n  get posAtEnd() {\n    return this.posAtStart + this.size - 2 * this.border\n  }\n\n  // : (dom.Node, number, ?number) → number\n  localPosFromDOM(dom, offset, bias) {\n    // If the DOM position is in the content, use the child desc after\n    // it to figure out a position.\n    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n      if (bias < 0) {\n        let domBefore, desc\n        if (dom == this.contentDOM) {\n          domBefore = dom.childNodes[offset - 1]\n        } else {\n          while (dom.parentNode != this.contentDOM) dom = dom.parentNode\n          domBefore = dom.previousSibling\n        }\n        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling\n        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n      } else {\n        let domAfter, desc\n        if (dom == this.contentDOM) {\n          domAfter = dom.childNodes[offset]\n        } else {\n          while (dom.parentNode != this.contentDOM) dom = dom.parentNode\n          domAfter = dom.nextSibling\n        }\n        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this)) domAfter = domAfter.nextSibling\n        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd\n      }\n    }\n    // Otherwise, use various heuristics, falling back on the bias\n    // parameter, to determine whether to return the position at the\n    // start or at the end of this view desc.\n    let atEnd\n    if (dom == this.dom && this.contentDOM) {\n      atEnd = offset > domIndex(this.contentDOM)\n    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2\n    } else if (this.dom.firstChild) {\n      if (offset == 0) for (let search = dom;; search = search.parentNode) {\n        if (search == this.dom) { atEnd = false; break }\n        if (search.parentNode.firstChild != search) break\n      }\n      if (atEnd == null && offset == dom.childNodes.length) for (let search = dom;; search = search.parentNode) {\n        if (search == this.dom) { atEnd = true; break }\n        if (search.parentNode.lastChild != search) break\n      }\n    }\n    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n  }\n\n  // Scan up the dom finding the first desc that is a descendant of\n  // this one.\n  nearestDesc(dom, onlyNodes) {\n    for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n      let desc = this.getDesc(cur)\n      if (desc && (!onlyNodes || desc.node)) {\n        // If dom is outside of this desc's nodeDOM, don't count it.\n        if (first && desc.nodeDOM &&\n            !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))\n          first = false\n        else\n          return desc\n      }\n    }\n  }\n\n  getDesc(dom) {\n    let desc = dom.pmViewDesc\n    for (let cur = desc; cur; cur = cur.parent) if (cur == this) return desc\n  }\n\n  posFromDOM(dom, offset, bias) {\n    for (let scan = dom; scan; scan = scan.parentNode) {\n      let desc = this.getDesc(scan)\n      if (desc) return desc.localPosFromDOM(dom, offset, bias)\n    }\n    return -1\n  }\n\n  // : (number) → ?NodeViewDesc\n  // Find the desc for the node after the given pos, if any. (When a\n  // parent node overrode rendering, there might not be one.)\n  descAt(pos) {\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (offset == pos && end != offset) {\n        while (!child.border && child.children.length) child = child.children[0]\n        return child\n      }\n      if (pos < end) return child.descAt(pos - offset - child.border)\n      offset = end\n    }\n  }\n\n  // : (number, number) → {node: dom.Node, offset: number}\n  domFromPos(pos, side) {\n    if (!this.contentDOM) return {node: this.dom, offset: 0}\n    for (let offset = 0, i = 0, first = true;; i++, first = false) {\n      // Skip removed or always-before children\n      while (i < this.children.length && (this.children[i].beforePosition ||\n                                          this.children[i].dom.parentNode != this.contentDOM))\n        offset += this.children[i++].size\n      let child = i == this.children.length ? null : this.children[i]\n      if (offset == pos && (side == 0 || !child || !child.size || child.border || (side < 0 && first)) ||\n          child && child.domAtom && pos < offset + child.size) return {\n        node: this.contentDOM,\n        offset: child ? domIndex(child.dom) : this.contentDOM.childNodes.length\n      }\n      if (!child) throw new Error(\"Invalid position \" + pos)\n      let end = offset + child.size\n      if (!child.domAtom && (side < 0 && !child.border ? end >= pos : end > pos) &&\n          (end > pos || i + 1 >= this.children.length || !this.children[i + 1].beforePosition))\n        return child.domFromPos(pos - offset - child.border, side)\n      offset = end\n    }\n  }\n\n  // Used to find a DOM range in a single parent for a given changed\n  // range.\n  parseRange(from, to, base = 0) {\n    if (this.children.length == 0)\n      return {node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length}\n\n    let fromOffset = -1, toOffset = -1\n    for (let offset = base, i = 0;; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (fromOffset == -1 && from <= end) {\n        let childBase = offset + child.border\n        // FIXME maybe descend mark views to parse a narrower range?\n        if (from >= childBase && to <= end - child.border && child.node &&\n            child.contentDOM && this.contentDOM.contains(child.contentDOM))\n          return child.parseRange(from, to, childBase)\n\n        from = offset\n        for (let j = i; j > 0; j--) {\n          let prev = this.children[j - 1]\n          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n            fromOffset = domIndex(prev.dom) + 1\n            break\n          }\n          from -= prev.size\n        }\n        if (fromOffset == -1) fromOffset = 0\n      }\n      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n        to = end\n        for (let j = i + 1; j < this.children.length; j++) {\n          let next = this.children[j]\n          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n            toOffset = domIndex(next.dom)\n            break\n          }\n          to += next.size\n        }\n        if (toOffset == -1) toOffset = this.contentDOM.childNodes.length\n        break\n      }\n      offset = end\n    }\n    return {node: this.contentDOM, from, to, fromOffset, toOffset}\n  }\n\n  emptyChildAt(side) {\n    if (this.border || !this.contentDOM || !this.children.length) return false\n    let child = this.children[side < 0 ? 0 : this.children.length - 1]\n    return child.size == 0 || child.emptyChildAt(side)\n  }\n\n  // : (number) → dom.Node\n  domAfterPos(pos) {\n    let {node, offset} = this.domFromPos(pos, 0)\n    if (node.nodeType != 1 || offset == node.childNodes.length)\n      throw new RangeError(\"No node after pos \" + pos)\n    return node.childNodes[offset]\n  }\n\n  // : (number, number, dom.Document)\n  // View descs are responsible for setting any selection that falls\n  // entirely inside of them, so that custom implementations can do\n  // custom things with the selection. Note that this falls apart when\n  // a selection starts in such a node and ends in another, in which\n  // case we just use whatever domFromPos produces as a best effort.\n  setSelection(anchor, head, root, force) {\n    // If the selection falls entirely in a child, give it to that child\n    let from = Math.min(anchor, head), to = Math.max(anchor, head)\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (from > offset && to < end)\n        return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force)\n      offset = end\n    }\n\n    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1)\n    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1)\n    let domSel = root.getSelection()\n\n    let brKludge = false\n    // On Firefox, using Selection.collapse to put the cursor after a\n    // BR node for some reason doesn't always work (#1073). On Safari,\n    // the cursor sometimes inexplicable visually lags behind its\n    // reported position in such situations (#1092).\n    if ((browser.gecko || browser.safari) && anchor == head) {\n      let {node, offset} = anchorDOM\n      if (node.nodeType == 3) {\n        brKludge = offset && node.nodeValue[offset - 1] == \"\\n\"\n        // Issue #1128\n        if (brKludge && offset == node.nodeValue.length &&\n            node.nextSibling && node.nextSibling.nodeName == \"BR\")\n          anchorDOM = headDOM = {node: node.parentNode, offset: domIndex(node) + 1}\n      } else {\n        let prev = node.childNodes[offset - 1]\n        brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\")\n      }\n    }\n\n    if (!(force || brKludge && browser.safari) &&\n        isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n        isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n      return\n\n    // Selection.extend can be used to create an 'inverted' selection\n    // (one where the focus is before the anchor), but not all\n    // browsers support it yet.\n    let domSelExtended = false\n    if ((domSel.extend || anchor == head) && !brKludge) {\n      domSel.collapse(anchorDOM.node, anchorDOM.offset)\n      try {\n        if (anchor != head) domSel.extend(headDOM.node, headDOM.offset)\n        domSelExtended = true\n      } catch (err) {\n        // In some cases with Chrome the selection is empty after calling\n        // collapse, even when it should be valid. This appears to be a bug, but\n        // it is difficult to isolate. If this happens fallback to the old path\n        // without using extend.\n        if (!(err instanceof DOMException)) throw err\n        // declare global: DOMException\n      }\n    }\n    if (!domSelExtended) {\n      if (anchor > head) { let tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp }\n      let range = document.createRange()\n      range.setEnd(headDOM.node, headDOM.offset)\n      range.setStart(anchorDOM.node, anchorDOM.offset)\n      domSel.removeAllRanges()\n      domSel.addRange(range)\n    }\n  }\n\n  // : (dom.MutationRecord) → bool\n  ignoreMutation(mutation) {\n    return !this.contentDOM && mutation.type != \"selection\"\n  }\n\n  get contentLost() {\n    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)\n  }\n\n  // Remove a subtree of the element tree that has been touched\n  // by a DOM change, so that the next update will redraw it.\n  markDirty(from, to) {\n    for (let offset = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size\n      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n        let startInside = offset + child.border, endInside = end - child.border\n        if (from >= startInside && to <= endInside) {\n          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY\n          if (from == startInside && to == endInside &&\n              (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY\n          else child.markDirty(from - startInside, to - startInside)\n          return\n        } else {\n          child.dirty = NODE_DIRTY\n        }\n      }\n      offset = end\n    }\n    this.dirty = CONTENT_DIRTY\n  }\n\n  markParentsDirty() {\n    let level = 1\n    for (let node = this.parent; node; node = node.parent, level++) {\n      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY\n      if (node.dirty < dirty) node.dirty = dirty\n    }\n  }\n\n  get domAtom() { return false }\n}\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nconst nothing = []\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n  // : (ViewDesc, Decoration)\n  constructor(parent, widget, view, pos) {\n    let self, dom = widget.type.toDOM\n    if (typeof dom == \"function\") dom = dom(view, () => {\n      if (!self) return pos\n      if (self.parent) return self.parent.posBeforeChild(self)\n    })\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        let wrap = document.createElement(\"span\")\n        wrap.appendChild(dom)\n        dom = wrap\n      }\n      dom.contentEditable = false\n      dom.classList.add(\"ProseMirror-widget\")\n    }\n    super(parent, nothing, dom, null)\n    this.widget = widget\n    self = this\n  }\n\n  get beforePosition() {\n    return this.widget.type.side < 0\n  }\n\n  matchesWidget(widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)\n  }\n\n  parseRule() { return {ignore: true} }\n\n  stopEvent(event) {\n    let stop = this.widget.spec.stopEvent\n    return stop ? stop(event) : false\n  }\n\n  ignoreMutation(mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection\n  }\n\n  get domAtom() { return true }\n}\n\nclass CompositionViewDesc extends ViewDesc {\n  constructor(parent, dom, textDOM, text) {\n    super(parent, nothing, dom, null)\n    this.textDOM = textDOM\n    this.text = text\n  }\n\n  get size() { return this.text.length }\n\n  localPosFromDOM(dom, offset) {\n    if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0)\n    return this.posAtStart + offset\n  }\n\n  domFromPos(pos) {\n    return {node: this.textDOM, offset: pos}\n  }\n\n  ignoreMutation(mut) {\n    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue\n   }\n}\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n  // : (ViewDesc, Mark, dom.Node)\n  constructor(parent, mark, dom, contentDOM) {\n    super(parent, [], dom, contentDOM)\n    this.mark = mark\n  }\n\n  static create(parent, mark, inline, view) {\n    let custom = view.nodeViews[mark.type.name]\n    let spec = custom && custom(mark, view, inline)\n    if (!spec || !spec.dom)\n      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline))\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)\n  }\n\n  parseRule() { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} }\n\n  matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) }\n\n  markDirty(from, to) {\n    super.markDirty(from, to)\n    // Move dirty info to nearest node view\n    if (this.dirty != NOT_DIRTY) {\n      let parent = this.parent\n      while (!parent.node) parent = parent.parent\n      if (parent.dirty < this.dirty) parent.dirty = this.dirty\n      this.dirty = NOT_DIRTY\n    }\n  }\n\n  slice(from, to, view) {\n    let copy = MarkViewDesc.create(this.parent, this.mark, true, view)\n    let nodes = this.children, size = this.size\n    if (to < size) nodes = replaceNodes(nodes, to, size, view)\n    if (from > 0) nodes = replaceNodes(nodes, 0, from, view)\n    for (let i = 0; i < nodes.length; i++) nodes[i].parent = copy\n    copy.children = nodes\n    return copy\n  }\n}\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n  // : (?ViewDesc, Node, [Decoration], DecorationSource, dom.Node, ?dom.Node, EditorView)\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    super(parent, node.isLeaf ? nothing : [], dom, contentDOM)\n    this.nodeDOM = nodeDOM\n    this.node = node\n    this.outerDeco = outerDeco\n    this.innerDeco = innerDeco\n    if (contentDOM) this.updateChildren(view, pos)\n  }\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finnicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  static create(parent, node, outerDeco, innerDeco, view, pos) {\n    let custom = view.nodeViews[node.type.name], descObj\n    let spec = custom && custom(node, view, () => {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (!descObj) return pos\n      if (descObj.parent) return descObj.parent.posBeforeChild(descObj)\n    }, outerDeco, innerDeco)\n\n    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM\n    if (node.isText) {\n      if (!dom) dom = document.createTextNode(node.text)\n      else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\")\n    } else if (!dom) {\n      ;({dom, contentDOM} = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)))\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n      if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = false\n      if (node.type.spec.draggable) dom.draggable = true\n    }\n\n    let nodeDOM = dom\n    dom = applyOuterDeco(dom, outerDeco, node)\n\n    if (spec)\n      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,\n                                              spec, view, pos + 1)\n    else if (node.isText)\n      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view)\n    else\n      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1)\n  }\n\n  parseRule() {\n    // Experimental kludge to allow opt-in re-parsing of nodes\n    if (this.node.type.spec.reparseInView) return null\n    // FIXME the assumption that this can always return the current\n    // attrs means that if the user somehow manages to change the\n    // attrs in the dom, that won't be picked up. Not entirely sure\n    // whether this is a problem\n    let rule = {node: this.node.type.name, attrs: this.node.attrs}\n    if (this.node.type.spec.code) rule.preserveWhitespace = \"full\"\n    if (this.contentDOM && !this.contentLost) rule.contentElement = this.contentDOM\n    else rule.getContent = () => this.contentDOM ? Fragment.empty : this.node.content\n    return rule\n  }\n\n  matchesNode(node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  }\n\n  get size() { return this.node.nodeSize }\n\n  get border() { return this.node.isLeaf ? 0 : 1 }\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  updateChildren(view, pos) {\n    let inline = this.node.inlineContent, off = pos\n    let composition = inline && view.composing && this.localCompositionNode(view, pos)\n    let updater = new ViewTreeUpdater(this, composition && composition.node)\n    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n      if (widget.spec.marks)\n        updater.syncToMarks(widget.spec.marks, inline, view)\n      else if (widget.type.side >= 0 && !insideNode)\n        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view)\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget, view, off)\n    }, (child, outerDeco, innerDeco, i) => {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, inline, view)\n      // Either find an existing desc that exactly matches this node,\n      // and drop the descs before it.\n      updater.findNodeMatch(child, outerDeco, innerDeco, i) ||\n        // Or try updating the next desc to reflect this node.\n        updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||\n        // Or just add it as a new desc.\n        updater.addNode(child, outerDeco, innerDeco, view, off)\n      off += child.nodeSize\n    })\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, inline, view)\n    if (this.node.isTextblock) updater.addTextblockHacks()\n    updater.destroyRest()\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      // May have to protect focused DOM from being changed if a composition is active\n      if (composition) this.protectLocalComposition(view, composition)\n      renderDescs(this.contentDOM, this.children, view)\n      if (browser.ios) iosHacks(this.dom)\n    }\n  }\n\n  localCompositionNode(view, pos) {\n    // Only do something if both the selection and a focused text node\n    // are inside of this node, and the node isn't already part of a\n    // view that's a child of this view\n    let {from, to} = view.state.selection\n    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) return\n    let sel = view.root.getSelection()\n    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset)\n    if (!textNode || !this.dom.contains(textNode.parentNode)) return\n\n    // Find the text in the focused node in the node, stop if it's not\n    // there (may have been modified through other means, in which\n    // case it should overwritten)\n    let text = textNode.nodeValue\n    let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos)\n\n    return textPos < 0 ? null : {node: textNode, pos: textPos, text}\n  }\n\n  protectLocalComposition(view, {node, pos, text}) {\n    // The node is already part of a local view desc, leave it there\n    if (this.getDesc(node)) return\n\n    // Create a composition view for the orphaned nodes\n    let topNode = node\n    for (;; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM) break\n      while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling)\n      while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling)\n      if (topNode.pmViewDesc) topNode.pmViewDesc = null\n    }\n    let desc = new CompositionViewDesc(this, topNode, node, text)\n    view.compositionNodes.push(desc)\n\n    // Patch up this.children to contain the composition view\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc)\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) return false\n    this.updateInner(node, outerDeco, innerDeco, view)\n    return true\n  }\n\n  updateInner(node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco)\n    this.node = node\n    this.innerDeco = innerDeco\n    if (this.contentDOM) this.updateChildren(view, this.posAtStart)\n    this.dirty = NOT_DIRTY\n  }\n\n  updateOuterDeco(outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) return\n    let needsWrap = this.nodeDOM.nodeType != 1\n    let oldDOM = this.dom\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap))\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = null\n      this.dom.pmViewDesc = this\n    }\n    this.outerDeco = outerDeco\n  }\n\n  // Mark this node as being the selected node.\n  selectNode() {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\")\n    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true\n  }\n\n  // Remove selected node marking from this node.\n  deselectNode() {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\")\n    if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\")\n  }\n\n  get domAtom() { return this.node.isAtom }\n}\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nexport function docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc)\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)\n}\n\nclass TextViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view)\n  }\n\n  parseRule() {\n    let skip = this.nodeDOM.parentNode\n    while (skip && skip != this.dom && !skip.pmIsDeco) skip = skip.parentNode\n    return {skip: skip || true}\n  }\n\n  update(node, outerDeco, _, view) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n        !node.sameMarkup(this.node)) return false\n    this.updateOuterDeco(outerDeco)\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text\n      if (view.trackWrites == this.nodeDOM) view.trackWrites = null\n    }\n    this.node = node\n    this.dirty = NOT_DIRTY\n    return true\n  }\n\n  inParent() {\n    let parentDOM = this.parent.contentDOM\n    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true\n    return false\n  }\n\n  domFromPos(pos) {\n    return {node: this.nodeDOM, offset: pos}\n  }\n\n  localPosFromDOM(dom, offset, bias) {\n    if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length)\n    return super.localPosFromDOM(dom, offset, bias)\n  }\n\n  ignoreMutation(mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\"\n  }\n\n  slice(from, to, view) {\n    let node = this.node.cut(from, to), dom = document.createTextNode(node.text)\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)\n  }\n\n  get domAtom() { return false }\n}\n\n// A dummy desc used to tag trailing BR or span nodes created to work\n// around contentEditable terribleness.\nclass BRHackViewDesc extends ViewDesc {\n  parseRule() { return {ignore: true} }\n  matchesHack() { return this.dirty == NOT_DIRTY }\n  get domAtom() { return true }\n}\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n  // : (?ViewDesc, Node, [Decoration], DecorationSource, dom.Node, ?dom.Node, NodeView, EditorView)\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos)\n    this.spec = spec\n  }\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY) return false\n    if (this.spec.update) {\n      let result = this.spec.update(node, outerDeco, innerDeco)\n      if (result) this.updateInner(node, outerDeco, innerDeco, view)\n      return result\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return super.update(node, outerDeco, innerDeco, view)\n    }\n  }\n\n  selectNode() {\n    this.spec.selectNode ? this.spec.selectNode() : super.selectNode()\n  }\n\n  deselectNode() {\n    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()\n  }\n\n  setSelection(anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n      : super.setSelection(anchor, head, root, force)\n  }\n\n  destroy() {\n    if (this.spec.destroy) this.spec.destroy()\n    super.destroy()\n  }\n\n  stopEvent(event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  }\n\n  ignoreMutation(mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation)\n  }\n}\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n  let dom = parentDOM.firstChild, written = false\n  for (let i = 0; i < descs.length; i++) {\n    let desc = descs[i], childDOM = desc.dom\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom); written = true }\n      dom = dom.nextSibling\n    } else {\n      written = true\n      parentDOM.insertBefore(childDOM, dom)\n    }\n    if (desc instanceof MarkViewDesc) {\n      let pos = dom ? dom.previousSibling : parentDOM.lastChild\n      renderDescs(desc.contentDOM, desc.children, view)\n      dom = pos ? pos.nextSibling : parentDOM.firstChild\n    }\n  }\n  while (dom) { dom = rm(dom); written = true }\n  if (written && view.trackWrites == parentDOM) view.trackWrites = null\n}\n\nfunction OuterDecoLevel(nodeName) {\n  if (nodeName) this.nodeName = nodeName\n}\nOuterDecoLevel.prototype = Object.create(null)\n\nconst noDeco = [new OuterDecoLevel]\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) return noDeco\n\n  let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top]\n\n  for (let i = 0; i < outerDeco.length; i++) {\n    let attrs = outerDeco[i].type.attrs\n    if (!attrs) continue\n    if (attrs.nodeName)\n      result.push(top = new OuterDecoLevel(attrs.nodeName))\n\n    for (let name in attrs) {\n      let val = attrs[name]\n      if (val == null) continue\n      if (needsWrap && result.length == 1)\n        result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"))\n      if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val\n      else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val\n      else if (name != \"nodeName\") top[name] = val\n    }\n  }\n\n  return result\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM\n\n  let curDOM = nodeDOM\n  for (let i = 0; i < curComputed.length; i++) {\n    let deco = curComputed[i], prev = prevComputed[i]\n    if (i) {\n      let parent\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent\n      } else {\n        parent = document.createElement(deco.nodeName)\n        parent.pmIsDeco = true\n        parent.appendChild(curDOM)\n        prev = noDeco[0]\n        curDOM = parent\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco)\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (let name in prev)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      dom.removeAttribute(name)\n  for (let name in cur)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n      dom.setAttribute(name, cur[name])\n  if (prev.class != cur.class) {\n    let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : nothing\n    let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : nothing\n    for (let i = 0; i < prevList.length; i++) if (curList.indexOf(prevList[i]) == -1)\n      dom.classList.remove(prevList[i])\n    for (let i = 0; i < curList.length; i++) if (prevList.indexOf(curList[i]) == -1)\n      dom.classList.add(curList[i])\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m\n      while (m = prop.exec(prev.style))\n        dom.style.removeProperty(m[1])\n    }\n    if (cur.style)\n      dom.style.cssText += cur.style\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (!a[i].type.eq(b[i].type)) return false\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  let next = dom.nextSibling\n  dom.parentNode.removeChild(dom)\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n  // : (NodeViewDesc)\n  constructor(top, lockedNode) {\n    this.top = top\n    this.lock = lockedNode\n    // Index into `this.top`'s child array, represents the current\n    // update position.\n    this.index = 0\n    // When entering a mark, the current top and index are pushed\n    // onto this.\n    this.stack = []\n    // Tracks whether anything was changed\n    this.changed = false\n\n    this.preMatch = preMatch(top.node.content, top.children)\n  }\n\n  // Destroy and remove the children between the given indices in\n  // `this.top`.\n  destroyBetween(start, end) {\n    if (start == end) return\n    for (let i = start; i < end; i++) this.top.children[i].destroy()\n    this.top.children.splice(start, end - start)\n    this.changed = true\n  }\n\n  // Destroy all remaining children in `this.top`.\n  destroyRest() {\n    this.destroyBetween(this.index, this.top.children.length)\n  }\n\n  // : ([Mark], EditorView)\n  // Sync the current stack of mark descs with the given array of\n  // marks, reusing existing mark descs when possible.\n  syncToMarks(marks, inline, view) {\n    let keep = 0, depth = this.stack.length >> 1\n    let maxKeep = Math.min(depth, marks.length)\n    while (keep < maxKeep &&\n           (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n      keep++\n\n    while (keep < depth) {\n      this.destroyRest()\n      this.top.dirty = NOT_DIRTY\n      this.index = this.stack.pop()\n      this.top = this.stack.pop()\n      depth--\n    }\n    while (depth < marks.length) {\n      this.stack.push(this.top, this.index + 1)\n      let found = -1\n      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n        if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }\n      }\n      if (found > -1) {\n        if (found > this.index) {\n          this.changed = true\n          this.destroyBetween(this.index, found)\n        }\n        this.top = this.top.children[this.index]\n      } else {\n        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view)\n        this.top.children.splice(this.index, 0, markDesc)\n        this.top = markDesc\n        this.changed = true\n      }\n      this.index = 0\n      depth++\n    }\n  }\n\n  // : (Node, [Decoration], DecorationSource) → bool\n  // Try to find a node desc matching the given data. Skip over it and\n  // return true when successful.\n  findNodeMatch(node, outerDeco, innerDeco, index) {\n    let children = this.top.children, found = -1\n    if (index >= this.preMatch.index) {\n      for (let i = this.index; i < children.length; i++) if (children[i].matchesNode(node, outerDeco, innerDeco)) {\n        found = i\n        break\n      }\n    } else {\n      for (let i = this.index, e = Math.min(children.length, i + 1); i < e; i++) {\n        let child = children[i]\n        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n          found = i\n          break\n        }\n      }\n    }\n    if (found < 0) return false\n    this.destroyBetween(this.index, found)\n    this.index++\n    return true\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool\n  // Try to update the next node, if any, to the given data. Checks\n  // pre-matches to avoid overwriting nodes that could still be used.\n  updateNextNode(node, outerDeco, innerDeco, view, index) {\n    for (let i = this.index; i < this.top.children.length; i++) {\n      let next = this.top.children[i]\n      if (next instanceof NodeViewDesc) {\n        let preMatch = this.preMatch.matched.get(next)\n        if (preMatch != null && preMatch != index) return false\n        let nextDOM = next.dom\n\n        // Can't update if nextDOM is or contains this.lock, except if\n        // it's a text node whose content already matches the new text\n        // and whose decorations match the new ones.\n        let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&\n            !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n              next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco))\n        if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n          this.destroyBetween(this.index, i)\n          if (next.dom != nextDOM) this.changed = true\n          this.index++\n          return true\n        }\n        break\n      }\n    }\n    return false\n  }\n\n  // : (Node, [Decoration], DecorationSource, EditorView)\n  // Insert the node as a newly created node desc.\n  addNode(node, outerDeco, innerDeco, view, pos) {\n    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos))\n    this.changed = true\n  }\n\n  placeWidget(widget, view, pos) {\n    let next = this.index < this.top.children.length ? this.top.children[this.index] : null\n    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n      this.index++\n    } else {\n      let desc = new WidgetViewDesc(this.top, widget, view, pos)\n      this.top.children.splice(this.index++, 0, desc)\n      this.changed = true\n    }\n  }\n\n  // Make sure a textblock looks and behaves correctly in\n  // contentEditable.\n  addTextblockHacks() {\n    let lastChild = this.top.children[this.index - 1]\n    while (lastChild instanceof MarkViewDesc) lastChild = lastChild.children[lastChild.children.length - 1]\n\n    if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) ||\n        /\\n$/.test(lastChild.node.text)) {\n      if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {\n        this.index++\n      } else {\n        let dom = document.createElement(\"br\")\n        this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null))\n        this.changed = true\n      }\n    }\n  }\n}\n\n// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, descs) {\n  let fI = frag.childCount, dI = descs.length, matched = new Map\n  for (; fI > 0 && dI > 0; dI--) {\n    let desc = descs[dI - 1], node = desc.node\n    if (!node) continue\n    if (node != frag.child(fI - 1)) break\n    --fI\n    matched.set(desc, fI)\n  }\n  return {index: fI, matched}\n}\n\nfunction compareSide(a, b) { return a.type.side - b.type.side }\n\n// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  let locals = deco.locals(parent), offset = 0\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (let i = 0; i < parent.childCount; i++) {\n      let child = parent.child(i)\n      onNode(child, locals, deco.forChild(offset, child), i)\n      offset += child.nodeSize\n    }\n    return\n  }\n\n  let decoIndex = 0, active = [], restNode = null\n  for (let parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      let widget = locals[decoIndex++], widgets\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        (widgets || (widgets = [widget])).push(locals[decoIndex++])\n      if (widgets) {\n        widgets.sort(compareSide)\n        for (let i = 0; i < widgets.length; i++) onWidget(widgets[i], parentIndex, !!restNode)\n      } else {\n        onWidget(widget, parentIndex, !!restNode)\n      }\n    }\n\n    let child, index\n    if (restNode) {\n      index = -1\n      child = restNode\n      restNode = null\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex\n      child = parent.child(parentIndex++)\n    } else {\n      break\n    }\n\n    for (let i = 0; i < active.length; i++) if (active[i].to <= offset) active.splice(i--, 1)\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      active.push(locals[decoIndex++])\n\n    let end = offset + child.nodeSize\n    if (child.isText) {\n      let cutAt = end\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from\n      for (let i = 0; i < active.length; i++) if (active[i].to < cutAt) cutAt = active[i].to\n      if (cutAt < end) {\n        restNode = child.cut(cutAt - offset)\n        child = child.cut(0, cutAt - offset)\n        end = cutAt\n        index = -1\n      }\n    }\n\n    let outerDeco = !active.length ? nothing\n        : child.isInline && !child.isLeaf ? active.filter(d => !d.inline)\n        : active.slice()\n    onNode(child, outerDeco, deco.forChild(offset, child), index)\n    offset = end\n  }\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    let oldCSS = dom.style.cssText\n    dom.style.cssText = oldCSS + \"; list-style: square !important\"\n    window.getComputedStyle(dom).listStyle\n    dom.style.cssText = oldCSS\n  }\n}\n\nfunction nearbyTextNode(node, offset) {\n  for (;;) {\n    if (node.nodeType == 3) return node\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n        return node.childNodes[offset]\n      node = node.childNodes[offset - 1]\n      offset = nodeSize(node)\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset]\n      offset = 0\n    } else {\n      return null\n    }\n  }\n}\n\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n  for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n    let child = frag.child(i++), childStart = pos\n    pos += child.nodeSize\n    if (!child.isText) continue\n    let str = child.text\n    while (i < frag.childCount) {\n      let next = frag.child(i++)\n      pos += next.nodeSize\n      if (!next.isText) break\n      str += next.text\n    }\n    if (pos >= from) {\n      let found = str.lastIndexOf(text, to - childStart)\n      if (found >= 0 && found + text.length + childStart >= from)\n        return childStart + found\n    }\n  }\n  return -1\n}\n\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  let result = []\n  for (let i = 0, off = 0; i < nodes.length; i++) {\n    let child = nodes[i], start = off, end = off += child.size\n    if (start >= to || end <= from) {\n      result.push(child)\n    } else {\n      if (start < from) result.push(child.slice(0, from - start, view))\n      if (replacement) {\n        result.push(replacement)\n        replacement = null\n      }\n      if (end > to) result.push(child.slice(to - start, child.size, view))\n    }\n  }\n  return result\n}\n","import {TextSelection, NodeSelection} from \"prosemirror-state\"\n\nimport browser from \"./browser\"\nimport {selectionCollapsed, isEquivalentPosition, domIndex, isOnEdge} from \"./dom\"\n\nexport function selectionFromDOM(view, origin) {\n  let domSel = view.root.getSelection(), doc = view.state.doc\n  if (!domSel.focusNode) return null\n  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0\n  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)\n  if (head < 0) return null\n  let $head = doc.resolve(head), $anchor, selection\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head\n    while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent\n    if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent\n        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      let pos = nearestDesc.posBefore\n      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos))\n    }\n  } else {\n    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset)\n    if (anchor < 0) return null\n    $anchor = doc.resolve(anchor)\n  }\n\n  if (!selection) {\n    let bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1\n    selection = selectionBetween(view, $anchor, $head, bias)\n  }\n  return selection\n}\n\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() :\n    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)\n}\n\nexport function selectionToDOM(view, force) {\n  let sel = view.state.selection\n  syncNodeSelection(view, sel)\n\n  if (!editorOwnsSelection(view)) return\n\n  view.domObserver.disconnectSelection()\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view)\n  } else {\n    let {anchor, head} = sel, resetEditableFrom, resetEditableTo\n    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        resetEditableFrom = temporarilyEditableNear(view, sel.from)\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        resetEditableTo = temporarilyEditableNear(view, sel.to)\n    }\n    view.docView.setSelection(anchor, head, view.root, force)\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) resetEditable(resetEditableFrom)\n      if (resetEditableTo) resetEditable(resetEditableTo)\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\")\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\")\n      if (\"onselectionchange\" in document) removeClassOnSelectionChange(view)\n    }\n  }\n\n  view.domObserver.setCurSelection()\n  view.domObserver.connectSelection()\n}\n\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\n\nconst brokenSelectBetweenUneditable = browser.safari || browser.chrome && browser.chrome_version < 63\n\nfunction temporarilyEditableNear(view, pos) {\n  let {node, offset} = view.docView.domFromPos(pos, 0)\n  let after = offset < node.childNodes.length ? node.childNodes[offset] : null\n  let before = offset ? node.childNodes[offset - 1] : null\n  if (browser.safari && after && after.contentEditable == \"false\") return setEditable(after)\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) return setEditable(after)\n    else if (before) return setEditable(before)\n  }\n}\n\nfunction setEditable(element) {\n  element.contentEditable = \"true\"\n  if (browser.safari && element.draggable) { element.draggable = false; element.wasDraggable = true }\n  return element\n}\n\nfunction resetEditable(element) {\n  element.contentEditable = \"false\"\n  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  let doc = view.dom.ownerDocument\n  doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard)\n  let domSel = view.root.getSelection()\n  let node = domSel.anchorNode, offset = domSel.anchorOffset\n  doc.addEventListener(\"selectionchange\", view.hideSelectionGuard = () => {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard)\n      setTimeout(() => {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          view.dom.classList.remove(\"ProseMirror-hideselection\")\n      }, 20)\n    }\n  })\n}\n\nfunction selectCursorWrapper(view) {\n  let domSel = view.root.getSelection(), range = document.createRange()\n  let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\"\n  if (img) range.setEnd(node.parentNode, domIndex(node) + 1)\n  else range.setEnd(node, 0)\n  range.collapse(false)\n  domSel.removeAllRanges()\n  domSel.addRange(range)\n  // Kludge to kill 'control selection' in IE11 when selecting an\n  // invisible cursor wrapper, since that would result in those weird\n  // resize handles and a selection that considers the absolutely\n  // positioned wrapper, rather than the root editable node, the\n  // focused element.\n  if (!img && !view.state.selection.visible && browser.ie && browser.ie_version <= 11) {\n    node.disabled = true\n    node.disabled = false\n  }\n}\n\nexport function syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    let desc = view.docView.descAt(sel.from)\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view)\n      if (desc) desc.selectNode()\n      view.lastSelectedViewDesc = desc\n    }\n  } else {\n    clearNodeSelection(view)\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      view.lastSelectedViewDesc.deselectNode()\n    view.lastSelectedViewDesc = null\n  }\n}\n\nexport function selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", f => f(view, $anchor, $head))\n    || TextSelection.between($anchor, $head, bias)\n}\n\nexport function hasFocusAndSelection(view) {\n  if (view.editable && view.root.activeElement != view.dom) return false\n  return hasSelection(view)\n}\n\nexport function hasSelection(view) {\n  let sel = view.root.getSelection()\n  if (!sel.anchorNode) return false\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))\n  } catch(_) {\n    return false\n  }\n}\n\nexport function anchorInRightPlace(view) {\n  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0)\n  let domSel = view.root.getSelection()\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)\n}\n","import {Selection, NodeSelection, TextSelection, AllSelection} from \"prosemirror-state\"\nimport browser from \"./browser\"\nimport {domIndex, selectionCollapsed} from \"./dom\"\nimport {selectionToDOM} from \"./selection\"\n\nfunction moveSelectionBlock(state, dir) {\n  let {$anchor, $head} = state.selection\n  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head)\n  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null\n  return $start && Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView())\n  return true\n}\n\nfunction selectHorizontally(view, dir, mods) {\n  let sel = view.state.selection\n  if (sel instanceof TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      let next = moveSelectionBlock(view.state, dir)\n      if (next && (next instanceof NodeSelection)) return apply(view, next)\n      return false\n    } else if (!(browser.mac && mods.indexOf(\"m\") > -1)) {\n      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc\n      if (!node || node.isText) return false\n      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false\n      if (NodeSelection.isSelectable(node)) {\n        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))\n      } else if (browser.webkit) {\n        // Chrome and Safari will introduce extra pointless cursor\n        // positions around inline uneditable nodes, so we have to\n        // take over and move the cursor past them (#937)\n        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))\n      } else {\n        return false\n      }\n    }\n  } else if (sel instanceof NodeSelection && sel.node.isInline) {\n    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))\n  } else {\n    let next = moveSelectionBlock(view.state, dir)\n    if (next) return apply(view, next)\n    return false\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  let desc = dom.pmViewDesc\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\")\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  let sel = view.root.getSelection()\n  let node = sel.focusNode, offset = sel.focusOffset\n  if (!node) return\n  let moveNode, moveOffset, force = false\n  // Gecko will do odd things when the selection is directly in front\n  // of a non-editable node, so in that case, move it into the next\n  // node if possible. Issue prosemirror/prosemirror#832.\n  if (browser.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break\n      } else {\n        let before = node.childNodes[offset - 1]\n        if (isIgnorable(before)) {\n          moveNode = node\n          moveOffset = --offset\n        } else if (before.nodeType == 3) {\n          node = before\n          offset = node.nodeValue.length\n        } else break\n      }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      let prev = node.previousSibling\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode\n        moveOffset = domIndex(prev)\n        prev = prev.previousSibling\n      }\n      if (!prev) {\n        node = node.parentNode\n        if (node == view.dom) break\n        offset = 0\n      } else {\n        node = prev\n        offset = nodeLen(node)\n      }\n    }\n  }\n  if (force) setSelFocus(view, sel, node, offset)\n  else if (moveNode) setSelFocus(view, sel, moveNode, moveOffset)\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  let sel = view.root.getSelection()\n  let node = sel.focusNode, offset = sel.focusOffset\n  if (!node) return\n  let len = nodeLen(node)\n  let moveNode, moveOffset\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) break\n      let after = node.childNodes[offset]\n      if (isIgnorable(after)) {\n        moveNode = node\n        moveOffset = ++offset\n      }\n      else break\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      let next = node.nextSibling\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode\n        moveOffset = domIndex(next) + 1\n        next = next.nextSibling\n      }\n      if (!next) {\n        node = node.parentNode\n        if (node == view.dom) break\n        offset = len = 0\n      } else {\n        node = next\n        offset = 0\n        len = nodeLen(node)\n      }\n    }\n  }\n  if (moveNode) setSelFocus(view, sel, moveNode, moveOffset)\n}\n\nfunction isBlockNode(dom) {\n  let desc = dom.pmViewDesc\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSelFocus(view, sel, node, offset) {\n  if (selectionCollapsed(sel)) {\n    let range = document.createRange()\n    range.setEnd(node, offset)\n    range.setStart(node, offset)\n    sel.removeAllRanges()\n    sel.addRange(range)\n  } else if (sel.extend) {\n    sel.extend(node, offset)\n  }\n  view.domObserver.setCurSelection()\n  let {state} = view\n  // If no state update ends up happening, reset the selection.\n  setTimeout(() => {\n    if (view.state == state) selectionToDOM(view)\n  }, 50)\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n  let sel = view.state.selection\n  if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false\n  if (browser.mac && mods.indexOf(\"m\") > -1) return false\n  let {$from, $to} = sel\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    let next = moveSelectionBlock(view.state, dir)\n    if (next && (next instanceof NodeSelection))\n      return apply(view, next)\n  }\n  if (!$from.parent.inlineContent) {\n    let side = dir < 0 ? $from : $to\n    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir)\n    return beyond ? apply(view, beyond) : false\n  }\n  return false\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return true\n  let {$head, $anchor, empty} = view.state.selection\n  if (!$head.sameParent($anchor)) return true\n  if (!empty) return false\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true\n  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter)\n  if (nextNode && !nextNode.isText) {\n    let tr = view.state.tr\n    if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos)\n    else tr.delete($head.pos, $head.pos + nextNode.nodeSize)\n    view.dispatch(tr)\n    return true\n  }\n  return false\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop()\n  node.contentEditable = state\n  view.domObserver.start()\n}\n\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n  if (!browser.safari || view.state.selection.$head.parentOffset > 0) return\n  let {focusNode, focusOffset} = view.root.getSelection()\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n      focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    let child = focusNode.firstChild\n    switchEditable(view, child, true)\n    setTimeout(() => switchEditable(view, child, false), 20)\n  }\n}\n\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction getMods(event) {\n  let result = \"\"\n  if (event.ctrlKey) result += \"c\"\n  if (event.metaKey) result += \"m\"\n  if (event.altKey) result += \"a\"\n  if (event.shiftKey) result += \"s\"\n  return result\n}\n\nexport function captureKeyDown(view, event) {\n  let code = event.keyCode, mods = getMods(event)\n  if (code == 8 || (browser.mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46 || (browser.mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 40) { // Down arrow\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (mods == (browser.mac ? \"m\" : \"c\") &&\n             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n    return true\n  }\n  return false\n}\n","import {Fragment, DOMParser} from \"prosemirror-model\"\nimport {Selection, TextSelection} from \"prosemirror-state\"\n\nimport {selectionBetween, selectionFromDOM, selectionToDOM} from \"./selection\"\nimport {selectionCollapsed, keyEvent} from \"./dom\"\nimport browser from \"./browser\"\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, from_, to_) {\n  let {node: parent, fromOffset, toOffset, from, to} = view.docView.parseRange(from_, to_)\n\n  let domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{node: anchor, offset: domSel.anchorOffset}]\n    if (!selectionCollapsed(domSel))\n      find.push({node: domSel.focusNode, offset: domSel.focusOffset})\n  }\n  // Work around issue in Chrome where backspacing sometimes replaces\n  // the deleted content with a random BR node (issues #799, #831)\n  if (browser.chrome && view.lastKeyCode === 8) {\n    for (let off = toOffset; off > fromOffset; off--) {\n      let node = parent.childNodes[off - 1], desc = node.pmViewDesc\n      if (node.nodeType == \"BR\" && !desc) { toOffset = off; break }\n      if (!desc || desc.size) break\n    }\n  }\n  let startDoc = view.state.doc\n  let parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n  let $from = startDoc.resolve(from)\n\n  let sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.spec.code ? \"full\" : true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode,\n    context: $from\n  })\n  if (find && find[0].pos != null) {\n    let anchor = find[0].pos, head = find[1] && find[1].pos\n    if (head == null) head = anchor\n    sel = {anchor: anchor + from, head: head + from}\n  }\n  return {doc, sel, from, to}\n}\n\nfunction ruleFromNode(dom) {\n  let desc = dom.pmViewDesc\n  if (desc) {\n    return desc.parseRule()\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    // Safari replaces the list item or table cell with a BR\n    // directly in the list node (?!) if you delete the last\n    // character in a list item or table cell (#708, #862)\n    if (browser.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      let skip = document.createElement(\"div\")\n      skip.appendChild(document.createElement(\"li\"))\n      return {skip}\n    } else if (dom.parentNode.lastChild == dom || browser.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return {ignore: true}\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return {ignore: true}\n  }\n}\n\nexport function readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    let origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null\n    let newSel = selectionFromDOM(view, origin)\n    if (newSel && !view.state.selection.eq(newSel)) {\n      let tr = view.state.tr.setSelection(newSel)\n      if (origin == \"pointer\") tr.setMeta(\"pointer\", true)\n      else if (origin == \"key\") tr.scrollIntoView()\n      view.dispatch(tr)\n    }\n    return\n  }\n\n  let $before = view.state.doc.resolve(from)\n  let shared = $before.sharedDepth(to)\n  from = $before.before(shared + 1)\n  to = view.state.doc.resolve(to).after(shared + 1)\n\n  let sel = view.state.selection\n  let parse = parseBetween(view, from, to)\n  // Chrome sometimes leaves the cursor before the inserted text when\n  // composing after a cursor wrapper. This moves it forward.\n  if (browser.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {\n    let text = view.cursorWrapper.deco.type.toDOM.nextSibling\n    let size = text && text.nodeValue ? text.nodeValue.length : 1\n    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size}\n  }\n\n  let doc = view.state.doc, compare = doc.slice(parse.from, parse.to)\n  let preferredPos, preferredSide\n  // Prefer anchoring to end when Backspace is pressed\n  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to\n    preferredSide = \"end\"\n  } else {\n    preferredPos = view.state.selection.from\n    preferredSide = \"start\"\n  }\n  view.lastKeyCode = null\n\n  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide)\n  if (!change) {\n    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = {start: sel.from, endA: sel.to, endB: sel.to}\n    } else if ((browser.ios && view.lastIOSEnter > Date.now() - 225 || browser.android) &&\n               addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\") &&\n               view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n      view.lastIOSEnter = 0\n      return\n    } else {\n      if (parse.sel) {\n        let sel = resolveSelection(view, view.state.doc, parse.sel)\n        if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel))\n      }\n      return\n    }\n  }\n  view.domChangeCount++\n  // Handle the case where overwriting a selection by typing matches\n  // the start or end of the selected content, creating a change\n  // that's smaller than what was actually overwritten.\n  if (view.state.selection.from < view.state.selection.to &&\n      change.start == change.endB &&\n      view.state.selection instanceof TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {\n      change.start = view.state.selection.from\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {\n      change.endB += (view.state.selection.to - change.endA)\n      change.endA = view.state.selection.to\n    }\n  }\n\n  // IE11 will insert a non-breaking space _ahead_ of the space after\n  // the cursor space when adding a space before another space. When\n  // that happened, adjust the change to cover the space instead.\n  if (browser.ie && browser.ie_version <= 11 && change.endB == change.start + 1 &&\n      change.endA == change.start && change.start > parse.from &&\n      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n    change.start--\n    change.endA--\n    change.endB--\n  }\n\n  let $from = parse.doc.resolveNoCache(change.start - parse.from)\n  let $to = parse.doc.resolveNoCache(change.endB - parse.from)\n  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent\n  let nextSel\n  // If this looks like the effect of pressing Enter (or was recorded\n  // as being an iOS enter press), just dispatch an Enter key instead.\n  if (((browser.ios && view.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\"))) ||\n       (!inlineChange && $from.pos < parse.doc.content.size &&\n        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n        nextSel.head == $to.pos)) &&\n      view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n    view.lastIOSEnter = 0\n    return\n  }\n  // Same for backspace\n  if (view.state.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) {\n    if (browser.android && browser.chrome) view.domObserver.suppressSelectionUpdates() // #820\n    return\n  }\n\n  // Chrome Android will occasionally, during composition, delete the\n  // entire composition and then immediately insert it again. This is\n  // used to detect that situation.\n  if (browser.chrome && browser.android && change.toB == change.from)\n    view.lastAndroidDelete = Date.now()\n\n  // This tries to detect Android virtual keyboard\n  // enter-and-pick-suggestion action. That sometimes (see issue\n  // #1059) first fires a DOM mutation, before moving the selection to\n  // the newly created block. And then, because ProseMirror cleans up\n  // the DOM selection, it gives up moving the selection entirely,\n  // leaving the cursor in the wrong place. When that happens, we drop\n  // the new paragraph from the initial change, and fire a simulated\n  // enter key afterwards.\n  if (browser.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2\n    $to = parse.doc.resolveNoCache(change.endB - parse.from)\n    setTimeout(() => {\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })\n    }, 20)\n  }\n\n  let chFrom = change.start, chTo = change.endA\n\n  let tr, storedMarks, markChange, $from1\n  if (inlineChange) {\n    if ($from.pos == $to.pos) { // Deletion\n      // IE11 sometimes weirdly moves the DOM selection around after\n      // backspacing out the first element in a textblock\n      if (browser.ie && browser.ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates()\n        setTimeout(() => selectionToDOM(view), 20)\n      }\n      tr = view.state.tr.delete(chFrom, chTo)\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA))\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr\n      if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark)\n      else tr.removeMark(chFrom, chTo, markChange.mark)\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset)\n      if (view.someProp(\"handleTextInput\", f => f(view, chFrom, chTo, text))) return\n      tr = view.state.tr.insertText(text, chFrom, chTo)\n    }\n  }\n\n  if (!tr)\n    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from))\n  if (parse.sel) {\n    let sel = resolveSelection(view, tr.doc, parse.sel)\n    // Chrome Android will sometimes, during composition, report the\n    // selection in the wrong place. If it looks like that is\n    // happening, don't update the selection.\n    // Edge just doesn't move the cursor forward when you start typing\n    // in an empty block or between br nodes.\n    if (sel && !(browser.chrome && browser.android && view.composing && sel.empty &&\n                 (change.from != change.toB || view.lastAndroidDelete < Date.now() - 100) &&\n                 (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n                 browser.ie && sel.empty && sel.head == chFrom))\n      tr.setSelection(sel)\n  }\n  if (storedMarks) tr.ensureMarks(storedMarks)\n  view.dispatch(tr.scrollIntoView())\n}\n\nfunction resolveSelection(view, doc, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null\n  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks\n  let added = curMarks, removed = prevMarks, type, mark, update\n  for (let i = 0; i < prevMarks.length; i++) added = prevMarks[i].removeFromSet(added)\n  for (let i = 0; i < curMarks.length; i++) removed = curMarks[i].removeFromSet(removed)\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0]\n    type = \"add\"\n    update = node => node.mark(mark.addToSet(node.marks))\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0]\n    type = \"remove\"\n    update = node => node.mark(mark.removeFromSet(node.marks))\n  } else {\n    return null\n  }\n  let updated = []\n  for (let i = 0; i < prev.childCount; i++) updated.push(update(prev.child(i)))\n  if (Fragment.from(updated).eq(cur)) return {mark, type}\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    return false\n\n  let $start = old.resolve(start)\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    return false\n  let $next = old.resolve(skipClosingAndOpening($start, true, true))\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    return false\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--\n    end++\n    fromEnd = false\n  }\n  if (mayOpen) {\n    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth))\n    while (next && !next.isLeaf) {\n      next = next.firstChild\n      end++\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  let start = a.findDiffStart(b, pos)\n  if (start == null) return null\n  let {a: endA, b: endB} = a.findDiffEnd(b, pos + a.size, pos + b.size)\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, start - Math.min(endA, endB))\n    preferredPos -= endA + adjust - start\n  }\n  if (endA < start && a.size < b.size) {\n    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0\n    start -= move\n    endB = start + (endB - endA)\n    endA = start\n  } else if (endB < start) {\n    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0\n    start -= move\n    endA = start + (endA - endB)\n    endB = start\n  }\n  return {start, endA, endB}\n}\n","import {Slice, Fragment, DOMParser, DOMSerializer} from \"prosemirror-model\"\n\nexport function serializeForClipboard(view, slice) {\n  let context = [], {content, openStart, openEnd} = slice\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--\n    openEnd--\n    let node = content.firstChild\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null)\n    content = node.content\n  }\n\n  let serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema)\n  let doc = detachedDoc(), wrap = doc.createElement(\"div\")\n  wrap.appendChild(serializer.serializeFragment(content, {document: doc}))\n\n  let firstChild = wrap.firstChild, needsWrap\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (let i = needsWrap.length - 1; i >= 0; i--) {\n      let wrapper = doc.createElement(needsWrap[i])\n      while (wrap.firstChild) wrapper.appendChild(wrap.firstChild)\n      wrap.appendChild(wrapper)\n    }\n    firstChild = wrap.firstChild\n  }\n\n  if (firstChild && firstChild.nodeType == 1)\n    firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd} ${JSON.stringify(context)}`)\n\n  let text = view.someProp(\"clipboardTextSerializer\", f => f(slice)) ||\n      slice.content.textBetween(0, slice.content.size, \"\\n\\n\")\n\n  return {dom: wrap, text}\n}\n\n// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nexport function parseFromClipboard(view, text, html, plainText, $context) {\n  let dom, inCode = $context.parent.type.spec.code, slice\n  if (!html && !text) return null\n  let asText = text && (plainText || inCode || !html)\n  if (asText) {\n    view.someProp(\"transformPastedText\", f => { text = f(text, inCode || plainText) })\n    if (inCode) return new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0)\n    let parsed = view.someProp(\"clipboardTextParser\", f => f(text, $context, plainText))\n    if (parsed) {\n      slice = parsed\n    } else {\n      dom = document.createElement(\"div\")\n      text.trim().split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n        dom.appendChild(document.createElement(\"p\")).textContent = block\n      })\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", f => { html = f(html) })\n    dom = readHTML(html)\n  }\n\n  let contextNode = dom && dom.querySelector(\"[data-pm-slice]\")\n  let sliceData = contextNode && /^(\\d+) (\\d+) (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\"))\n  if (!slice) {\n    let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema)\n    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context})\n  }\n  if (sliceData)\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3])\n  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), false)\n\n  view.someProp(\"transformPasted\", f => { slice = f(slice) })\n  return slice\n}\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) return fragment\n  for (let d = $context.depth; d >= 0; d--) {\n    let parent = $context.node(d)\n    let match = parent.contentMatchAt($context.index(d))\n    let lastWrap, result = []\n    fragment.forEach(node => {\n      if (!result) return\n      let wrap = match.findWrapping(node.type), inLast\n      if (!wrap) return result = null\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast\n      } else {\n        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length)\n        let wrapped = withWrappers(node, wrap)\n        result.push(wrapped)\n        match = match.matchType(wrapped.type, wrapped.attrs)\n        lastWrap = wrap\n      }\n    })\n    if (result) return Fragment.from(result)\n  }\n  return fragment\n}\n\nfunction withWrappers(node, wrap, from = 0) {\n  for (let i = wrap.length - 1; i >= from; i--)\n    node = wrap[i].create(null, Fragment.from(node))\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1)\n    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner))\n    let match = sibling.contentMatchAt(sibling.childCount)\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))))\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) return node\n  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1))\n  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)\n  return node.copy(fragment.append(fill))\n}\n\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content\n  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd)\n  if (depth >= from)\n    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)\n      : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true))\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))\n}\n\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd)\n  if (openEnd < slice.openEnd)\n    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd)\n  return slice\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n}\n\nlet _detachedDoc = null\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n}\n\nfunction readHTML(html) {\n  let metas = /^(\\s*<meta [^>]*>)*/.exec(html)\n  if (metas) html = html.slice(metas[0].length)\n  let elt = detachedDoc().createElement(\"div\")\n  let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    html = wrap.map(n => \"<\" + n + \">\").join(\"\") + html + wrap.map(n => \"</\" + n + \">\").reverse().join(\"\")\n  elt.innerHTML = html\n  if (wrap) for (let i = 0; i < wrap.length; i++) elt = elt.querySelector(wrap[i]) || elt\n  return elt\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) return slice\n  let schema = slice.content.firstChild.type.schema, array\n  try { array = JSON.parse(context) }\n  catch(e) { return slice }\n  let {content, openStart, openEnd} = slice\n  for (let i = array.length - 2; i >= 0; i -= 2) {\n    let type = schema.nodes[array[i]]\n    if (!type || type.hasRequiredAttrs()) break\n    content = Fragment.from(type.create(array[i + 1], content))\n    openStart++; openEnd++\n  }\n  return new Slice(content, openStart, openEnd)\n}\n","import browser from \"./browser\"\nimport {domIndex, isEquivalentPosition} from \"./dom\"\nimport {hasFocusAndSelection, hasSelection, selectionToDOM} from \"./selection\"\n\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n}\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = browser.ie && browser.ie_version <= 11\n\nclass SelectionState {\n  constructor() {\n    this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null\n  }\n\n  set(sel) {\n    this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset\n    this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset\n  }\n\n  eq(sel) {\n    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n      sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset\n  }\n}\n\nexport class DOMObserver {\n  constructor(view, handleDOMChange) {\n    this.view = view\n    this.handleDOMChange = handleDOMChange\n    this.queue = []\n    this.flushingSoon = -1\n    this.observer = window.MutationObserver &&\n      new window.MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) this.queue.push(mutations[i])\n        // IE11 will sometimes (on backspacing out a single character\n        // text node after a BR node) call the observer callback\n        // before actually updating the DOM, which will cause\n        // ProseMirror to miss the change (see #930)\n        if (browser.ie && browser.ie_version <= 11 && mutations.some(\n          m => m.type == \"childList\" && m.removedNodes.length ||\n               m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n          this.flushSoon()\n        else\n          this.flush()\n      })\n    this.currentSelection = new SelectionState\n    if (useCharData) {\n      this.onCharData = e => {\n        this.queue.push({target: e.target, type: \"characterData\", oldValue: e.prevValue})\n        this.flushSoon()\n      }\n    }\n    this.onSelectionChange = this.onSelectionChange.bind(this)\n    this.suppressingSelectionUpdates = false\n  }\n\n  flushSoon() {\n    if (this.flushingSoon < 0)\n      this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush() }, 20)\n  }\n\n  forceFlush() {\n    if (this.flushingSoon > -1) {\n      window.clearTimeout(this.flushingSoon)\n      this.flushingSoon = -1\n      this.flush()\n    }\n  }\n\n  start() {\n    if (this.observer)\n      this.observer.observe(this.view.dom, observeOptions)\n    if (useCharData)\n      this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData)\n    this.connectSelection()\n  }\n\n  stop() {\n    if (this.observer) {\n      let take = this.observer.takeRecords()\n      if (take.length) {\n        for (let i = 0; i < take.length; i++) this.queue.push(take[i])\n        window.setTimeout(() => this.flush(), 20)\n      }\n      this.observer.disconnect()\n    }\n    if (useCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData)\n    this.disconnectSelection()\n  }\n\n  connectSelection() {\n    this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange)\n  }\n\n  disconnectSelection() {\n    this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange)\n  }\n\n  suppressSelectionUpdates() {\n    this.suppressingSelectionUpdates = true\n    setTimeout(() => this.suppressingSelectionUpdates = false, 50)\n  }\n\n  onSelectionChange() {\n    if (!hasFocusAndSelection(this.view)) return\n    if (this.suppressingSelectionUpdates) return selectionToDOM(this.view)\n    // Deletions on IE11 fire their events in the wrong order, giving\n    // us a selection change event before the DOM changes are\n    // reported.\n    if (browser.ie && browser.ie_version <= 11 && !this.view.state.selection.empty) {\n      let sel = this.view.root.getSelection()\n      // Selection.isCollapsed isn't reliable on IE\n      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n        return this.flushSoon()\n    }\n    this.flush()\n  }\n\n  setCurSelection() {\n    this.currentSelection.set(this.view.root.getSelection())\n  }\n\n  ignoreSelectionChange(sel) {\n    if (sel.rangeCount == 0) return true\n    let container = sel.getRangeAt(0).commonAncestorContainer\n    let desc = this.view.docView.nearestDesc(container)\n    if (desc && desc.ignoreMutation({type: \"selection\", target: container.nodeType == 3 ? container.parentNode : container})) {\n      this.setCurSelection()\n      return true\n    }\n  }\n\n  flush() {\n    if (!this.view.docView || this.flushingSoon > -1) return\n    let mutations = this.observer ? this.observer.takeRecords() : []\n    if (this.queue.length) {\n      mutations = this.queue.concat(mutations)\n      this.queue.length = 0\n    }\n\n    let sel = this.view.root.getSelection()\n    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel)\n\n    let from = -1, to = -1, typeOver = false, added = []\n    if (this.view.editable) {\n      for (let i = 0; i < mutations.length; i++) {\n        let result = this.registerMutation(mutations[i], added)\n        if (result) {\n          from = from < 0 ? result.from : Math.min(result.from, from)\n          to = to < 0 ? result.to : Math.max(result.to, to)\n          if (result.typeOver) typeOver = true\n        }\n      }\n    }\n\n    if (browser.gecko && added.length > 1) {\n      let brs = added.filter(n => n.nodeName == \"BR\")\n      if (brs.length == 2) {\n        let [a, b] = brs\n        if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove()\n        else a.remove()\n      }\n    }\n\n    if (from > -1 || newSel) {\n      if (from > -1) {\n        this.view.docView.markDirty(from, to)\n        checkCSS(this.view)\n      }\n      this.handleDOMChange(from, to, typeOver, added)\n      if (this.view.docView.dirty) this.view.updateState(this.view.state)\n      else if (!this.currentSelection.eq(sel)) selectionToDOM(this.view)\n      this.currentSelection.set(sel)\n    }\n  }\n\n  registerMutation(mut, added) {\n    // Ignore mutations inside nodes that were already noted as inserted\n    if (added.indexOf(mut.target) > -1) return null\n    let desc = this.view.docView.nearestDesc(mut.target)\n    if (mut.type == \"attributes\" &&\n        (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n         // Firefox sometimes fires spurious events for null/empty styles\n         (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n      return null\n    if (!desc || desc.ignoreMutation(mut)) return null\n\n    if (mut.type == \"childList\") {\n      for (let i = 0; i < mut.addedNodes.length; i++) added.push(mut.addedNodes[i])\n      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n        return {from: desc.posBefore, to: desc.posAfter}\n      let prev = mut.previousSibling, next = mut.nextSibling\n      if (browser.ie && browser.ie_version <= 11 && mut.addedNodes.length) {\n        // IE11 gives us incorrect next/prev siblings for some\n        // insertions, so if there are added nodes, recompute those\n        for (let i = 0; i < mut.addedNodes.length; i++) {\n          let {previousSibling, nextSibling} = mut.addedNodes[i]\n          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling\n          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling\n        }\n      }\n      let fromOffset = prev && prev.parentNode == mut.target\n          ? domIndex(prev) + 1 : 0\n      let from = desc.localPosFromDOM(mut.target, fromOffset, -1)\n      let toOffset = next && next.parentNode == mut.target\n          ? domIndex(next) : mut.target.childNodes.length\n      let to = desc.localPosFromDOM(mut.target, toOffset, 1)\n      return {from, to}\n    } else if (mut.type == \"attributes\") {\n      return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}\n    } else { // \"characterData\"\n      return {\n        from: desc.posAtStart,\n        to: desc.posAtEnd,\n        // An event was generated for a text change that didn't change\n        // any text. Mark the dom change to fall back to assuming the\n        // selection was typed over with an identical value if it can't\n        // find another change.\n        typeOver: mut.target.nodeValue == mut.oldValue\n      }\n    }\n  }\n}\n\nlet cssChecked = false\n\nfunction checkCSS(view) {\n  if (cssChecked) return\n  cssChecked = true\n  if (getComputedStyle(view.dom).whiteSpace == \"normal\")\n    console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\")\n}\n","import {Selection, NodeSelection, TextSelection} from \"prosemirror-state\"\nimport {dropPoint} from \"prosemirror-transform\"\nimport {Slice} from \"prosemirror-model\"\n\nimport browser from \"./browser\"\nimport {captureKeyDown} from \"./capturekeys\"\nimport {readDOMChange} from \"./domchange\"\nimport {parseFromClipboard, serializeForClipboard} from \"./clipboard\"\nimport {DOMObserver} from \"./domobserver\"\nimport {selectionBetween, selectionToDOM, selectionFromDOM} from \"./selection\"\nimport {keyEvent} from \"./dom\"\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {}, editHandlers = {}\n\nexport function initInput(view) {\n  view.shiftKey = false\n  view.mouseDown = null\n  view.lastKeyCode = null\n  view.lastKeyCodeTime = 0\n  view.lastClick = {time: 0, x: 0, y: 0, type: \"\"}\n  view.lastSelectionOrigin = null\n  view.lastSelectionTime = 0\n\n  view.lastIOSEnter = 0\n  view.lastIOSEnterFallbackTimeout = null\n  view.lastAndroidDelete = 0\n\n  view.composing = false\n  view.composingTimeout = null\n  view.compositionNodes = []\n  view.compositionEndedAt = -2e8\n\n  view.domObserver = new DOMObserver(view, (from, to, typeOver, added) => readDOMChange(view, from, to, typeOver, added))\n  view.domObserver.start()\n  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM\n  view.domChangeCount = 0\n\n  view.eventHandlers = Object.create(null)\n  for (let event in handlers) {\n    let handler = handlers[event]\n    view.dom.addEventListener(event, view.eventHandlers[event] = event => {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        handler(view, event)\n    })\n  }\n  // On Safari, for reasons beyond my understanding, adding an input\n  // event handler makes an issue where the composition vanishes when\n  // you press enter go away.\n  if (browser.safari) view.dom.addEventListener(\"input\", () => null)\n\n  ensureListeners(view)\n}\n\nfunction setSelectionOrigin(view, origin) {\n  view.lastSelectionOrigin = origin\n  view.lastSelectionTime = Date.now()\n}\n\nexport function destroyInput(view) {\n  view.domObserver.stop()\n  for (let type in view.eventHandlers)\n    view.dom.removeEventListener(type, view.eventHandlers[type])\n  clearTimeout(view.composingTimeout)\n  clearTimeout(view.lastIOSEnterFallbackTimeout)\n}\n\nexport function ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", currentHandlers => {\n    for (let type in currentHandlers) if (!view.eventHandlers[type])\n      view.dom.addEventListener(type, view.eventHandlers[type] = event => runCustomHandler(view, event))\n  })\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", handlers => {\n    let handler = handlers[event.type]\n    return handler ? handler(view, event) || event.defaultPrevented : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) return true\n  if (event.defaultPrevented) return false\n  for (let node = event.target; node != view.dom; node = node.parentNode)\n    if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      return false\n  return true\n}\n\nexport function dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    handlers[event.type](view, event)\n}\n\neditHandlers.keydown = (view, event) => {\n  view.shiftKey = event.keyCode == 16 || event.shiftKey\n  if (inOrNearComposition(view, event)) return\n  view.domObserver.forceFlush()\n  view.lastKeyCode = event.keyCode\n  view.lastKeyCodeTime = Date.now()\n  // On iOS, if we preventDefault enter key presses, the virtual\n  // keyboard gets confused. So the hack here is to set a flag that\n  // makes the DOM change code recognize that what just happens should\n  // be replaced by whatever the Enter key handlers do.\n  if (browser.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    let now = Date.now()\n    view.lastIOSEnter = now\n    view.lastIOSEnterFallbackTimeout = setTimeout(() => {\n      if (view.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))\n        view.lastIOSEnter = 0\n      }\n    }, 200)\n  } else if (view.someProp(\"handleKeyDown\", f => f(view, event)) || captureKeyDown(view, event)) {\n    event.preventDefault()\n  } else {\n    setSelectionOrigin(view, \"key\")\n  }\n}\n\neditHandlers.keyup = (view, e) => {\n  if (e.keyCode == 16) view.shiftKey = false\n}\n\neditHandlers.keypress = (view, event) => {\n  if (inOrNearComposition(view, event) || !event.charCode ||\n      event.ctrlKey && !event.altKey || browser.mac && event.metaKey) return\n\n  if (view.someProp(\"handleKeyPress\", f => f(view, event))) {\n    event.preventDefault()\n    return\n  }\n\n  let sel = view.state.selection\n  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    let text = String.fromCharCode(event.charCode)\n    if (!view.someProp(\"handleTextInput\", f => f(view, sel.$from.pos, sel.$to.pos, text)))\n      view.dispatch(view.state.tr.insertText(text).scrollIntoView())\n    event.preventDefault()\n  }\n}\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nfunction isNear(event, click) {\n  let dx = click.x - event.clientX, dy = click.y - event.clientY\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) return false\n  let $pos = view.state.doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n      return true\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) view.focus()\n  let tr = view.state.tr.setSelection(selection)\n  if (origin == \"pointer\") tr.setMeta(\"pointer\", true)\n  view.dispatch(tr)\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) return false\n  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter\n  if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\")\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) return false\n  let sel = view.state.selection, selectedNode, selectAt\n  if (sel instanceof NodeSelection) selectedNode = sel.node\n\n  let $pos = view.state.doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    if (NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 &&\n          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        selectAt = $pos.before(sel.$from.depth)\n      else\n        selectAt = $pos.before(i)\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\")\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", f => f(view, pos, event)) ||\n    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", f => f(view, pos, event))\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", f => f(view, pos, event)) ||\n    defaultTripleClick(view, inside)\n}\n\nfunction defaultTripleClick(view, inside) {\n  let doc = view.state.doc\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\")\n      return true\n    }\n    return false\n  }\n\n  let $pos = doc.resolve(inside)\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i)\n    let nodePos = $pos.before(i)\n    if (node.inlineContent)\n      updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\")\n    else if (NodeSelection.isSelectable(node))\n      updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\")\n    else\n      continue\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  return endComposition(view)\n}\n\nconst selectNodeModifier = browser.mac ? \"metaKey\" : \"ctrlKey\"\n\nhandlers.mousedown = (view, event) => {\n  view.shiftKey = event.shiftKey\n  let flushed = forceDOMFlush(view)\n  let now = Date.now(), type = \"singleClick\"\n  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {\n    if (view.lastClick.type == \"singleClick\") type = \"doubleClick\"\n    else if (view.lastClick.type == \"doubleClick\") type = \"tripleClick\"\n  }\n  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type}\n\n  let pos = view.posAtCoords(eventCoords(event))\n  if (!pos) return\n\n  if (type == \"singleClick\")\n    view.mouseDown = new MouseDown(view, pos, event, flushed)\n  else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))\n    event.preventDefault()\n  else\n    setSelectionOrigin(view, \"pointer\")\n}\n\nclass MouseDown {\n  constructor(view, pos, event, flushed) {\n    this.view = view\n    this.startDoc = view.state.doc\n    this.pos = pos\n    this.event = event\n    this.flushed = flushed\n    this.selectNode = event[selectNodeModifier]\n    this.allowDefault = event.shiftKey\n\n    let targetNode, targetPos\n    if (pos.inside > -1) {\n      targetNode = view.state.doc.nodeAt(pos.inside)\n      targetPos = pos.inside\n    } else {\n      let $pos = view.state.doc.resolve(pos.pos)\n      targetNode = $pos.parent\n      targetPos = $pos.depth ? $pos.before() : 0\n    }\n\n    this.mightDrag = null\n\n    const target = flushed ? null : event.target\n    const targetDesc = target ? view.docView.nearestDesc(target, true) : null\n    this.target = targetDesc ? targetDesc.dom : null\n\n    if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n        view.state.selection instanceof NodeSelection && targetPos == view.state.selection.from)\n      this.mightDrag = {node: targetNode,\n                        pos: targetPos,\n                        addAttr: this.target && !this.target.draggable,\n                        setUneditable: this.target && browser.gecko && !this.target.hasAttribute(\"contentEditable\")}\n\n    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n      this.view.domObserver.stop()\n      if (this.mightDrag.addAttr) this.target.draggable = true\n      if (this.mightDrag.setUneditable)\n        setTimeout(() => this.target.setAttribute(\"contentEditable\", \"false\"), 20)\n      this.view.domObserver.start()\n    }\n\n    view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this))\n    view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this))\n    setSelectionOrigin(view, \"pointer\")\n  }\n\n  done() {\n    this.view.root.removeEventListener(\"mouseup\", this.up)\n    this.view.root.removeEventListener(\"mousemove\", this.move)\n    if (this.mightDrag && this.target) {\n      this.view.domObserver.stop()\n      if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\")\n      if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\")\n      this.view.domObserver.start()\n    }\n    this.view.mouseDown = null\n  }\n\n  up(event) {\n    this.done()\n\n    if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n      return\n\n    let pos = this.pos\n    if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event))\n\n    if (this.allowDefault || !pos) {\n      setSelectionOrigin(this.view, \"pointer\")\n    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n      event.preventDefault()\n    } else if (this.flushed ||\n               // Safari ignores clicks on draggable elements\n               (browser.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n               // Chrome will sometimes treat a node selection as a\n               // cursor, but still report that the node is selected\n               // when asked through getSelection. You'll then get a\n               // situation where clicking at the point where that\n               // (hidden) cursor is doesn't change the selection, and\n               // thus doesn't get a reaction from ProseMirror. This\n               // works around that.\n               (browser.chrome && !(this.view.state.selection instanceof TextSelection) &&\n                (pos.pos == this.view.state.selection.from || pos.pos == this.view.state.selection.to))) {\n      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\")\n      event.preventDefault()\n    } else {\n      setSelectionOrigin(this.view, \"pointer\")\n    }\n  }\n\n  move(event) {\n    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n                               Math.abs(this.event.y - event.clientY) > 4))\n      this.allowDefault = true\n    setSelectionOrigin(this.view, \"pointer\")\n  }\n}\n\nhandlers.touchdown = view => {\n  forceDOMFlush(view)\n  setSelectionOrigin(view, \"pointer\")\n}\n\nhandlers.contextmenu = view => forceDOMFlush(view)\n\nfunction inOrNearComposition(view, event) {\n  if (view.composing) return true\n  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n  // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n  // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n  // emitted. The keydown event triggers newline insertion, which we don't want.\n  // This method returns true if the keydown event should be ignored.\n  // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n  // This guards against the case where compositionend is triggered without the keyboard\n  // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n  // afterwards- we wouldn't want to ignore the keydown event in this case.\n  if (browser.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {\n    view.compositionEndedAt = -2e8\n    return true\n  }\n  return false\n}\n\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = browser.android ? 5000 : -1\n\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n  if (!view.composing) {\n    view.domObserver.flush()\n    let {state} = view, $pos = state.selection.$from\n    if (state.selection.empty &&\n        (state.storedMarks ||\n         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {\n      // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n      view.markCursor = view.state.storedMarks || $pos.marks()\n      endComposition(view, true)\n      view.markCursor = null\n    } else {\n      endComposition(view)\n      // In firefox, if the cursor is after but outside a marked node,\n      // the inserted text won't inherit the marks. So this moves it\n      // inside if necessary.\n      if (browser.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        let sel = view.root.getSelection()\n        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1]\n          if (!before) break\n          if (before.nodeType == 3) {\n            sel.collapse(before, before.nodeValue.length)\n            break\n          } else {\n            node = before\n            offset = -1\n          }\n        }\n      }\n    }\n    view.composing = true\n  }\n  scheduleComposeEnd(view, timeoutComposition)\n}\n\neditHandlers.compositionend = (view, event) => {\n  if (view.composing) {\n    view.composing = false\n    view.compositionEndedAt = event.timeStamp\n    scheduleComposeEnd(view, 20)\n  }\n}\n\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.composingTimeout)\n  if (delay > -1) view.composingTimeout = setTimeout(() => endComposition(view), delay)\n}\n\nexport function clearComposition(view) {\n  view.composing = false\n  while (view.compositionNodes.length > 0) view.compositionNodes.pop().markParentsDirty()\n}\n\nexport function endComposition(view, forceUpdate) {\n  view.domObserver.forceFlush()\n  clearComposition(view)\n  if (forceUpdate || view.docView.dirty) {\n    let sel = selectionFromDOM(view)\n    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel))\n    else view.updateState(view.state)\n    return true\n  }\n  return false\n}\n\nfunction captureCopy(view, dom) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  if (!view.dom.parentNode) return\n  let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"))\n  wrap.appendChild(dom)\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\"\n  let sel = getSelection(), range = document.createRange()\n  range.selectNodeContents(dom)\n  // Done because IE will fire a selectionchange moving the selection\n  // to its start when removeAllRanges is called and the editor still\n  // has focus (which will mess up the editor's selection state).\n  view.dom.blur()\n  sel.removeAllRanges()\n  sel.addRange(range)\n  setTimeout(() => {\n    if (wrap.parentNode) wrap.parentNode.removeChild(wrap)\n    view.focus()\n  }, 50)\n}\n\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n      (browser.ios && browser.webkit_version < 604)\n\nhandlers.copy = editHandlers.cut = (view, e) => {\n  let sel = view.state.selection, cut = e.type == \"cut\"\n  if (sel.empty) return\n\n  // IE and Edge's clipboard interface is completely broken\n  let data = brokenClipboardAPI ? null : e.clipboardData\n  let slice = sel.content(), {dom, text} = serializeForClipboard(view, slice)\n  if (data) {\n    e.preventDefault()\n    data.clearData()\n    data.setData(\"text/html\", dom.innerHTML)\n    data.setData(\"text/plain\", text)\n  } else {\n    captureCopy(view, dom)\n  }\n  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"))\n}\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\nfunction capturePaste(view, e) {\n  if (!view.dom.parentNode) return\n  let plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code\n  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"))\n  if (!plainText) target.contentEditable = \"true\"\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\"\n  target.focus()\n  setTimeout(() => {\n    view.focus()\n    if (target.parentNode) target.parentNode.removeChild(target)\n    if (plainText) doPaste(view, target.value, null, e)\n    else doPaste(view, target.textContent, target.innerHTML, e)\n  }, 50)\n}\n\nfunction doPaste(view, text, html, e) {\n  let slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from)\n  if (view.someProp(\"handlePaste\", f => f(view, e, slice || Slice.empty))) return true\n  if (!slice) return false\n\n  let singleNode = sliceSingleNode(slice)\n  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice)\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"))\n  return true\n}\n\neditHandlers.paste = (view, e) => {\n  let data = brokenClipboardAPI ? null : e.clipboardData\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), e)) e.preventDefault()\n  else capturePaste(view, e)\n}\n\nclass Dragging {\n  constructor(slice, move) {\n    this.slice = slice\n    this.move = move\n  }\n}\n\nconst dragCopyModifier = browser.mac ? \"altKey\" : \"ctrlKey\"\n\nhandlers.dragstart = (view, e) => {\n  let mouseDown = view.mouseDown\n  if (mouseDown) mouseDown.done()\n  if (!e.dataTransfer) return\n\n  let sel = view.state.selection\n  let pos = sel.empty ? null : view.posAtCoords(eventCoords(e))\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) {\n    // In selection\n  } else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)))\n  } else if (e.target && e.target.nodeType == 1) {\n    let desc = view.docView.nearestDesc(e.target, true)\n    if (!desc || !desc.node.type.spec.draggable || desc == view.docView) return\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)))\n  }\n  let slice = view.state.selection.content(), {dom, text} = serializeForClipboard(view, slice)\n  e.dataTransfer.clearData()\n  e.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML)\n  if (!brokenClipboardAPI) e.dataTransfer.setData(\"text/plain\", text)\n  view.dragging = new Dragging(slice, !e[dragCopyModifier])\n}\n\nhandlers.dragend = view => {\n  let dragging = view.dragging\n  window.setTimeout(() => {\n    if (view.dragging == dragging)  view.dragging = null\n  }, 50)\n}\n\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault()\n\neditHandlers.drop = (view, e) => {\n  let dragging = view.dragging\n  view.dragging = null\n\n  if (!e.dataTransfer) return\n\n  let eventPos = view.posAtCoords(eventCoords(e))\n  if (!eventPos) return\n  let $mouse = view.state.doc.resolve(eventPos.pos)\n  if (!$mouse) return\n  let slice = dragging && dragging.slice ||\n      parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"),\n                         brokenClipboardAPI ? null : e.dataTransfer.getData(\"text/html\"), false, $mouse)\n  let move = dragging && !e[dragCopyModifier]\n  if (view.someProp(\"handleDrop\", f => f(view, e, slice || Slice.empty, move))) {\n    e.preventDefault()\n    return\n  }\n  if (!slice) return\n\n  e.preventDefault()\n  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos\n  if (insertPos == null) insertPos = $mouse.pos\n\n  let tr = view.state.tr\n  if (move) tr.deleteSelection()\n\n  let pos = tr.mapping.map(insertPos)\n  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1\n  let beforeInsert = tr.doc\n  if (isNode)\n    tr.replaceRangeWith(pos, pos, slice.content.firstChild)\n  else\n    tr.replaceRange(pos, pos, slice)\n  if (tr.doc.eq(beforeInsert)) return\n\n  let $pos = tr.doc.resolve(pos)\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new NodeSelection($pos))\n  } else {\n    let end = tr.mapping.map(insertPos)\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo)\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)))\n  }\n  view.focus()\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"))\n}\n\nhandlers.focus = view => {\n  if (!view.focused) {\n    view.domObserver.stop()\n    view.dom.classList.add(\"ProseMirror-focused\")\n    view.domObserver.start()\n    view.focused = true\n    setTimeout(() => {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))\n        selectionToDOM(view)\n    }, 20)\n  }\n}\n\nhandlers.blur = view => {\n  if (view.focused) {\n    view.domObserver.stop()\n    view.dom.classList.remove(\"ProseMirror-focused\")\n    view.domObserver.start()\n    view.domObserver.currentSelection.set({})\n    view.focused = false\n  }\n}\n\nhandlers.beforeinput = (view, event) => {\n  // We should probably do more with beforeinput events, but support\n  // is so spotty that I'm still waiting to see where they are going.\n\n  // Very specific hack to deal with backspace sometimes failing on\n  // Chrome Android when after an uneditable node.\n  if (browser.chrome && browser.android && event.inputType == \"deleteContentBackward\") {\n    let {domChangeCount} = view\n    setTimeout(() => {\n      if (view.domChangeCount != domChangeCount) return // Event already had some effect\n      // This bug tends to close the virtual keyboard, so we refocus\n      view.dom.blur()\n      view.focus()\n      if (view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) return\n      let {$cursor} = view.state.selection\n      // Crude approximation of backspace behavior when no command handled it\n      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView())\n    }, 50)\n  }\n}\n\n// Make sure all handlers get registered\nfor (let prop in editHandlers) handlers[prop] = editHandlers[prop]\n","function compareObjs(a, b) {\n  if (a == b) return true\n  for (let p in a) if (a[p] !== b[p]) return false\n  for (let p in b) if (!(p in a)) return false\n  return true\n}\n\nclass WidgetType {\n  constructor(toDOM, spec) {\n    this.spec = spec || noSpec\n    this.side = this.spec.side || 0\n    this.toDOM = toDOM\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let {pos, deleted} = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1)\n    return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n  }\n\n  valid() { return true }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof WidgetType &&\n       (this.spec.key && this.spec.key == other.spec.key ||\n        this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))\n  }\n}\n\nclass InlineType {\n  constructor(attrs, spec) {\n    this.spec = spec || noSpec\n    this.attrs = attrs\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset\n    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset\n    return from >= to ? null : new Decoration(from, to, this)\n  }\n\n  valid(_, span) { return span.from < span.to }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n       compareObjs(this.spec, other.spec))\n  }\n\n  static is(span) { return span.type instanceof InlineType }\n}\n\nclass NodeType {\n  constructor(attrs, spec) {\n    this.spec = spec || noSpec\n    this.attrs = attrs\n  }\n\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.mapResult(span.from + oldOffset, 1)\n    if (from.deleted) return null\n    let to = mapping.mapResult(span.to + oldOffset, -1)\n    if (to.deleted || to.pos <= from.pos) return null\n    return new Decoration(from.pos - offset, to.pos - offset, this)\n  }\n\n  valid(node, span) {\n    let {index, offset} = node.content.findIndex(span.from)\n    return offset == span.from && offset + node.child(index).nodeSize == span.to\n  }\n\n  eq(other) {\n    return this == other ||\n      (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n       compareObjs(this.spec, other.spec))\n  }\n}\n\n// ::- Decoration objects can be provided to the view through the\n// [`decorations` prop](#view.EditorProps.decorations). They come in\n// several variants—see the static members of this class for details.\nexport class Decoration {\n  constructor(from, to, type) {\n    // :: number\n    // The start position of the decoration.\n    this.from = from\n    // :: number\n    // The end position. Will be the same as `from` for [widget\n    // decorations](#view.Decoration^widget).\n    this.to = to\n    this.type = type\n  }\n\n  copy(from, to) {\n    return new Decoration(from, to, this.type)\n  }\n\n  eq(other, offset = 0) {\n    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to\n  }\n\n  map(mapping, offset, oldOffset) {\n    return this.type.map(mapping, this, offset, oldOffset)\n  }\n\n  // :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration\n  // Creates a widget decoration, which is a DOM node that's shown in\n  // the document at the given position. It is recommended that you\n  // delay rendering the widget by passing a function that will be\n  // called when the widget is actually drawn in a view, but you can\n  // also directly pass a DOM node. `getPos` can be used to find the\n  // widget's current document position.\n  //\n  //   spec::- These options are supported:\n  //\n  //     side:: ?number\n  //     Controls which side of the document position this widget is\n  //     associated with. When negative, it is drawn before a cursor\n  //     at its position, and content inserted at that position ends\n  //     up after the widget. When zero (the default) or positive, the\n  //     widget is drawn after the cursor and content inserted there\n  //     ends up before the widget.\n  //\n  //     When there are multiple widgets at a given position, their\n  //     `side` values determine the order in which they appear. Those\n  //     with lower values appear first. The ordering of widgets with\n  //     the same `side` value is unspecified.\n  //\n  //     When `marks` is null, `side` also determines the marks that\n  //     the widget is wrapped in—those of the node before when\n  //     negative, those of the node after when positive.\n  //\n  //     marks:: ?[Mark]\n  //     The precise set of marks to draw around the widget.\n  //\n  //     stopEvent:: ?(event: dom.Event) → bool\n  //     Can be used to control which DOM events, when they bubble out\n  //     of this widget, the editor view should ignore.\n  //\n  //     ignoreSelection:: ?bool\n  //     When set (defaults to false), selection changes inside the\n  //     widget are ignored, and don't cause ProseMirror to try and\n  //     re-sync the selection with its selection state.\n  //\n  //     key:: ?string\n  //     When comparing decorations of this type (in order to decide\n  //     whether it needs to be redrawn), ProseMirror will by default\n  //     compare the widget DOM node by identity. If you pass a key,\n  //     that key will be compared instead, which can be useful when\n  //     you generate decorations on the fly and don't want to store\n  //     and reuse DOM nodes. Make sure that any widgets with the same\n  //     key are interchangeable—if widgets differ in, for example,\n  //     the behavior of some event handler, they should get\n  //     different keys.\n  static widget(pos, toDOM, spec) {\n    return new Decoration(pos, pos, new WidgetType(toDOM, spec))\n  }\n\n  // :: (number, number, DecorationAttrs, ?Object) → Decoration\n  // Creates an inline decoration, which adds the given attributes to\n  // each inline node between `from` and `to`.\n  //\n  //   spec::- These options are recognized:\n  //\n  //     inclusiveStart:: ?bool\n  //     Determines how the left side of the decoration is\n  //     [mapped](#transform.Position_Mapping) when content is\n  //     inserted directly at that position. By default, the decoration\n  //     won't include the new content, but you can set this to `true`\n  //     to make it inclusive.\n  //\n  //     inclusiveEnd:: ?bool\n  //     Determines how the right side of the decoration is mapped.\n  //     See\n  //     [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).\n  static inline(from, to, attrs, spec) {\n    return new Decoration(from, to, new InlineType(attrs, spec))\n  }\n\n  // :: (number, number, DecorationAttrs, ?Object) → Decoration\n  // Creates a node decoration. `from` and `to` should point precisely\n  // before and after a node in the document. That node, and only that\n  // node, will receive the given attributes.\n  //\n  //   spec::-\n  //\n  //   Optional information to store with the decoration. It\n  //   is also used when comparing decorators for equality.\n  static node(from, to, attrs, spec) {\n    return new Decoration(from, to, new NodeType(attrs, spec))\n  }\n\n  // :: Object\n  // The spec provided when creating this decoration. Can be useful\n  // if you've stored extra information in that object.\n  get spec() { return this.type.spec }\n\n  get inline() { return this.type instanceof InlineType }\n}\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nconst none = [], noSpec = {}\n\n// :: class extends DecorationSource\n// A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nexport class DecorationSet {\n  constructor(local, children) {\n    this.local = local && local.length ? local : none\n    this.children = children && children.length ? children : none\n  }\n\n  // :: (Node, [Decoration]) → DecorationSet\n  // Create a set of decorations, using the structure of the given\n  // document.\n  static create(doc, decorations) {\n    return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty\n  }\n\n  // :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]\n  // Find all decorations in this set which touch the given range\n  // (including decorations that start or end directly at the\n  // boundaries) and match the given predicate on their spec. When\n  // `start` and `end` are omitted, all decorations in the set are\n  // considered. When `predicate` isn't given, all decorations are\n  // assumed to match.\n  find(start, end, predicate) {\n    let result = []\n    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate)\n    return result\n  }\n\n  findInner(start, end, result, offset, predicate) {\n    for (let i = 0; i < this.local.length; i++) {\n      let span = this.local[i]\n      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n        result.push(span.copy(span.from + offset, span.to + offset))\n    }\n    for (let i = 0; i < this.children.length; i += 3) {\n      if (this.children[i] < end && this.children[i + 1] > start) {\n        let childOff = this.children[i] + 1\n        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate)\n      }\n    }\n  }\n\n  // :: (Mapping, Node, ?Object) → DecorationSet\n  // Map the set of decorations in response to a change in the\n  // document.\n  //\n  //   options::- An optional set of options.\n  //\n  //     onRemove:: ?(decorationSpec: Object)\n  //     When given, this function will be called for each decoration\n  //     that gets dropped as a result of the mapping, passing the\n  //     spec of that decoration.\n  map(mapping, doc, options) {\n    if (this == empty || mapping.maps.length == 0) return this\n    return this.mapInner(mapping, doc, 0, 0, options || noSpec)\n  }\n\n  mapInner(mapping, node, offset, oldOffset, options) {\n    let newLocal\n    for (let i = 0; i < this.local.length; i++) {\n      let mapped = this.local[i].map(mapping, offset, oldOffset)\n      if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped)\n      else if (options.onRemove) options.onRemove(this.local[i].spec)\n    }\n\n    if (this.children.length)\n      return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options)\n    else\n      return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty\n  }\n\n  // :: (Node, [Decoration]) → DecorationSet\n  // Add the given array of decorations to the ones in the set,\n  // producing a new set. Needs access to the current document to\n  // create the appropriate tree structure.\n  add(doc, decorations) {\n    if (!decorations.length) return this\n    if (this == empty) return DecorationSet.create(doc, decorations)\n    return this.addInner(doc, decorations, 0)\n  }\n\n  addInner(doc, decorations, offset) {\n    let children, childIndex = 0\n    doc.forEach((childNode, childOffset) => {\n      let baseOffset = childOffset + offset, found\n      if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return\n\n      if (!children) children = this.children.slice()\n      while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3\n      if (children[childIndex] == childOffset)\n        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1)\n      else\n        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec))\n      childIndex += 3\n    })\n\n    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset)\n    for (let i = 0; i < local.length; i++) if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1)\n\n    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                             children || this.children)\n  }\n\n  // :: ([Decoration]) → DecorationSet\n  // Create a new set that contains the decorations in this set, minus\n  // the ones in the given array.\n  remove(decorations) {\n    if (decorations.length == 0 || this == empty) return this\n    return this.removeInner(decorations, 0)\n  }\n\n  removeInner(decorations, offset) {\n    let children = this.children, local = this.local\n    for (let i = 0; i < children.length; i += 3) {\n      let found, from = children[i] + offset, to = children[i + 1] + offset\n      for (let j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {\n        if (span.from > from && span.to < to) {\n          decorations[j] = null\n          ;(found || (found = [])).push(span)\n        }\n      }\n      if (!found) continue\n      if (children == this.children) children = this.children.slice()\n      let removed = children[i + 2].removeInner(found, from + 1)\n      if (removed != empty) {\n        children[i + 2] = removed\n      } else {\n        children.splice(i, 3)\n        i -= 3\n      }\n    }\n    if (local.length) for (let i = 0, span; i < decorations.length; i++) if (span = decorations[i]) {\n      for (let j = 0; j < local.length; j++) if (local[j].eq(span, offset)) {\n        if (local == this.local) local = this.local.slice()\n        local.splice(j--, 1)\n      }\n    }\n    if (children == this.children && local == this.local) return this\n    return local.length || children.length ? new DecorationSet(local, children) : empty\n  }\n\n  forChild(offset, node) {\n    if (this == empty) return this\n    if (node.isLeaf) return DecorationSet.empty\n\n    let child, local\n    for (let i = 0; i < this.children.length; i += 3) if (this.children[i] >= offset) {\n      if (this.children[i] == offset) child = this.children[i + 2]\n      break\n    }\n    let start = offset + 1, end = start + node.content.size\n    for (let i = 0; i < this.local.length; i++) {\n      let dec = this.local[i]\n      if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start\n        if (from < to) (local || (local = [])).push(dec.copy(from, to))\n      }\n    }\n    if (local) {\n      let localSet = new DecorationSet(local.sort(byPos))\n      return child ? new DecorationGroup([localSet, child]) : localSet\n    }\n    return child || empty\n  }\n\n  eq(other) {\n    if (this == other) return true\n    if (!(other instanceof DecorationSet) ||\n        this.local.length != other.local.length ||\n        this.children.length != other.children.length) return false\n    for (let i = 0; i < this.local.length; i++)\n      if (!this.local[i].eq(other.local[i])) return false\n    for (let i = 0; i < this.children.length; i += 3)\n      if (this.children[i] != other.children[i] ||\n          this.children[i + 1] != other.children[i + 1] ||\n          !this.children[i + 2].eq(other.children[i + 2])) return false\n    return true\n  }\n\n  locals(node) {\n    return removeOverlap(this.localsInner(node))\n  }\n\n  localsInner(node) {\n    if (this == empty) return none\n    if (node.inlineContent || !this.local.some(InlineType.is)) return this.local\n    let result = []\n    for (let i = 0; i < this.local.length; i++) {\n      if (!(this.local[i].type instanceof InlineType))\n        result.push(this.local[i])\n    }\n    return result\n  }\n}\n\n// DecorationSource:: interface\n// An object that can [provide](#view.EditorProps.decorations)\n// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),\n// and passed to [node views](#view.EditorProps.nodeViews).\n\nconst empty = new DecorationSet()\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty\n\nDecorationSet.removeOverlap = removeOverlap\n\n// :- An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n  constructor(members) {\n    this.members = members\n  }\n\n  forChild(offset, child) {\n    if (child.isLeaf) return DecorationSet.empty\n    let found = []\n    for (let i = 0; i < this.members.length; i++) {\n      let result = this.members[i].forChild(offset, child)\n      if (result == empty) continue\n      if (result instanceof DecorationGroup) found = found.concat(result.members)\n      else found.push(result)\n    }\n    return DecorationGroup.from(found)\n  }\n\n  eq(other) {\n    if (!(other instanceof DecorationGroup) ||\n        other.members.length != this.members.length) return false\n    for (let i = 0; i < this.members.length; i++)\n      if (!this.members[i].eq(other.members[i])) return false\n    return true\n  }\n\n  locals(node) {\n    let result, sorted = true\n    for (let i = 0; i < this.members.length; i++) {\n      let locals = this.members[i].localsInner(node)\n      if (!locals.length) continue\n      if (!result) {\n        result = locals\n      } else {\n        if (sorted) {\n          result = result.slice()\n          sorted = false\n        }\n        for (let j = 0; j < locals.length; j++) result.push(locals[j])\n      }\n    }\n    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n  }\n\n  // : ([DecorationSet]) → union<DecorationSet, DecorationGroup>\n  // Create a group for the given array of decoration sets, or return\n  // a single set when possible.\n  static from(members) {\n    switch (members.length) {\n      case 0: return empty\n      case 1: return members[0]\n      default: return new DecorationGroup(members)\n    }\n  }\n}\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  let children = oldChildren.slice()\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  let shift = (oldStart, oldEnd, newStart, newEnd) => {\n    for (let i = 0; i < children.length; i += 3) {\n      let end = children[i + 1], dSize\n      if (end == -1 || oldStart > end + oldOffset) continue\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1\n      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {\n        children[i] += dSize\n        children[i + 1] += dSize\n      }\n    }\n  }\n  for (let i = 0; i < mapping.maps.length; i++) mapping.maps[i].forEach(shift)\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  let mustRebuild = false\n  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1) { // Touched nodes\n    let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset\n    let {index, offset: childOffset} = node.content.findIndex(fromLocal)\n    let childNode = node.maybeChild(index)\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options)\n      if (mapped != empty) {\n        children[i] = fromLocal\n        children[i + 1] = toLocal\n        children[i + 2] = mapped\n      } else {\n        children[i + 1] = -2\n        mustRebuild = true\n      }\n    } else {\n      mustRebuild = true\n    }\n  }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,\n                                                       offset, oldOffset, options)\n    let built = buildTree(decorations, node, 0, options)\n    newLocal = built.local\n    for (let i = 0; i < children.length; i += 3) if (children[i + 1] < 0) {\n      children.splice(i, 3)\n      i -= 3\n    }\n    for (let i = 0, j = 0; i < built.children.length; i += 3) {\n      let from = built.children[i]\n      while (j < children.length && children[j] < from) j += 3\n      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2])\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) return spans\n  let result = []\n  for (let i = 0; i < spans.length; i++) {\n    let span = spans[i]\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type))\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (let i = 0; i < set.local.length; i++) {\n      let mapped = set.local[i].map(mapping, offset, oldOffset)\n      if (mapped) decorations.push(mapped)\n      else if (options.onRemove) options.onRemove(set.local[i].spec)\n    }\n    for (let i = 0; i < set.children.length; i += 3)\n      gather(set.children[i + 2], set.children[i] + oldOffset + 1)\n  }\n  for (let i = 0; i < children.length; i += 3) if (children[i + 1] == -1)\n    gather(children[i + 2], oldChildren[i] + oldOffset + 1)\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) return null\n  let end = offset + node.nodeSize, found = null\n  for (let i = 0, span; i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      ;(found || (found = [])).push(span)\n      spans[i] = null\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  let result = []\n  for (let i = 0; i < array.length; i++)\n    if (array[i] != null) result.push(array[i])\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtractet from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  let children = [], hasNulls = false\n  node.forEach((childNode, localStart) => {\n    let found = takeSpansForNode(spans, childNode, localStart + offset)\n    if (found) {\n      hasNulls = true\n      let subtree = buildTree(found, childNode, offset + localStart + 1, options)\n      if (subtree != empty)\n        children.push(localStart, localStart + childNode.nodeSize, subtree)\n    }\n  })\n  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos)\n  for (let i = 0; i < locals.length; i++) if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) options.onRemove(locals[i].spec)\n    locals.splice(i--, 1)\n  }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decoration]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  let working = spans\n  for (let i = 0; i < working.length - 1; i++) {\n    let span = working[i]\n    if (span.from != span.to) for (let j = i + 1; j < working.length; j++) {\n      let next = working[j]\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) working = spans.slice()\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to)\n          insertAhead(working, j + 1, next.copy(span.to, next.to))\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) working = spans.slice()\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from)\n          insertAhead(working, j, span.copy(next.from, span.to))\n        }\n        break\n      }\n    }\n  }\n  return working\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) i++\n  array.splice(i, 0, deco)\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nexport function viewDecorations(view) {\n  let found = []\n  view.someProp(\"decorations\", f => {\n    let result = f(view.state)\n    if (result && result != empty) found.push(result)\n  })\n  if (view.cursorWrapper)\n    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]))\n  return DecorationGroup.from(found)\n}\n","import {NodeSelection} from \"prosemirror-state\"\n\nimport {scrollRectIntoView, posAtCoords, coordsAtPos, endOfTextblock, storeScrollPos,\n        resetScrollPos, focusPreventScroll} from \"./domcoords\"\nimport {docViewDesc} from \"./viewdesc\"\nimport {initInput, destroyInput, dispatchEvent, ensureListeners, clearComposition} from \"./input\"\nimport {selectionToDOM, anchorInRightPlace, syncNodeSelection} from \"./selection\"\nimport {Decoration, viewDecorations} from \"./decoration\"\nimport browser from \"./browser\"\n\nexport {Decoration, DecorationSet} from \"./decoration\"\n\n// Exported for testing\nexport {serializeForClipboard as __serializeForClipboard, parseFromClipboard as __parseFromClipboard} from \"./clipboard\"\nexport {endComposition as __endComposition} from \"./input\"\n\n// ::- An editor view manages the DOM structure that represents an\n// editable document. Its state and behavior are determined by its\n// [props](#view.DirectEditorProps).\nexport class EditorView {\n  // :: (?union<dom.Node, (dom.Node), {mount: dom.Node}>, DirectEditorProps)\n  // Create a view. `place` may be a DOM node that the editor should\n  // be appended to, a function that will place it into the document,\n  // or an object whose `mount` property holds the node to use as the\n  // document container. If it is `null`, the editor will not be added\n  // to the document.\n  constructor(place, props) {\n    this._props = props\n    // :: EditorState\n    // The view's current [state](#state.EditorState).\n    this.state = props.state\n\n    this.dispatch = this.dispatch.bind(this)\n\n    this._root = null\n    this.focused = false\n    // Kludge used to work around a Chrome bug\n    this.trackWrites = null\n\n    // :: dom.Element\n    // An editable DOM node containing the document. (You probably\n    // should not directly interfere with its content.)\n    this.dom = (place && place.mount) || document.createElement(\"div\")\n    if (place) {\n      if (place.appendChild) place.appendChild(this.dom)\n      else if (place.apply) place(this.dom)\n      else if (place.mount) this.mounted = true\n    }\n\n    // :: bool\n    // Indicates whether the editor is currently [editable](#view.EditorProps.editable).\n    this.editable = getEditable(this)\n    this.markCursor = null\n    this.cursorWrapper = null\n    updateCursorWrapper(this)\n    this.nodeViews = buildNodeViews(this)\n    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this)\n\n    this.lastSelectedViewDesc = null\n    // :: ?{slice: Slice, move: bool}\n    // When editor content is being dragged, this object contains\n    // information about the dragged slice and whether it is being\n    // copied or moved. At any other time, it is null.\n    this.dragging = null\n\n    initInput(this)\n\n    this.pluginViews = []\n    this.updatePluginViews()\n  }\n\n  // composing:: boolean\n  // Holds `true` when a\n  // [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)\n  // is active.\n\n  // :: DirectEditorProps\n  // The view's current [props](#view.EditorProps).\n  get props() {\n    if (this._props.state != this.state) {\n      let prev = this._props\n      this._props = {}\n      for (let name in prev) this._props[name] = prev[name]\n      this._props.state = this.state\n    }\n    return this._props\n  }\n\n  // :: (DirectEditorProps)\n  // Update the view's props. Will immediately cause an update to\n  // the DOM.\n  update(props) {\n    if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this)\n    this._props = props\n    this.updateStateInner(props.state, true)\n  }\n\n  // :: (DirectEditorProps)\n  // Update the view by updating existing props object with the object\n  // given as argument. Equivalent to `view.update(Object.assign({},\n  // view.props, props))`.\n  setProps(props) {\n    let updated = {}\n    for (let name in this._props) updated[name] = this._props[name]\n    updated.state = this.state\n    for (let name in props) updated[name] = props[name]\n    this.update(updated)\n  }\n\n  // :: (EditorState)\n  // Update the editor's `state` prop, without touching any of the\n  // other props.\n  updateState(state) {\n    this.updateStateInner(state, this.state.plugins != state.plugins)\n  }\n\n  updateStateInner(state, reconfigured) {\n    let prev = this.state, redraw = false, updateSel = false\n    // When stored marks are added, stop composition, so that they can\n    // be displayed.\n    if (state.storedMarks && this.composing) {\n      clearComposition(this)\n      updateSel = true\n    }\n    this.state = state\n    if (reconfigured) {\n      let nodeViews = buildNodeViews(this)\n      if (changedNodeViews(nodeViews, this.nodeViews)) {\n        this.nodeViews = nodeViews\n        redraw = true\n      }\n      ensureListeners(this)\n    }\n\n    this.editable = getEditable(this)\n    updateCursorWrapper(this)\n    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this)\n\n    let scroll = reconfigured ? \"reset\"\n        : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\"\n    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco)\n    if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true\n    let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this)\n\n    if (updateSel) {\n      this.domObserver.stop()\n      // Work around an issue in Chrome, IE, and Edge where changing\n      // the DOM around an active selection puts it into a broken\n      // state where the thing the user sees differs from the\n      // selection reported by the Selection object (#710, #973,\n      // #1011, #1013, #1035).\n      let forceSelUpdate = updateDoc && (browser.ie || browser.chrome) && !this.composing &&\n          !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection)\n      if (updateDoc) {\n        // If the node that the selection points into is written to,\n        // Chrome sometimes starts misreporting the selection, so this\n        // tracks that and forces a selection reset when our update\n        // did write to the node.\n        let chromeKludge = browser.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null\n        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n          this.docView.updateOuterDeco([])\n          this.docView.destroy()\n          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this)\n        }\n        if (chromeKludge && !this.trackWrites) forceSelUpdate = true\n      }\n      // Work around for an issue where an update arriving right between\n      // a DOM selection change and the \"selectionchange\" event for it\n      // can cause a spurious DOM selection update, disrupting mouse\n      // drag selection.\n      if (forceSelUpdate ||\n          !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {\n        selectionToDOM(this, forceSelUpdate)\n      } else {\n        syncNodeSelection(this, state.selection)\n        this.domObserver.setCurSelection()\n      }\n      this.domObserver.start()\n    }\n\n    this.updatePluginViews(prev)\n\n    if (scroll == \"reset\") {\n      this.dom.scrollTop = 0\n    } else if (scroll == \"to selection\") {\n      let startDOM = this.root.getSelection().focusNode\n      if (this.someProp(\"handleScrollToSelection\", f => f(this)))\n        {} // Handled\n      else if (state.selection instanceof NodeSelection)\n        scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM)\n      else\n        scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM)\n    } else if (oldScrollPos) {\n      resetScrollPos(oldScrollPos)\n    }\n  }\n\n  destroyPluginViews() {\n    let view\n    while (view = this.pluginViews.pop()) if (view.destroy) view.destroy()\n  }\n\n  updatePluginViews(prevState) {\n    if (!prevState || prevState.plugins != this.state.plugins) {\n      this.destroyPluginViews()\n      for (let i = 0; i < this.state.plugins.length; i++) {\n        let plugin = this.state.plugins[i]\n        if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this))\n      }\n    } else {\n      for (let i = 0; i < this.pluginViews.length; i++) {\n        let pluginView = this.pluginViews[i]\n        if (pluginView.update) pluginView.update(this, prevState)\n      }\n    }\n  }\n\n  // :: (string, ?(prop: *) → *) → *\n  // Goes over the values of a prop, first those provided directly,\n  // then those from plugins (in order), and calls `f` every time a\n  // non-undefined value is found. When `f` returns a truthy value,\n  // that is immediately returned. When `f` isn't provided, it is\n  // treated as the identity function (the prop value is returned\n  // directly).\n  someProp(propName, f) {\n    let prop = this._props && this._props[propName], value\n    if (prop != null && (value = f ? f(prop) : prop)) return value\n    let plugins = this.state.plugins\n    if (plugins) for (let i = 0; i < plugins.length; i++) {\n      let prop = plugins[i].props[propName]\n      if (prop != null && (value = f ? f(prop) : prop)) return value\n    }\n  }\n\n  // :: () → bool\n  // Query whether the view has focus.\n  hasFocus() {\n    return this.root.activeElement == this.dom\n  }\n\n  // :: ()\n  // Focus the editor.\n  focus() {\n    this.domObserver.stop()\n    if (this.editable) focusPreventScroll(this.dom)\n    selectionToDOM(this)\n    this.domObserver.start()\n  }\n\n  // :: union<dom.Document, dom.DocumentFragment>\n  // Get the document root in which the editor exists. This will\n  // usually be the top-level `document`, but might be a [shadow\n  // DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n  // root if the editor is inside one.\n  get root() {\n    let cached = this._root\n    if (cached == null) for (let search = this.dom.parentNode; search; search = search.parentNode) {\n      if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n        if (!search.getSelection) Object.getPrototypeOf(search).getSelection = () => document.getSelection()\n        return this._root = search\n      }\n    }\n    return cached || document\n  }\n\n  // :: ({left: number, top: number}) → ?{pos: number, inside: number}\n  // Given a pair of viewport coordinates, return the document\n  // position that corresponds to them. May return null if the given\n  // coordinates aren't inside of the editor. When an object is\n  // returned, its `pos` property is the position nearest to the\n  // coordinates, and its `inside` property holds the position of the\n  // inner node that the position falls inside of, or -1 if it is at\n  // the top level, not in any node.\n  posAtCoords(coords) {\n    return posAtCoords(this, coords)\n  }\n\n  // :: (number, number) → {left: number, right: number, top: number, bottom: number}\n  // Returns the viewport rectangle at a given document position.\n  // `left` and `right` will be the same number, as this returns a\n  // flat cursor-ish rectangle. If the position is between two things\n  // that aren't directly adjacent, `side` determines which element is\n  // used. When < 0, the element before the position is used,\n  // otherwise the element after.\n  coordsAtPos(pos, side = 1) {\n    return coordsAtPos(this, pos, side)\n  }\n\n  // :: (number, number) → {node: dom.Node, offset: number}\n  // Find the DOM position that corresponds to the given document\n  // position. When `side` is negative, find the position as close as\n  // possible to the content before the position. When positive,\n  // prefer positions close to the content after the position. When\n  // zero, prefer as shallow a position as possible.\n  //\n  // Note that you should **not** mutate the editor's internal DOM,\n  // only inspect it (and even that is usually not necessary).\n  domAtPos(pos, side = 0) {\n    return this.docView.domFromPos(pos, side)\n  }\n\n  // :: (number) → ?dom.Node\n  // Find the DOM node that represents the document node after the\n  // given position. May return `null` when the position doesn't point\n  // in front of a node or if the node is inside an opaque node view.\n  //\n  // This is intended to be able to call things like\n  // `getBoundingClientRect` on that DOM node. Do **not** mutate the\n  // editor DOM directly, or add styling this way, since that will be\n  // immediately overriden by the editor as it redraws the node.\n  nodeDOM(pos) {\n    let desc = this.docView.descAt(pos)\n    return desc ? desc.nodeDOM : null\n  }\n\n  // :: (dom.Node, number, ?number) → number\n  // Find the document position that corresponds to a given DOM\n  // position. (Whenever possible, it is preferable to inspect the\n  // document structure directly, rather than poking around in the\n  // DOM, but sometimes—for example when interpreting an event\n  // target—you don't have a choice.)\n  //\n  // The `bias` parameter can be used to influence which side of a DOM\n  // node to use when the position is inside a leaf node.\n  posAtDOM(node, offset, bias = -1) {\n    let pos = this.docView.posFromDOM(node, offset, bias)\n    if (pos == null) throw new RangeError(\"DOM position not inside the editor\")\n    return pos\n  }\n\n  // :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n  // Find out whether the selection is at the end of a textblock when\n  // moving in a given direction. When, for example, given `\"left\"`,\n  // it will return true if moving left from the current cursor\n  // position would leave that position's parent textblock. Will apply\n  // to the view's current state by default, but it is possible to\n  // pass a different state.\n  endOfTextblock(dir, state) {\n    return endOfTextblock(this, state || this.state, dir)\n  }\n\n  // :: ()\n  // Removes the editor from the DOM and destroys all [node\n  // views](#view.NodeView).\n  destroy() {\n    if (!this.docView) return\n    destroyInput(this)\n    this.destroyPluginViews()\n    if (this.mounted) {\n      this.docView.update(this.state.doc, [], viewDecorations(this), this)\n      this.dom.textContent = \"\"\n    } else if (this.dom.parentNode) {\n      this.dom.parentNode.removeChild(this.dom)\n    }\n    this.docView.destroy()\n    this.docView = null\n  }\n\n  // Used for testing.\n  dispatchEvent(event) {\n    return dispatchEvent(this, event)\n  }\n\n  // :: (Transaction)\n  // Dispatch a transaction. Will call\n  // [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)\n  // when given, and otherwise defaults to applying the transaction to\n  // the current state and calling\n  // [`updateState`](#view.EditorView.updateState) with the result.\n  // This method is bound to the view instance, so that it can be\n  // easily passed around.\n  dispatch(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction\n    if (dispatchTransaction) dispatchTransaction.call(this, tr)\n    else this.updateState(this.state.apply(tr))\n  }\n}\n\nfunction computeDocDeco(view) {\n  let attrs = Object.create(null)\n  attrs.class = \"ProseMirror\"\n  attrs.contenteditable = String(view.editable)\n\n  view.someProp(\"attributes\", value => {\n    if (typeof value == \"function\") value = value(view.state)\n    if (value) for (let attr in value) {\n      if (attr == \"class\")\n        attrs.class += \" \" + value[attr]\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        attrs[attr] = String(value[attr])\n    }\n  })\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    let dom = document.createElement(\"img\")\n    dom.setAttribute(\"mark-placeholder\", \"true\")\n    view.cursorWrapper = {dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})}\n  } else {\n    view.cursorWrapper = null\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", value => value(view.state) === false)\n}\n\nfunction selectionContextChanged(sel1, sel2) {\n  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head))\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)\n}\n\nfunction buildNodeViews(view) {\n  let result = {}\n  view.someProp(\"nodeViews\", obj => {\n    for (let prop in obj) if (!Object.prototype.hasOwnProperty.call(result, prop))\n      result[prop] = obj[prop]\n  })\n  return result\n}\n\nfunction changedNodeViews(a, b) {\n  let nA = 0, nB = 0\n  for (let prop in a) {\n    if (a[prop] != b[prop]) return true\n    nA++\n  }\n  for (let _ in b) nB++\n  return nA != nB\n}\n\n// EditorProps:: interface\n//\n// Props are configuration values that can be passed to an editor view\n// or included in a plugin. This interface lists the supported props.\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// How a prop is resolved depends on the prop. Handler functions are\n// called one at a time, starting with the base props and then\n// searching through the plugins (in order of appearance) until one of\n// them returns true. For some props, the first plugin that yields a\n// value gets precedence.\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   behavior of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool\n//   Can be used to override the behavior of pasting. `slice` is the\n//   pasted content parsed by the editor, but you can directly access\n//   the event to get at the raw content.\n//\n//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool\n//   Called when something is dropped on the editor. `moved` will be\n//   true if this drop moves from the current selection (which should\n//   thus be deleted).\n//\n//   handleScrollToSelection:: ?(view: EditorView) → bool\n//   Called when the view, after updating its state, tries to scroll\n//   the selection into view. A handler function may return false to\n//   indicate that it did not handle the scrolling and further\n//   handlers or the default behavior should be tried.\n//\n//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection\n//   Can be used to override the way a selection is created when\n//   reading a DOM selection between the given anchor and head.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   transformPastedHTML:: ?(html: string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPastedText:: ?(text: string, plain: bool) → string\n//   Transform pasted plain text. The `plain` flag will be true when\n//   the text is pasted as plain text.\n//\n//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice\n//   A function to parse text from the clipboard into a document\n//   slice. Called after\n//   [`transformPastedText`](#view.EditorProps.transformPastedText).\n//   The default behavior is to split the text into lines, wrap them\n//   in `<p>` tags, and call\n//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.\n//   The `plain` flag will be true when the text is pasted as plain text.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor\n//   functions that produce a [`NodeView`](#view.NodeView) object\n//   implementing the node's display behavior. For nodes, the third\n//   argument `getPos` is a function that can be called to get the\n//   node's current position, which can be useful when creating\n//   transactions to update it. For marks, the third argument is a\n//   boolean that indicates whether the mark's content is inline.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   `innerDecorations` holds the decorations for the node's content.\n//   You can safely ignore this if your view has no content or a\n//   `contentDOM` property, since the editor will draw the decorations\n//   on the content. But if you, for example, want to create a nested\n//   editor with the content, it may make sense to provide it with the\n//   inner decorations.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used.\n//\n//   clipboardTextSerializer:: ?(Slice) → string\n//   A function that will be called to get the text for the current\n//   selection when copying text to the clipboard. By default, the\n//   editor will use [`textBetween`](#model.Node.textBetween) on the\n//   selected range.\n//\n//   decorations:: ?(state: EditorState) → ?DecorationSource\n//   A set of [document decorations](#view.Decoration) to show in the\n//   view.\n//\n//   editable:: ?(state: EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n// DirectEditorProps:: interface extends EditorProps\n//\n// The props object given directly to the editor view supports two\n// fields that can't be used in plugins:\n//\n//   state:: EditorState\n//   The current state of the editor.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. If you specify this, you probably want to\n//   make sure this ends up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply). The callback will be bound to have\n//   the view instance as its `this` binding.\n","import {Selection, NodeSelection} from \"prosemirror-state\"\nimport {Slice} from \"prosemirror-model\"\n\n// ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\nexport class GapCursor extends Selection {\n  // : (ResolvedPos)\n  constructor($pos) {\n    super($pos, $pos)\n  }\n\n  map(doc, mapping) {\n    let $pos = doc.resolve(mapping.map(this.head))\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n\n  content() { return Slice.empty }\n\n  eq(other) {\n    return other instanceof GapCursor && other.head == this.head\n  }\n\n  toJSON() {\n    return {type: \"gapcursor\", pos: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\")\n    return new GapCursor(doc.resolve(json.pos))\n  }\n\n  getBookmark() { return new GapBookmark(this.anchor) }\n\n  static valid($pos) {\n    let parent = $pos.parent\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false\n    let override = parent.type.spec.allowGapCursor\n    if (override != null) return override\n    let deflt = parent.contentMatchAt($pos.index()).defaultType\n    return deflt && deflt.isTextblock\n  }\n\n  static findFrom($pos, dir, mustMove) {\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) return $pos\n      let pos = $pos.pos, next = null\n      // Scan up from this position\n      for (let d = $pos.depth;; d--) {\n        let parent = $pos.node(d)\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1)\n          break\n        } else if (d == 0) {\n          return null\n        }\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      // And then down into the next node\n      for (;;) {\n        let inside = dir > 0 ? next.firstChild : next.lastChild\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir)\n            mustMove = false\n            continue search\n          }\n          break\n        }\n        next = inside\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      return null\n    }\n  }\n}\n\nGapCursor.prototype.visible = false\n\nSelection.jsonID(\"gapcursor\", GapCursor)\n\nclass GapBookmark {\n  constructor(pos) {\n    this.pos = pos\n  }\n  map(mapping) {\n    return new GapBookmark(mapping.map(this.pos))\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.pos)\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n}\n\nfunction closedBefore($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.index(d)\n    // At the start of this parent, look at next one\n    if (index == 0) continue\n    // See if the node before (or its first ancestor) is closed\n    for (let before = $pos.node(d).child(index - 1);; before = before.lastChild) {\n      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) return true\n      if (before.inlineContent) return false\n    }\n  }\n  // Hit start of document\n  return true\n}\n\nfunction closedAfter($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.indexAfter(d), parent = $pos.node(d)\n    if (index == parent.childCount) continue\n    for (let after = parent.child(index);; after = after.firstChild) {\n      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) return true\n      if (after.inlineContent) return false\n    }\n  }\n  return true\n}\n","import {keydownHandler} from \"prosemirror-keymap\"\nimport {TextSelection, NodeSelection, Plugin} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\n\nimport {GapCursor} from \"./gapcursor\"\n\n// :: () → Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\nexport const gapCursor = function() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n\n      createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) return new GapCursor($head)\n      },\n\n      handleClick,\n      handleKeyDown\n    }\n  })\n}\n\nexport {GapCursor}\n\nconst handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n})\n\nfunction arrow(axis, dir) {\n  let dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\")\n  return function(state, dispatch, view) {\n    let sel = state.selection\n    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false\n      mustMove = false\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before())\n    }\n    let $found = GapCursor.findFrom($start, dir, mustMove)\n    if (!$found) return false\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)))\n    return true\n  }\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view.editable) return false\n  let $pos = view.state.doc.resolve(pos)\n  if (!GapCursor.valid($pos)) return false\n  let {inside} = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) return false\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)))\n  return true\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null\n  let node = document.createElement(\"div\")\n  node.className = \"ProseMirror-gapcursor\"\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {key: \"gapcursor\"})])\n}\n","import {\n  Extension,\n  callOrReturn,\n  getExtensionField,\n  ParentConfig,\n} from '@tiptap/core'\nimport { gapCursor } from 'prosemirror-gapcursor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options> {\n    /**\n     * Allow gap cursor\n     */\n    allowGapCursor?:\n      | boolean\n      | null\n      | ((this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['allowGapCursor'],\n      }) => boolean | null),\n  }\n}\n\nexport const Gapcursor = Extension.create({\n  name: 'gapCursor',\n\n  addProseMirrorPlugins() {\n    return [\n      gapCursor(),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    return {\n      allowGapCursor: callOrReturn(getExtensionField(extension, 'allowGapCursor', context)) ?? null,\n    }\n  },\n})\n"],"names":["base","8","9","10","12","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","106","107","108","109","110","111","144","145","160","161","162","163","164","165","173","186","187","188","189","190","191","192","219","220","221","222","229","shift","48","49","50","51","52","53","54","55","56","57","chrome","navigator","exec","userAgent","safari","test","vendor","gecko","mac","platform","ie","brokenModifierNames","i","String","fromCharCode","code","hasOwnProperty","findDiffStart","a","b","pos","let","childCount","childA","child","childB","sameMarkup","isText","text","j","content","size","inner","nodeSize","findDiffEnd","posA","posB","iA","iB","same","minSize","Math","min","length","Fragment","this","nodesBetween","from","to","f","nodeStart","parent","end","start","max","descendants","textBetween","blockSeparator","leafText","separated","node","slice","isLeaf","isBlock","append","other","last","lastChild","first","firstChild","withText","push","cut","result","cutByIndex","empty","replaceChild","index","current","copy","addToStart","concat","addToEnd","eq","found","RangeError","maybeChild","forEach","p","otherPos","findIndex","round","retIndex","curPos","toString","toStringInner","join","toJSON","map","n","fromJSON","schema","value","Array","isArray","nodeFromJSON","fromArray","array","joined","nodes","attrs","const","offset","compareDeep","Mark","type","ReplaceError","message","err","Error","call","__proto__","prototype","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","obj","name","_","json","marks","create","sameSet","setFrom","none","sort","Object","constructor","Slice","openStart","openEnd","removeRange","offsetTo","indexTo","insertInto","dist","insert","canReplace","replace","$from","$to","depth","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","close","replaceThreeWay","parentOffset","replaceTwoWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","insertAt","fragment","removeBetween","maxOpen","openIsolating","spec","isolating","ResolvedPos","path","resolveDepth","val","doc","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","next","sharedDepth","blockRange","pred","d","inlineContent","NodeRange","sameParent","str","resolve","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","emptyAttrs","Node","startPos","textContent","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","isTextblock","isAtom","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","m","markFromJSON","nodeType","ContentMatch","wrapCache","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","indexOf","state","cmp","dfa","connect","compile","edge","edges","exprs","reduce","loop","cur","work","dead","hasRequiredAttrs","checkForDeadEnds","frag","defaultType","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","active","via","reverse","edgeCount","scan","inline","tokens","split","pop","parseExprSeq","eat","parseExprSubscript","typeName","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","undefined","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","atom","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","MarkType","excluded","instance","DOMParser","rules","tags","styles","rule","tag","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","prop","charCodeAt","schemaRules","priority","splice","parseDOM","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","popFromStashMark","applyPending","nextType","pending","markMayApply","parser","open","isOpen","topContext","topOptions","topMatch","topNodeType","find","findPositions","needsBlock","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","prototypeAccessors","top","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","nodeName","insertNode","findInText","findInside","matchAfter","ruleID","toLowerCase","prevItem","nextSibling","appendChild","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","ok","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","toDOM","document","window","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNode","renderSpec","onContent","serializeNodeAndMarks","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","factor16","pow","recoverIndex","MapResult","deleted","recover","StepMap","ranges","inverted","diff","recoverOffset","mapResult","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","JSON","stringify","Mapping","maps","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","mapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","Transform","steps","docs","mustOverride","step","maybeStep","failed","apply","addStep","docChanged","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","jsonID","id","stepClass","StepResult","fail","fromReplace","e","ReplaceStep","super","contentBetween","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","mapFragment","mapped","lift","range","gapStart","gapEnd","splitting","wrappers","setBlockType","mapFrom","$pos","canChangeType","clearIncompatible","startM","endM","setNodeMarkup","newNode","replaceWith","typesAfter","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","fitsTrivially","addMark","removed","added","removing","adding","newSet","s","removeMark","matched","toRemove","parentType","delSteps","allowed","Fitter","fit","replaceStep","delete","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","pass","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","move","replaceRange","deleteRange","targetDepths","preferredTarget","unshift","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","replaceRangeWith","point","insertPoint","covered","classesById","Selection","$anchor","$head","SelectionRange","anchor","tr","lastNode","lastParent","selectionToInsertionEnd","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","bias","AllSelection","atStart","atEnd","cls","selectionClass","getBookmark","between","visible","prototypeAccessors$1","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","NodeBookmark","isSelectable","selectable","sel","selection","setSelection","AllBookmark","startLen","_from","_to","_newFrom","newTo","Transaction","time","Date","now","curSelection","curSelectionFor","storedMarks","updated","meta","selectionSet","setStoredMarks","addStoredMark","removeStoredMark","storedMarksSet","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","setMeta","key","getMeta","isGeneric","scrollIntoView","scrolledIntoView","bind","self","FieldDesc","desc","init","baseFields","config","_marks","_old","prev","Configuration","plugins","fields","pluginsByKey","plugin","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","Plugin","props","keys","createKey","getState","normalizeKeyName","alt","ctrl","mod","modifiers","event","altKey","ctrlKey","metaKey","shiftKey","ie_edge","ie_upto10","ie_11up","ie_version","documentMode","gecko_version","chrome_version","ios","maxTouchPoints","android","webkit","documentElement","webkit_version","domIndex","parentNode","host","reusedRange","textRange","createRange","setEnd","setStart","isEquivalentPosition","off","targetNode","targetOff","scanFor","atomElements","hasBlockDesc","contentEditable","pmViewDesc","selectionCollapsed","domSel","collapsed","isCollapsed","browser","rangeCount","getRangeAt","keyEvent","keyCode","createEvent","initEvent","windowRect","left","right","clientWidth","bottom","clientHeight","getSide","side","clientRect","rect","getBoundingClientRect","scaleX","width","offsetWidth","scaleY","height","offsetHeight","scrollRectIntoView","view","startDOM","scrollThreshold","someProp","scrollMargin","atTop","body","bounding","moveX","moveY","defaultView","scrollBy","startX","scrollLeft","startY","scrollTop","dX","dY","scrollStack","stack","restoreScrollStack","dTop","preventScrollSupported","findOffsetInNode","coords","closest","coordsClosest","dxClosest","rowBot","rowTop","childIndex","rects","getClientRects","dx","len","singleRect","inRect","findOffsetInText","elementFromPoint","element","box","startI","floor","posAtCoords","root","caretPositionFromPoint","caretRangeFromPoint","elt","draggable","targetKludge","outside","docView","nearestDesc","posBefore","posAfter","posFromDOM","posFromCaret","posFromElement","inside","posAtStart","border","BIDI","coordsAtPos","domFromPos","supportEmptyRange","takeSide","flattenV","rectBefore","rectAfter","flattenH","x","y","withFlushedState","viewState","activeElement","updateState","focus","maybeRTL","cachedState","cachedDir","cachedResult","endOfTextblock","nearest","boxes","endOfTextblockVertical","getSelection","modify","oldRange","oldNode","focusNode","oldOff","focusOffset","oldBidiLevel","caretBidiLevel","domAfterPos","removeAllRanges","endOfTextblockHorizontal","ViewDesc","children","dirty","matchesWidget","matchesMark","matchesNode","matchesHack","beforePosition","parseRule","stopEvent","destroy","posBeforeChild","posAtEnd","localPosFromDOM","domBefore","domAfter","onlyNodes","getDesc","nodeDOM","descAt","domAtom","parseRange","fromOffset","toOffset","childBase","emptyChildAt","force","anchorDOM","headDOM","brKludge","anchorNode","anchorOffset","domSelExtended","extend","collapse","DOMException","ignoreMutation","mutation","contentLost","markDirty","startInside","endInside","markParentsDirty","nothing","WidgetViewDesc","widget","raw","classList","stop","ignoreSelection","CompositionViewDesc","textDOM","prototypeAccessors$2","mut","oldValue","MarkViewDesc","custom","nodeViews","replaceNodes","NodeViewDesc","outerDeco","innerDeco","updateChildren","descObj","hasAttribute","applyOuterDeco","CustomNodeViewDesc","TextViewDesc","reparseInView","sameOuterDeco","prototypeAccessors$3","composition","composing","localCompositionNode","updater","ViewTreeUpdater","deco","onWidget","onNode","locals","forChild","decoIndex","restNode","parentIndex","widgets","compareSide","cutAt","filter","iterDeco","insideNode","syncToMarks","placeWidget","findNodeMatch","updateNextNode","addTextblockHacks","destroyRest","changed","protectLocalComposition","renderDescs","oldCSS","cssText","getComputedStyle","listStyle","iosHacks","nearbyTextNode","textPos","childStart","findTextInFragment","removeChild","compositionNodes","update","updateInner","updateOuterDeco","needsWrap","oldDOM","patchOuterDeco","computeOuterDeco","selectNode","deselectNode","remove","removeAttribute","docViewDesc","pmIsDeco","inParent","trackWrites","parentDOM","prototypeAccessors$4","BRHackViewDesc","prototypeAccessors$5","descs","written","childDOM","rm","insertBefore","OuterDecoLevel","noDeco","class","outerDOM","prevComputed","curComputed","curDOM","patchAttributes","prevList","Boolean","curList","removeProperty","lockedNode","lock","preMatch","fI","dI","Map","selectionFromDOM","origin","inWidget","isOnEdge","selectionBetween","editorOwnsSelection","editable","hasFocus","hasSelection","selectionToDOM","syncNodeSelection","domObserver","disconnectSelection","cursorWrapper","img","disabled","selectCursorWrapper","resetEditableFrom","resetEditableTo","brokenSelectBetweenUneditable","temporarilyEditableNear","resetEditable","removeEventListener","hideSelectionGuard","addEventListener","setTimeout","removeClassOnSelectionChange","setCurSelection","connectSelection","destroyBetween","maxKeep","markDesc","has","get","nextDOM","setEditable","wasDraggable","lastSelectedViewDesc","clearNodeSelection","moveSelectionBlock","$side","dispatch","selectHorizontally","mods","nodePos","nodeLen","isIgnorable","skipIgnoredNodesLeft","moveNode","moveOffset","isBlockNode","setSelFocus","skipIgnoredNodesRight","selectVertically","beyond","stopNativeHorizontalDelete","nextNode","switchEditable","captureKeyDown","getMods","safariDownArrowBug","readDOMChange","typeOver","addedNodes","lastSelectionTime","lastSelectionOrigin","newSel","shared","from_","to_","lastKeyCode","startDoc","editableContent","parseBetween","preferredPos","preferredSide","compare","lastKeyCodeTime","change","endA","endB","findDiff","lastIOSEnter","resolveSelection","domChangeCount","nextSel","inlineChange","old","$newStart","$newEnd","skipClosingAndOpening","$next","looksLikeJoin","suppressSelectionUpdates","toB","lastAndroidDelete","markChange","$from1","chFrom","chTo","curMarks","prevMarks","isMarkChange","parsedSel","fromEnd","mayOpen","serializeForClipboard","serializer","detachedDoc","wrapMap","wrapper","parseFromClipboard","html","plainText","inCode","asText","parsed","metas","firstTag","innerHTML","readHTML","contextNode","sliceData","addContext","closeRange","closeSlice","lastWrap","inLast","addToSibling","closeRight","wrapped","withWrappers","normalizeSiblings","sibling","thead","tbody","caption","colgroup","col","td","th","_detachedDoc","implementation","createHTMLDocument","observeOptions","childList","characterData","characterDataOldValue","attributes","attributeOldValue","subtree","useCharData","SelectionState","DOMObserver","handleDOMChange","queue","flushingSoon","observer","MutationObserver","mutations","removedNodes","flushSoon","flush","currentSelection","onCharData","prevValue","onSelectionChange","suppressingSelectionUpdates","forceFlush","clearTimeout","observe","take","takeRecords","disconnect","ignoreSelectionChange","container","commonAncestorContainer","registerMutation","brs","cssChecked","whiteSpace","console","checkCSS","attributeName","handlers","editHandlers","setSelectionOrigin","ensureListeners","currentHandlers","eventHandlers","runCustomHandler","handler","defaultPrevented","eventCoords","clientX","clientY","runHandlerOnContext","propName","updateSelection","focused","handleSingleClick","selectedNode","selectAt","selectClickedNode","selectClickedLeaf","handleDoubleClick","handleTripleClick","defaultTripleClick","forceDOMFlush","endComposition","keydown","inOrNearComposition","preventDefault","lastIOSEnterFallbackTimeout","keyup","keypress","charCode","selectNodeModifier","mousedown","flushed","lastClick","click","dy","isNear","mouseDown","MouseDown","targetPos","allowDefault","mightDrag","targetDesc","addAttr","setUneditable","up","abs","timeStamp","compositionEndedAt","done","touchdown","contextmenu","timeoutComposition","scheduleComposeEnd","delay","composingTimeout","clearComposition","forceUpdate","compositionstart","compositionupdate","markCursor","compositionend","brokenClipboardAPI","doPaste","singleNode","sliceSingleNode","data","clipboardData","clearData","setData","selectNodeContents","blur","captureCopy","paste","getData","capturePaste","Dragging","dragCopyModifier","dragstart","dataTransfer","dragging","dragend","dragover","dragenter","drop","eventPos","$mouse","insertPos","fits","wrapping","dropPoint","isNode","beforeInsert","beforeinput","inputType","compareObjs","WidgetType","noSpec","span","oldOffset","Decoration","valid","InlineType","inclusiveStart","inclusiveEnd","is","DecorationSet","local","decorations","buildTree","predicate","findInner","childOff","mapInner","newLocal","onRemove","oldChildren","oldEnd","newEnd","dSize","mustRebuild","fromLocal","toLocal","childNode","childOffset","gather","mapAndGatherRemainingDecorations","byPos","mapChildren","addInner","baseOffset","takeSpansForNode","moveSpans","withoutNulls","removeInner","dec","localSet","DecorationGroup","removeOverlap","localsInner","members","spans","hasNulls","localStart","working","insertAhead","viewDecorations","sorted","EditorView","place","_props","_root","mount","mounted","getEditable","updateCursorWrapper","buildNodeViews","computeDocDeco","bubbles","eventBelongsToView","initInput","pluginViews","updatePluginViews","contenteditable","handleDOMEvents","updateStateInner","setProps","reconfigured","redraw","updateSel","nA","nB","changedNodeViews","scroll","scrollToSelection","updateDoc","sel1","sel2","newRefTop","oldScrollPos","overflowAnchor","refDOM","refTop","innerHeight","localRect","storeScrollPos","forceSelUpdate","chromeKludge","destroyPluginViews","prevState","pluginView","setActive","stored","preventScroll","focusPreventScroll","getPrototypeOf","domAtPos","posAtDOM","destroyInput","dispatchEvent","dispatchTransaction","GapCursor","GapBookmark","closedBefore","closedAfter","override","allowGapCursor","mustMove","$cur","bindings","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","normalize","baseName","keyName","isChar","direct","fromCode","withShift","axis","dirStr","$found","handleClick","drawGapCursor","className","Gapcursor","Extension","addProseMirrorPlugins","createSelectionBetween","_view","[object Object]","extension","callOrReturn","getExtensionField"],"mappings":"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"}